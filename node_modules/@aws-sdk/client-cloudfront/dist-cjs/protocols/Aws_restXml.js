"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeAws_restXmlGetInvalidationCommand = exports.serializeAws_restXmlGetFunctionCommand = exports.serializeAws_restXmlGetFieldLevelEncryptionProfileConfigCommand = exports.serializeAws_restXmlGetFieldLevelEncryptionProfileCommand = exports.serializeAws_restXmlGetFieldLevelEncryptionConfigCommand = exports.serializeAws_restXmlGetFieldLevelEncryptionCommand = exports.serializeAws_restXmlGetDistributionConfigCommand = exports.serializeAws_restXmlGetDistributionCommand = exports.serializeAws_restXmlGetContinuousDeploymentPolicyConfigCommand = exports.serializeAws_restXmlGetContinuousDeploymentPolicyCommand = exports.serializeAws_restXmlGetCloudFrontOriginAccessIdentityConfigCommand = exports.serializeAws_restXmlGetCloudFrontOriginAccessIdentityCommand = exports.serializeAws_restXmlGetCachePolicyConfigCommand = exports.serializeAws_restXmlGetCachePolicyCommand = exports.serializeAws_restXmlDescribeFunctionCommand = exports.serializeAws_restXmlDeleteStreamingDistributionCommand = exports.serializeAws_restXmlDeleteResponseHeadersPolicyCommand = exports.serializeAws_restXmlDeleteRealtimeLogConfigCommand = exports.serializeAws_restXmlDeletePublicKeyCommand = exports.serializeAws_restXmlDeleteOriginRequestPolicyCommand = exports.serializeAws_restXmlDeleteOriginAccessControlCommand = exports.serializeAws_restXmlDeleteMonitoringSubscriptionCommand = exports.serializeAws_restXmlDeleteKeyGroupCommand = exports.serializeAws_restXmlDeleteFunctionCommand = exports.serializeAws_restXmlDeleteFieldLevelEncryptionProfileCommand = exports.serializeAws_restXmlDeleteFieldLevelEncryptionConfigCommand = exports.serializeAws_restXmlDeleteDistributionCommand = exports.serializeAws_restXmlDeleteContinuousDeploymentPolicyCommand = exports.serializeAws_restXmlDeleteCloudFrontOriginAccessIdentityCommand = exports.serializeAws_restXmlDeleteCachePolicyCommand = exports.serializeAws_restXmlCreateStreamingDistributionWithTagsCommand = exports.serializeAws_restXmlCreateStreamingDistributionCommand = exports.serializeAws_restXmlCreateResponseHeadersPolicyCommand = exports.serializeAws_restXmlCreateRealtimeLogConfigCommand = exports.serializeAws_restXmlCreatePublicKeyCommand = exports.serializeAws_restXmlCreateOriginRequestPolicyCommand = exports.serializeAws_restXmlCreateOriginAccessControlCommand = exports.serializeAws_restXmlCreateMonitoringSubscriptionCommand = exports.serializeAws_restXmlCreateKeyGroupCommand = exports.serializeAws_restXmlCreateInvalidationCommand = exports.serializeAws_restXmlCreateFunctionCommand = exports.serializeAws_restXmlCreateFieldLevelEncryptionProfileCommand = exports.serializeAws_restXmlCreateFieldLevelEncryptionConfigCommand = exports.serializeAws_restXmlCreateDistributionWithTagsCommand = exports.serializeAws_restXmlCreateDistributionCommand = exports.serializeAws_restXmlCreateContinuousDeploymentPolicyCommand = exports.serializeAws_restXmlCreateCloudFrontOriginAccessIdentityCommand = exports.serializeAws_restXmlCreateCachePolicyCommand = exports.serializeAws_restXmlCopyDistributionCommand = exports.serializeAws_restXmlAssociateAliasCommand = void 0;
exports.serializeAws_restXmlUpdateOriginAccessControlCommand = exports.serializeAws_restXmlUpdateKeyGroupCommand = exports.serializeAws_restXmlUpdateFunctionCommand = exports.serializeAws_restXmlUpdateFieldLevelEncryptionProfileCommand = exports.serializeAws_restXmlUpdateFieldLevelEncryptionConfigCommand = exports.serializeAws_restXmlUpdateDistributionCommand = exports.serializeAws_restXmlUpdateContinuousDeploymentPolicyCommand = exports.serializeAws_restXmlUpdateCloudFrontOriginAccessIdentityCommand = exports.serializeAws_restXmlUpdateCachePolicyCommand = exports.serializeAws_restXmlUntagResourceCommand = exports.serializeAws_restXmlTestFunctionCommand = exports.serializeAws_restXmlTagResourceCommand = exports.serializeAws_restXmlPublishFunctionCommand = exports.serializeAws_restXmlListTagsForResourceCommand = exports.serializeAws_restXmlListStreamingDistributionsCommand = exports.serializeAws_restXmlListResponseHeadersPoliciesCommand = exports.serializeAws_restXmlListRealtimeLogConfigsCommand = exports.serializeAws_restXmlListPublicKeysCommand = exports.serializeAws_restXmlListOriginRequestPoliciesCommand = exports.serializeAws_restXmlListOriginAccessControlsCommand = exports.serializeAws_restXmlListKeyGroupsCommand = exports.serializeAws_restXmlListInvalidationsCommand = exports.serializeAws_restXmlListFunctionsCommand = exports.serializeAws_restXmlListFieldLevelEncryptionProfilesCommand = exports.serializeAws_restXmlListFieldLevelEncryptionConfigsCommand = exports.serializeAws_restXmlListDistributionsByWebACLIdCommand = exports.serializeAws_restXmlListDistributionsByResponseHeadersPolicyIdCommand = exports.serializeAws_restXmlListDistributionsByRealtimeLogConfigCommand = exports.serializeAws_restXmlListDistributionsByOriginRequestPolicyIdCommand = exports.serializeAws_restXmlListDistributionsByKeyGroupCommand = exports.serializeAws_restXmlListDistributionsByCachePolicyIdCommand = exports.serializeAws_restXmlListDistributionsCommand = exports.serializeAws_restXmlListContinuousDeploymentPoliciesCommand = exports.serializeAws_restXmlListConflictingAliasesCommand = exports.serializeAws_restXmlListCloudFrontOriginAccessIdentitiesCommand = exports.serializeAws_restXmlListCachePoliciesCommand = exports.serializeAws_restXmlGetStreamingDistributionConfigCommand = exports.serializeAws_restXmlGetStreamingDistributionCommand = exports.serializeAws_restXmlGetResponseHeadersPolicyConfigCommand = exports.serializeAws_restXmlGetResponseHeadersPolicyCommand = exports.serializeAws_restXmlGetRealtimeLogConfigCommand = exports.serializeAws_restXmlGetPublicKeyConfigCommand = exports.serializeAws_restXmlGetPublicKeyCommand = exports.serializeAws_restXmlGetOriginRequestPolicyConfigCommand = exports.serializeAws_restXmlGetOriginRequestPolicyCommand = exports.serializeAws_restXmlGetOriginAccessControlConfigCommand = exports.serializeAws_restXmlGetOriginAccessControlCommand = exports.serializeAws_restXmlGetMonitoringSubscriptionCommand = exports.serializeAws_restXmlGetKeyGroupConfigCommand = exports.serializeAws_restXmlGetKeyGroupCommand = void 0;
exports.deserializeAws_restXmlGetFieldLevelEncryptionCommand = exports.deserializeAws_restXmlGetDistributionConfigCommand = exports.deserializeAws_restXmlGetDistributionCommand = exports.deserializeAws_restXmlGetContinuousDeploymentPolicyConfigCommand = exports.deserializeAws_restXmlGetContinuousDeploymentPolicyCommand = exports.deserializeAws_restXmlGetCloudFrontOriginAccessIdentityConfigCommand = exports.deserializeAws_restXmlGetCloudFrontOriginAccessIdentityCommand = exports.deserializeAws_restXmlGetCachePolicyConfigCommand = exports.deserializeAws_restXmlGetCachePolicyCommand = exports.deserializeAws_restXmlDescribeFunctionCommand = exports.deserializeAws_restXmlDeleteStreamingDistributionCommand = exports.deserializeAws_restXmlDeleteResponseHeadersPolicyCommand = exports.deserializeAws_restXmlDeleteRealtimeLogConfigCommand = exports.deserializeAws_restXmlDeletePublicKeyCommand = exports.deserializeAws_restXmlDeleteOriginRequestPolicyCommand = exports.deserializeAws_restXmlDeleteOriginAccessControlCommand = exports.deserializeAws_restXmlDeleteMonitoringSubscriptionCommand = exports.deserializeAws_restXmlDeleteKeyGroupCommand = exports.deserializeAws_restXmlDeleteFunctionCommand = exports.deserializeAws_restXmlDeleteFieldLevelEncryptionProfileCommand = exports.deserializeAws_restXmlDeleteFieldLevelEncryptionConfigCommand = exports.deserializeAws_restXmlDeleteDistributionCommand = exports.deserializeAws_restXmlDeleteContinuousDeploymentPolicyCommand = exports.deserializeAws_restXmlDeleteCloudFrontOriginAccessIdentityCommand = exports.deserializeAws_restXmlDeleteCachePolicyCommand = exports.deserializeAws_restXmlCreateStreamingDistributionWithTagsCommand = exports.deserializeAws_restXmlCreateStreamingDistributionCommand = exports.deserializeAws_restXmlCreateResponseHeadersPolicyCommand = exports.deserializeAws_restXmlCreateRealtimeLogConfigCommand = exports.deserializeAws_restXmlCreatePublicKeyCommand = exports.deserializeAws_restXmlCreateOriginRequestPolicyCommand = exports.deserializeAws_restXmlCreateOriginAccessControlCommand = exports.deserializeAws_restXmlCreateMonitoringSubscriptionCommand = exports.deserializeAws_restXmlCreateKeyGroupCommand = exports.deserializeAws_restXmlCreateInvalidationCommand = exports.deserializeAws_restXmlCreateFunctionCommand = exports.deserializeAws_restXmlCreateFieldLevelEncryptionProfileCommand = exports.deserializeAws_restXmlCreateFieldLevelEncryptionConfigCommand = exports.deserializeAws_restXmlCreateDistributionWithTagsCommand = exports.deserializeAws_restXmlCreateDistributionCommand = exports.deserializeAws_restXmlCreateContinuousDeploymentPolicyCommand = exports.deserializeAws_restXmlCreateCloudFrontOriginAccessIdentityCommand = exports.deserializeAws_restXmlCreateCachePolicyCommand = exports.deserializeAws_restXmlCopyDistributionCommand = exports.deserializeAws_restXmlAssociateAliasCommand = exports.serializeAws_restXmlUpdateStreamingDistributionCommand = exports.serializeAws_restXmlUpdateResponseHeadersPolicyCommand = exports.serializeAws_restXmlUpdateRealtimeLogConfigCommand = exports.serializeAws_restXmlUpdatePublicKeyCommand = exports.serializeAws_restXmlUpdateOriginRequestPolicyCommand = void 0;
exports.deserializeAws_restXmlUpdateDistributionCommand = exports.deserializeAws_restXmlUpdateContinuousDeploymentPolicyCommand = exports.deserializeAws_restXmlUpdateCloudFrontOriginAccessIdentityCommand = exports.deserializeAws_restXmlUpdateCachePolicyCommand = exports.deserializeAws_restXmlUntagResourceCommand = exports.deserializeAws_restXmlTestFunctionCommand = exports.deserializeAws_restXmlTagResourceCommand = exports.deserializeAws_restXmlPublishFunctionCommand = exports.deserializeAws_restXmlListTagsForResourceCommand = exports.deserializeAws_restXmlListStreamingDistributionsCommand = exports.deserializeAws_restXmlListResponseHeadersPoliciesCommand = exports.deserializeAws_restXmlListRealtimeLogConfigsCommand = exports.deserializeAws_restXmlListPublicKeysCommand = exports.deserializeAws_restXmlListOriginRequestPoliciesCommand = exports.deserializeAws_restXmlListOriginAccessControlsCommand = exports.deserializeAws_restXmlListKeyGroupsCommand = exports.deserializeAws_restXmlListInvalidationsCommand = exports.deserializeAws_restXmlListFunctionsCommand = exports.deserializeAws_restXmlListFieldLevelEncryptionProfilesCommand = exports.deserializeAws_restXmlListFieldLevelEncryptionConfigsCommand = exports.deserializeAws_restXmlListDistributionsByWebACLIdCommand = exports.deserializeAws_restXmlListDistributionsByResponseHeadersPolicyIdCommand = exports.deserializeAws_restXmlListDistributionsByRealtimeLogConfigCommand = exports.deserializeAws_restXmlListDistributionsByOriginRequestPolicyIdCommand = exports.deserializeAws_restXmlListDistributionsByKeyGroupCommand = exports.deserializeAws_restXmlListDistributionsByCachePolicyIdCommand = exports.deserializeAws_restXmlListDistributionsCommand = exports.deserializeAws_restXmlListContinuousDeploymentPoliciesCommand = exports.deserializeAws_restXmlListConflictingAliasesCommand = exports.deserializeAws_restXmlListCloudFrontOriginAccessIdentitiesCommand = exports.deserializeAws_restXmlListCachePoliciesCommand = exports.deserializeAws_restXmlGetStreamingDistributionConfigCommand = exports.deserializeAws_restXmlGetStreamingDistributionCommand = exports.deserializeAws_restXmlGetResponseHeadersPolicyConfigCommand = exports.deserializeAws_restXmlGetResponseHeadersPolicyCommand = exports.deserializeAws_restXmlGetRealtimeLogConfigCommand = exports.deserializeAws_restXmlGetPublicKeyConfigCommand = exports.deserializeAws_restXmlGetPublicKeyCommand = exports.deserializeAws_restXmlGetOriginRequestPolicyConfigCommand = exports.deserializeAws_restXmlGetOriginRequestPolicyCommand = exports.deserializeAws_restXmlGetOriginAccessControlConfigCommand = exports.deserializeAws_restXmlGetOriginAccessControlCommand = exports.deserializeAws_restXmlGetMonitoringSubscriptionCommand = exports.deserializeAws_restXmlGetKeyGroupConfigCommand = exports.deserializeAws_restXmlGetKeyGroupCommand = exports.deserializeAws_restXmlGetInvalidationCommand = exports.deserializeAws_restXmlGetFunctionCommand = exports.deserializeAws_restXmlGetFieldLevelEncryptionProfileConfigCommand = exports.deserializeAws_restXmlGetFieldLevelEncryptionProfileCommand = exports.deserializeAws_restXmlGetFieldLevelEncryptionConfigCommand = void 0;
exports.deserializeAws_restXmlUpdateStreamingDistributionCommand = exports.deserializeAws_restXmlUpdateResponseHeadersPolicyCommand = exports.deserializeAws_restXmlUpdateRealtimeLogConfigCommand = exports.deserializeAws_restXmlUpdatePublicKeyCommand = exports.deserializeAws_restXmlUpdateOriginRequestPolicyCommand = exports.deserializeAws_restXmlUpdateOriginAccessControlCommand = exports.deserializeAws_restXmlUpdateKeyGroupCommand = exports.deserializeAws_restXmlUpdateFunctionCommand = exports.deserializeAws_restXmlUpdateFieldLevelEncryptionProfileCommand = exports.deserializeAws_restXmlUpdateFieldLevelEncryptionConfigCommand = void 0;
const protocol_http_1 = require("@aws-sdk/protocol-http");
const smithy_client_1 = require("@aws-sdk/smithy-client");
const xml_builder_1 = require("@aws-sdk/xml-builder");
const fast_xml_parser_1 = require("fast-xml-parser");
const CloudFrontServiceException_1 = require("../models/CloudFrontServiceException");
const models_0_1 = require("../models/models_0");
const models_1_1 = require("../models/models_1");
const serializeAws_restXmlAssociateAliasCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/distribution/{TargetDistributionId}/associate-alias";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "TargetDistributionId", () => input.TargetDistributionId, "{TargetDistributionId}", false);
    const query = map({
        Alias: [, input.Alias],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlAssociateAliasCommand = serializeAws_restXmlAssociateAliasCommand;
const serializeAws_restXmlCopyDistributionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        staging: [() => isSerializableHeaderValue(input.Staging), () => input.Staging.toString()],
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/distribution/{PrimaryDistributionId}/copy";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "PrimaryDistributionId", () => input.PrimaryDistributionId, "{PrimaryDistributionId}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new xml_builder_1.XmlNode("CopyDistributionRequest");
    bodyNode.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input.CallerReference !== undefined) {
        const node = xml_builder_1.XmlNode.of("string", input.CallerReference).withName("CallerReference");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlCopyDistributionCommand = serializeAws_restXmlCopyDistributionCommand;
const serializeAws_restXmlCreateCachePolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/cache-policy";
    let body;
    if (input.CachePolicyConfig !== undefined) {
        body = serializeAws_restXmlCachePolicyConfig(input.CachePolicyConfig, context);
    }
    let contents;
    if (input.CachePolicyConfig !== undefined) {
        contents = serializeAws_restXmlCachePolicyConfig(input.CachePolicyConfig, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlCreateCachePolicyCommand = serializeAws_restXmlCreateCachePolicyCommand;
const serializeAws_restXmlCreateCloudFrontOriginAccessIdentityCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/origin-access-identity/cloudfront";
    let body;
    if (input.CloudFrontOriginAccessIdentityConfig !== undefined) {
        body = serializeAws_restXmlCloudFrontOriginAccessIdentityConfig(input.CloudFrontOriginAccessIdentityConfig, context);
    }
    let contents;
    if (input.CloudFrontOriginAccessIdentityConfig !== undefined) {
        contents = serializeAws_restXmlCloudFrontOriginAccessIdentityConfig(input.CloudFrontOriginAccessIdentityConfig, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlCreateCloudFrontOriginAccessIdentityCommand = serializeAws_restXmlCreateCloudFrontOriginAccessIdentityCommand;
const serializeAws_restXmlCreateContinuousDeploymentPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/continuous-deployment-policy";
    let body;
    if (input.ContinuousDeploymentPolicyConfig !== undefined) {
        body = serializeAws_restXmlContinuousDeploymentPolicyConfig(input.ContinuousDeploymentPolicyConfig, context);
    }
    let contents;
    if (input.ContinuousDeploymentPolicyConfig !== undefined) {
        contents = serializeAws_restXmlContinuousDeploymentPolicyConfig(input.ContinuousDeploymentPolicyConfig, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlCreateContinuousDeploymentPolicyCommand = serializeAws_restXmlCreateContinuousDeploymentPolicyCommand;
const serializeAws_restXmlCreateDistributionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/distribution";
    let body;
    if (input.DistributionConfig !== undefined) {
        body = serializeAws_restXmlDistributionConfig(input.DistributionConfig, context);
    }
    let contents;
    if (input.DistributionConfig !== undefined) {
        contents = serializeAws_restXmlDistributionConfig(input.DistributionConfig, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlCreateDistributionCommand = serializeAws_restXmlCreateDistributionCommand;
const serializeAws_restXmlCreateDistributionWithTagsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/distribution";
    const query = map({
        WithTags: [, ""],
    });
    let body;
    if (input.DistributionConfigWithTags !== undefined) {
        body = serializeAws_restXmlDistributionConfigWithTags(input.DistributionConfigWithTags, context);
    }
    let contents;
    if (input.DistributionConfigWithTags !== undefined) {
        contents = serializeAws_restXmlDistributionConfigWithTags(input.DistributionConfigWithTags, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlCreateDistributionWithTagsCommand = serializeAws_restXmlCreateDistributionWithTagsCommand;
const serializeAws_restXmlCreateFieldLevelEncryptionConfigCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/field-level-encryption";
    let body;
    if (input.FieldLevelEncryptionConfig !== undefined) {
        body = serializeAws_restXmlFieldLevelEncryptionConfig(input.FieldLevelEncryptionConfig, context);
    }
    let contents;
    if (input.FieldLevelEncryptionConfig !== undefined) {
        contents = serializeAws_restXmlFieldLevelEncryptionConfig(input.FieldLevelEncryptionConfig, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlCreateFieldLevelEncryptionConfigCommand = serializeAws_restXmlCreateFieldLevelEncryptionConfigCommand;
const serializeAws_restXmlCreateFieldLevelEncryptionProfileCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/field-level-encryption-profile";
    let body;
    if (input.FieldLevelEncryptionProfileConfig !== undefined) {
        body = serializeAws_restXmlFieldLevelEncryptionProfileConfig(input.FieldLevelEncryptionProfileConfig, context);
    }
    let contents;
    if (input.FieldLevelEncryptionProfileConfig !== undefined) {
        contents = serializeAws_restXmlFieldLevelEncryptionProfileConfig(input.FieldLevelEncryptionProfileConfig, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlCreateFieldLevelEncryptionProfileCommand = serializeAws_restXmlCreateFieldLevelEncryptionProfileCommand;
const serializeAws_restXmlCreateFunctionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/function";
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new xml_builder_1.XmlNode("CreateFunctionRequest");
    bodyNode.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input.FunctionCode !== undefined) {
        const node = xml_builder_1.XmlNode.of("FunctionBlob", context.base64Encoder(input.FunctionCode)).withName("FunctionCode");
        bodyNode.addChildNode(node);
    }
    if (input.FunctionConfig !== undefined) {
        const node = serializeAws_restXmlFunctionConfig(input.FunctionConfig, context).withName("FunctionConfig");
        bodyNode.addChildNode(node);
    }
    if (input.Name !== undefined) {
        const node = xml_builder_1.XmlNode.of("FunctionName", input.Name).withName("Name");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlCreateFunctionCommand = serializeAws_restXmlCreateFunctionCommand;
const serializeAws_restXmlCreateInvalidationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/distribution/{DistributionId}/invalidation";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "DistributionId", () => input.DistributionId, "{DistributionId}", false);
    let body;
    if (input.InvalidationBatch !== undefined) {
        body = serializeAws_restXmlInvalidationBatch(input.InvalidationBatch, context);
    }
    let contents;
    if (input.InvalidationBatch !== undefined) {
        contents = serializeAws_restXmlInvalidationBatch(input.InvalidationBatch, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlCreateInvalidationCommand = serializeAws_restXmlCreateInvalidationCommand;
const serializeAws_restXmlCreateKeyGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/key-group";
    let body;
    if (input.KeyGroupConfig !== undefined) {
        body = serializeAws_restXmlKeyGroupConfig(input.KeyGroupConfig, context);
    }
    let contents;
    if (input.KeyGroupConfig !== undefined) {
        contents = serializeAws_restXmlKeyGroupConfig(input.KeyGroupConfig, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlCreateKeyGroupCommand = serializeAws_restXmlCreateKeyGroupCommand;
const serializeAws_restXmlCreateMonitoringSubscriptionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/distributions/{DistributionId}/monitoring-subscription";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "DistributionId", () => input.DistributionId, "{DistributionId}", false);
    let body;
    if (input.MonitoringSubscription !== undefined) {
        body = serializeAws_restXmlMonitoringSubscription(input.MonitoringSubscription, context);
    }
    let contents;
    if (input.MonitoringSubscription !== undefined) {
        contents = serializeAws_restXmlMonitoringSubscription(input.MonitoringSubscription, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlCreateMonitoringSubscriptionCommand = serializeAws_restXmlCreateMonitoringSubscriptionCommand;
const serializeAws_restXmlCreateOriginAccessControlCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/origin-access-control";
    let body;
    if (input.OriginAccessControlConfig !== undefined) {
        body = serializeAws_restXmlOriginAccessControlConfig(input.OriginAccessControlConfig, context);
    }
    let contents;
    if (input.OriginAccessControlConfig !== undefined) {
        contents = serializeAws_restXmlOriginAccessControlConfig(input.OriginAccessControlConfig, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlCreateOriginAccessControlCommand = serializeAws_restXmlCreateOriginAccessControlCommand;
const serializeAws_restXmlCreateOriginRequestPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/origin-request-policy";
    let body;
    if (input.OriginRequestPolicyConfig !== undefined) {
        body = serializeAws_restXmlOriginRequestPolicyConfig(input.OriginRequestPolicyConfig, context);
    }
    let contents;
    if (input.OriginRequestPolicyConfig !== undefined) {
        contents = serializeAws_restXmlOriginRequestPolicyConfig(input.OriginRequestPolicyConfig, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlCreateOriginRequestPolicyCommand = serializeAws_restXmlCreateOriginRequestPolicyCommand;
const serializeAws_restXmlCreatePublicKeyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/public-key";
    let body;
    if (input.PublicKeyConfig !== undefined) {
        body = serializeAws_restXmlPublicKeyConfig(input.PublicKeyConfig, context);
    }
    let contents;
    if (input.PublicKeyConfig !== undefined) {
        contents = serializeAws_restXmlPublicKeyConfig(input.PublicKeyConfig, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlCreatePublicKeyCommand = serializeAws_restXmlCreatePublicKeyCommand;
const serializeAws_restXmlCreateRealtimeLogConfigCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/realtime-log-config";
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new xml_builder_1.XmlNode("CreateRealtimeLogConfigRequest");
    bodyNode.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input.EndPoints !== undefined) {
        const nodes = serializeAws_restXmlEndPointList(input.EndPoints, context);
        const containerNode = new xml_builder_1.XmlNode("EndPoints");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.Fields !== undefined) {
        const nodes = serializeAws_restXmlFieldList(input.Fields, context);
        const containerNode = new xml_builder_1.XmlNode("Fields");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.Name !== undefined) {
        const node = xml_builder_1.XmlNode.of("string", input.Name).withName("Name");
        bodyNode.addChildNode(node);
    }
    if (input.SamplingRate !== undefined) {
        const node = xml_builder_1.XmlNode.of("long", String(input.SamplingRate)).withName("SamplingRate");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlCreateRealtimeLogConfigCommand = serializeAws_restXmlCreateRealtimeLogConfigCommand;
const serializeAws_restXmlCreateResponseHeadersPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/response-headers-policy";
    let body;
    if (input.ResponseHeadersPolicyConfig !== undefined) {
        body = serializeAws_restXmlResponseHeadersPolicyConfig(input.ResponseHeadersPolicyConfig, context);
    }
    let contents;
    if (input.ResponseHeadersPolicyConfig !== undefined) {
        contents = serializeAws_restXmlResponseHeadersPolicyConfig(input.ResponseHeadersPolicyConfig, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlCreateResponseHeadersPolicyCommand = serializeAws_restXmlCreateResponseHeadersPolicyCommand;
const serializeAws_restXmlCreateStreamingDistributionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/streaming-distribution";
    let body;
    if (input.StreamingDistributionConfig !== undefined) {
        body = serializeAws_restXmlStreamingDistributionConfig(input.StreamingDistributionConfig, context);
    }
    let contents;
    if (input.StreamingDistributionConfig !== undefined) {
        contents = serializeAws_restXmlStreamingDistributionConfig(input.StreamingDistributionConfig, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlCreateStreamingDistributionCommand = serializeAws_restXmlCreateStreamingDistributionCommand;
const serializeAws_restXmlCreateStreamingDistributionWithTagsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/streaming-distribution";
    const query = map({
        WithTags: [, ""],
    });
    let body;
    if (input.StreamingDistributionConfigWithTags !== undefined) {
        body = serializeAws_restXmlStreamingDistributionConfigWithTags(input.StreamingDistributionConfigWithTags, context);
    }
    let contents;
    if (input.StreamingDistributionConfigWithTags !== undefined) {
        contents = serializeAws_restXmlStreamingDistributionConfigWithTags(input.StreamingDistributionConfigWithTags, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlCreateStreamingDistributionWithTagsCommand = serializeAws_restXmlCreateStreamingDistributionWithTagsCommand;
const serializeAws_restXmlDeleteCachePolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/cache-policy/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlDeleteCachePolicyCommand = serializeAws_restXmlDeleteCachePolicyCommand;
const serializeAws_restXmlDeleteCloudFrontOriginAccessIdentityCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/origin-access-identity/cloudfront/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlDeleteCloudFrontOriginAccessIdentityCommand = serializeAws_restXmlDeleteCloudFrontOriginAccessIdentityCommand;
const serializeAws_restXmlDeleteContinuousDeploymentPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/continuous-deployment-policy/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlDeleteContinuousDeploymentPolicyCommand = serializeAws_restXmlDeleteContinuousDeploymentPolicyCommand;
const serializeAws_restXmlDeleteDistributionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/distribution/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlDeleteDistributionCommand = serializeAws_restXmlDeleteDistributionCommand;
const serializeAws_restXmlDeleteFieldLevelEncryptionConfigCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/field-level-encryption/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlDeleteFieldLevelEncryptionConfigCommand = serializeAws_restXmlDeleteFieldLevelEncryptionConfigCommand;
const serializeAws_restXmlDeleteFieldLevelEncryptionProfileCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/field-level-encryption-profile/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlDeleteFieldLevelEncryptionProfileCommand = serializeAws_restXmlDeleteFieldLevelEncryptionProfileCommand;
const serializeAws_restXmlDeleteFunctionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/function/{Name}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlDeleteFunctionCommand = serializeAws_restXmlDeleteFunctionCommand;
const serializeAws_restXmlDeleteKeyGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/key-group/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlDeleteKeyGroupCommand = serializeAws_restXmlDeleteKeyGroupCommand;
const serializeAws_restXmlDeleteMonitoringSubscriptionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/distributions/{DistributionId}/monitoring-subscription";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "DistributionId", () => input.DistributionId, "{DistributionId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlDeleteMonitoringSubscriptionCommand = serializeAws_restXmlDeleteMonitoringSubscriptionCommand;
const serializeAws_restXmlDeleteOriginAccessControlCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/origin-access-control/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlDeleteOriginAccessControlCommand = serializeAws_restXmlDeleteOriginAccessControlCommand;
const serializeAws_restXmlDeleteOriginRequestPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/origin-request-policy/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlDeleteOriginRequestPolicyCommand = serializeAws_restXmlDeleteOriginRequestPolicyCommand;
const serializeAws_restXmlDeletePublicKeyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/public-key/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlDeletePublicKeyCommand = serializeAws_restXmlDeletePublicKeyCommand;
const serializeAws_restXmlDeleteRealtimeLogConfigCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/delete-realtime-log-config";
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new xml_builder_1.XmlNode("DeleteRealtimeLogConfigRequest");
    bodyNode.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input.ARN !== undefined) {
        const node = xml_builder_1.XmlNode.of("string", input.ARN).withName("ARN");
        bodyNode.addChildNode(node);
    }
    if (input.Name !== undefined) {
        const node = xml_builder_1.XmlNode.of("string", input.Name).withName("Name");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlDeleteRealtimeLogConfigCommand = serializeAws_restXmlDeleteRealtimeLogConfigCommand;
const serializeAws_restXmlDeleteResponseHeadersPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/response-headers-policy/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlDeleteResponseHeadersPolicyCommand = serializeAws_restXmlDeleteResponseHeadersPolicyCommand;
const serializeAws_restXmlDeleteStreamingDistributionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/streaming-distribution/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlDeleteStreamingDistributionCommand = serializeAws_restXmlDeleteStreamingDistributionCommand;
const serializeAws_restXmlDescribeFunctionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/function/{Name}/describe";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    const query = map({
        Stage: [, input.Stage],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlDescribeFunctionCommand = serializeAws_restXmlDescribeFunctionCommand;
const serializeAws_restXmlGetCachePolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/cache-policy/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetCachePolicyCommand = serializeAws_restXmlGetCachePolicyCommand;
const serializeAws_restXmlGetCachePolicyConfigCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/cache-policy/{Id}/config";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetCachePolicyConfigCommand = serializeAws_restXmlGetCachePolicyConfigCommand;
const serializeAws_restXmlGetCloudFrontOriginAccessIdentityCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/origin-access-identity/cloudfront/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetCloudFrontOriginAccessIdentityCommand = serializeAws_restXmlGetCloudFrontOriginAccessIdentityCommand;
const serializeAws_restXmlGetCloudFrontOriginAccessIdentityConfigCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/origin-access-identity/cloudfront/{Id}/config";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetCloudFrontOriginAccessIdentityConfigCommand = serializeAws_restXmlGetCloudFrontOriginAccessIdentityConfigCommand;
const serializeAws_restXmlGetContinuousDeploymentPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/continuous-deployment-policy/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetContinuousDeploymentPolicyCommand = serializeAws_restXmlGetContinuousDeploymentPolicyCommand;
const serializeAws_restXmlGetContinuousDeploymentPolicyConfigCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/continuous-deployment-policy/{Id}/config";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetContinuousDeploymentPolicyConfigCommand = serializeAws_restXmlGetContinuousDeploymentPolicyConfigCommand;
const serializeAws_restXmlGetDistributionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/distribution/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetDistributionCommand = serializeAws_restXmlGetDistributionCommand;
const serializeAws_restXmlGetDistributionConfigCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/distribution/{Id}/config";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetDistributionConfigCommand = serializeAws_restXmlGetDistributionConfigCommand;
const serializeAws_restXmlGetFieldLevelEncryptionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/field-level-encryption/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetFieldLevelEncryptionCommand = serializeAws_restXmlGetFieldLevelEncryptionCommand;
const serializeAws_restXmlGetFieldLevelEncryptionConfigCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/field-level-encryption/{Id}/config";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetFieldLevelEncryptionConfigCommand = serializeAws_restXmlGetFieldLevelEncryptionConfigCommand;
const serializeAws_restXmlGetFieldLevelEncryptionProfileCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/field-level-encryption-profile/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetFieldLevelEncryptionProfileCommand = serializeAws_restXmlGetFieldLevelEncryptionProfileCommand;
const serializeAws_restXmlGetFieldLevelEncryptionProfileConfigCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/field-level-encryption-profile/{Id}/config";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetFieldLevelEncryptionProfileConfigCommand = serializeAws_restXmlGetFieldLevelEncryptionProfileConfigCommand;
const serializeAws_restXmlGetFunctionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/function/{Name}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    const query = map({
        Stage: [, input.Stage],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlGetFunctionCommand = serializeAws_restXmlGetFunctionCommand;
const serializeAws_restXmlGetInvalidationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/distribution/{DistributionId}/invalidation/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "DistributionId", () => input.DistributionId, "{DistributionId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetInvalidationCommand = serializeAws_restXmlGetInvalidationCommand;
const serializeAws_restXmlGetKeyGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/key-group/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetKeyGroupCommand = serializeAws_restXmlGetKeyGroupCommand;
const serializeAws_restXmlGetKeyGroupConfigCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/key-group/{Id}/config";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetKeyGroupConfigCommand = serializeAws_restXmlGetKeyGroupConfigCommand;
const serializeAws_restXmlGetMonitoringSubscriptionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/distributions/{DistributionId}/monitoring-subscription";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "DistributionId", () => input.DistributionId, "{DistributionId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetMonitoringSubscriptionCommand = serializeAws_restXmlGetMonitoringSubscriptionCommand;
const serializeAws_restXmlGetOriginAccessControlCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/origin-access-control/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetOriginAccessControlCommand = serializeAws_restXmlGetOriginAccessControlCommand;
const serializeAws_restXmlGetOriginAccessControlConfigCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/origin-access-control/{Id}/config";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetOriginAccessControlConfigCommand = serializeAws_restXmlGetOriginAccessControlConfigCommand;
const serializeAws_restXmlGetOriginRequestPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/origin-request-policy/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetOriginRequestPolicyCommand = serializeAws_restXmlGetOriginRequestPolicyCommand;
const serializeAws_restXmlGetOriginRequestPolicyConfigCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/origin-request-policy/{Id}/config";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetOriginRequestPolicyConfigCommand = serializeAws_restXmlGetOriginRequestPolicyConfigCommand;
const serializeAws_restXmlGetPublicKeyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/public-key/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetPublicKeyCommand = serializeAws_restXmlGetPublicKeyCommand;
const serializeAws_restXmlGetPublicKeyConfigCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/public-key/{Id}/config";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetPublicKeyConfigCommand = serializeAws_restXmlGetPublicKeyConfigCommand;
const serializeAws_restXmlGetRealtimeLogConfigCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/get-realtime-log-config";
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new xml_builder_1.XmlNode("GetRealtimeLogConfigRequest");
    bodyNode.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input.ARN !== undefined) {
        const node = xml_builder_1.XmlNode.of("string", input.ARN).withName("ARN");
        bodyNode.addChildNode(node);
    }
    if (input.Name !== undefined) {
        const node = xml_builder_1.XmlNode.of("string", input.Name).withName("Name");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetRealtimeLogConfigCommand = serializeAws_restXmlGetRealtimeLogConfigCommand;
const serializeAws_restXmlGetResponseHeadersPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/response-headers-policy/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetResponseHeadersPolicyCommand = serializeAws_restXmlGetResponseHeadersPolicyCommand;
const serializeAws_restXmlGetResponseHeadersPolicyConfigCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/response-headers-policy/{Id}/config";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetResponseHeadersPolicyConfigCommand = serializeAws_restXmlGetResponseHeadersPolicyConfigCommand;
const serializeAws_restXmlGetStreamingDistributionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/streaming-distribution/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetStreamingDistributionCommand = serializeAws_restXmlGetStreamingDistributionCommand;
const serializeAws_restXmlGetStreamingDistributionConfigCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/streaming-distribution/{Id}/config";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlGetStreamingDistributionConfigCommand = serializeAws_restXmlGetStreamingDistributionConfigCommand;
const serializeAws_restXmlListCachePoliciesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/cache-policy";
    const query = map({
        Type: [, input.Type],
        Marker: [, input.Marker],
        MaxItems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlListCachePoliciesCommand = serializeAws_restXmlListCachePoliciesCommand;
const serializeAws_restXmlListCloudFrontOriginAccessIdentitiesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/origin-access-identity/cloudfront";
    const query = map({
        Marker: [, input.Marker],
        MaxItems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlListCloudFrontOriginAccessIdentitiesCommand = serializeAws_restXmlListCloudFrontOriginAccessIdentitiesCommand;
const serializeAws_restXmlListConflictingAliasesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/conflicting-alias";
    const query = map({
        DistributionId: [, input.DistributionId],
        Alias: [, input.Alias],
        Marker: [, input.Marker],
        MaxItems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlListConflictingAliasesCommand = serializeAws_restXmlListConflictingAliasesCommand;
const serializeAws_restXmlListContinuousDeploymentPoliciesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/continuous-deployment-policy";
    const query = map({
        Marker: [, input.Marker],
        MaxItems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlListContinuousDeploymentPoliciesCommand = serializeAws_restXmlListContinuousDeploymentPoliciesCommand;
const serializeAws_restXmlListDistributionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/distribution";
    const query = map({
        Marker: [, input.Marker],
        MaxItems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlListDistributionsCommand = serializeAws_restXmlListDistributionsCommand;
const serializeAws_restXmlListDistributionsByCachePolicyIdCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/distributionsByCachePolicyId/{CachePolicyId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "CachePolicyId", () => input.CachePolicyId, "{CachePolicyId}", false);
    const query = map({
        Marker: [, input.Marker],
        MaxItems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlListDistributionsByCachePolicyIdCommand = serializeAws_restXmlListDistributionsByCachePolicyIdCommand;
const serializeAws_restXmlListDistributionsByKeyGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/distributionsByKeyGroupId/{KeyGroupId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "KeyGroupId", () => input.KeyGroupId, "{KeyGroupId}", false);
    const query = map({
        Marker: [, input.Marker],
        MaxItems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlListDistributionsByKeyGroupCommand = serializeAws_restXmlListDistributionsByKeyGroupCommand;
const serializeAws_restXmlListDistributionsByOriginRequestPolicyIdCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/distributionsByOriginRequestPolicyId/{OriginRequestPolicyId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "OriginRequestPolicyId", () => input.OriginRequestPolicyId, "{OriginRequestPolicyId}", false);
    const query = map({
        Marker: [, input.Marker],
        MaxItems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlListDistributionsByOriginRequestPolicyIdCommand = serializeAws_restXmlListDistributionsByOriginRequestPolicyIdCommand;
const serializeAws_restXmlListDistributionsByRealtimeLogConfigCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/distributionsByRealtimeLogConfig";
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new xml_builder_1.XmlNode("ListDistributionsByRealtimeLogConfigRequest");
    bodyNode.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input.Marker !== undefined) {
        const node = xml_builder_1.XmlNode.of("string", input.Marker).withName("Marker");
        bodyNode.addChildNode(node);
    }
    if (input.MaxItems !== undefined) {
        const node = xml_builder_1.XmlNode.of("Integer", String(input.MaxItems)).withName("MaxItems");
        bodyNode.addChildNode(node);
    }
    if (input.RealtimeLogConfigArn !== undefined) {
        const node = xml_builder_1.XmlNode.of("string", input.RealtimeLogConfigArn).withName("RealtimeLogConfigArn");
        bodyNode.addChildNode(node);
    }
    if (input.RealtimeLogConfigName !== undefined) {
        const node = xml_builder_1.XmlNode.of("string", input.RealtimeLogConfigName).withName("RealtimeLogConfigName");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlListDistributionsByRealtimeLogConfigCommand = serializeAws_restXmlListDistributionsByRealtimeLogConfigCommand;
const serializeAws_restXmlListDistributionsByResponseHeadersPolicyIdCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/distributionsByResponseHeadersPolicyId/{ResponseHeadersPolicyId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ResponseHeadersPolicyId", () => input.ResponseHeadersPolicyId, "{ResponseHeadersPolicyId}", false);
    const query = map({
        Marker: [, input.Marker],
        MaxItems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlListDistributionsByResponseHeadersPolicyIdCommand = serializeAws_restXmlListDistributionsByResponseHeadersPolicyIdCommand;
const serializeAws_restXmlListDistributionsByWebACLIdCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/distributionsByWebACLId/{WebACLId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "WebACLId", () => input.WebACLId, "{WebACLId}", false);
    const query = map({
        Marker: [, input.Marker],
        MaxItems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlListDistributionsByWebACLIdCommand = serializeAws_restXmlListDistributionsByWebACLIdCommand;
const serializeAws_restXmlListFieldLevelEncryptionConfigsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/field-level-encryption";
    const query = map({
        Marker: [, input.Marker],
        MaxItems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlListFieldLevelEncryptionConfigsCommand = serializeAws_restXmlListFieldLevelEncryptionConfigsCommand;
const serializeAws_restXmlListFieldLevelEncryptionProfilesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/field-level-encryption-profile";
    const query = map({
        Marker: [, input.Marker],
        MaxItems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlListFieldLevelEncryptionProfilesCommand = serializeAws_restXmlListFieldLevelEncryptionProfilesCommand;
const serializeAws_restXmlListFunctionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/function";
    const query = map({
        Marker: [, input.Marker],
        MaxItems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
        Stage: [, input.Stage],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlListFunctionsCommand = serializeAws_restXmlListFunctionsCommand;
const serializeAws_restXmlListInvalidationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/distribution/{DistributionId}/invalidation";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "DistributionId", () => input.DistributionId, "{DistributionId}", false);
    const query = map({
        Marker: [, input.Marker],
        MaxItems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlListInvalidationsCommand = serializeAws_restXmlListInvalidationsCommand;
const serializeAws_restXmlListKeyGroupsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/key-group";
    const query = map({
        Marker: [, input.Marker],
        MaxItems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlListKeyGroupsCommand = serializeAws_restXmlListKeyGroupsCommand;
const serializeAws_restXmlListOriginAccessControlsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/origin-access-control";
    const query = map({
        Marker: [, input.Marker],
        MaxItems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlListOriginAccessControlsCommand = serializeAws_restXmlListOriginAccessControlsCommand;
const serializeAws_restXmlListOriginRequestPoliciesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/origin-request-policy";
    const query = map({
        Type: [, input.Type],
        Marker: [, input.Marker],
        MaxItems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlListOriginRequestPoliciesCommand = serializeAws_restXmlListOriginRequestPoliciesCommand;
const serializeAws_restXmlListPublicKeysCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/public-key";
    const query = map({
        Marker: [, input.Marker],
        MaxItems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlListPublicKeysCommand = serializeAws_restXmlListPublicKeysCommand;
const serializeAws_restXmlListRealtimeLogConfigsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/realtime-log-config";
    const query = map({
        MaxItems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
        Marker: [, input.Marker],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlListRealtimeLogConfigsCommand = serializeAws_restXmlListRealtimeLogConfigsCommand;
const serializeAws_restXmlListResponseHeadersPoliciesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/response-headers-policy";
    const query = map({
        Type: [, input.Type],
        Marker: [, input.Marker],
        MaxItems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlListResponseHeadersPoliciesCommand = serializeAws_restXmlListResponseHeadersPoliciesCommand;
const serializeAws_restXmlListStreamingDistributionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/streaming-distribution";
    const query = map({
        Marker: [, input.Marker],
        MaxItems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlListStreamingDistributionsCommand = serializeAws_restXmlListStreamingDistributionsCommand;
const serializeAws_restXmlListTagsForResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/tagging";
    const query = map({
        Resource: [, input.Resource],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlListTagsForResourceCommand = serializeAws_restXmlListTagsForResourceCommand;
const serializeAws_restXmlPublishFunctionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/function/{Name}/publish";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlPublishFunctionCommand = serializeAws_restXmlPublishFunctionCommand;
const serializeAws_restXmlTagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/tagging";
    const query = map({
        Operation: [, "Tag"],
        Resource: [, input.Resource],
    });
    let body;
    if (input.Tags !== undefined) {
        body = serializeAws_restXmlTags(input.Tags, context);
    }
    let contents;
    if (input.Tags !== undefined) {
        contents = serializeAws_restXmlTags(input.Tags, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlTagResourceCommand = serializeAws_restXmlTagResourceCommand;
const serializeAws_restXmlTestFunctionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/function/{Name}/test";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new xml_builder_1.XmlNode("TestFunctionRequest");
    bodyNode.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input.EventObject !== undefined) {
        const node = xml_builder_1.XmlNode.of("FunctionEventObject", context.base64Encoder(input.EventObject)).withName("EventObject");
        bodyNode.addChildNode(node);
    }
    if (input.Stage !== undefined) {
        const node = xml_builder_1.XmlNode.of("FunctionStage", input.Stage).withName("Stage");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlTestFunctionCommand = serializeAws_restXmlTestFunctionCommand;
const serializeAws_restXmlUntagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/tagging";
    const query = map({
        Operation: [, "Untag"],
        Resource: [, input.Resource],
    });
    let body;
    if (input.TagKeys !== undefined) {
        body = serializeAws_restXmlTagKeys(input.TagKeys, context);
    }
    let contents;
    if (input.TagKeys !== undefined) {
        contents = serializeAws_restXmlTagKeys(input.TagKeys, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restXmlUntagResourceCommand = serializeAws_restXmlUntagResourceCommand;
const serializeAws_restXmlUpdateCachePolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/cache-policy/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    if (input.CachePolicyConfig !== undefined) {
        body = serializeAws_restXmlCachePolicyConfig(input.CachePolicyConfig, context);
    }
    let contents;
    if (input.CachePolicyConfig !== undefined) {
        contents = serializeAws_restXmlCachePolicyConfig(input.CachePolicyConfig, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlUpdateCachePolicyCommand = serializeAws_restXmlUpdateCachePolicyCommand;
const serializeAws_restXmlUpdateCloudFrontOriginAccessIdentityCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/origin-access-identity/cloudfront/{Id}/config";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    if (input.CloudFrontOriginAccessIdentityConfig !== undefined) {
        body = serializeAws_restXmlCloudFrontOriginAccessIdentityConfig(input.CloudFrontOriginAccessIdentityConfig, context);
    }
    let contents;
    if (input.CloudFrontOriginAccessIdentityConfig !== undefined) {
        contents = serializeAws_restXmlCloudFrontOriginAccessIdentityConfig(input.CloudFrontOriginAccessIdentityConfig, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlUpdateCloudFrontOriginAccessIdentityCommand = serializeAws_restXmlUpdateCloudFrontOriginAccessIdentityCommand;
const serializeAws_restXmlUpdateContinuousDeploymentPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/continuous-deployment-policy/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    if (input.ContinuousDeploymentPolicyConfig !== undefined) {
        body = serializeAws_restXmlContinuousDeploymentPolicyConfig(input.ContinuousDeploymentPolicyConfig, context);
    }
    let contents;
    if (input.ContinuousDeploymentPolicyConfig !== undefined) {
        contents = serializeAws_restXmlContinuousDeploymentPolicyConfig(input.ContinuousDeploymentPolicyConfig, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlUpdateContinuousDeploymentPolicyCommand = serializeAws_restXmlUpdateContinuousDeploymentPolicyCommand;
const serializeAws_restXmlUpdateDistributionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/distribution/{Id}/config";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    if (input.DistributionConfig !== undefined) {
        body = serializeAws_restXmlDistributionConfig(input.DistributionConfig, context);
    }
    let contents;
    if (input.DistributionConfig !== undefined) {
        contents = serializeAws_restXmlDistributionConfig(input.DistributionConfig, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlUpdateDistributionCommand = serializeAws_restXmlUpdateDistributionCommand;
const serializeAws_restXmlUpdateFieldLevelEncryptionConfigCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/field-level-encryption/{Id}/config";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    if (input.FieldLevelEncryptionConfig !== undefined) {
        body = serializeAws_restXmlFieldLevelEncryptionConfig(input.FieldLevelEncryptionConfig, context);
    }
    let contents;
    if (input.FieldLevelEncryptionConfig !== undefined) {
        contents = serializeAws_restXmlFieldLevelEncryptionConfig(input.FieldLevelEncryptionConfig, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlUpdateFieldLevelEncryptionConfigCommand = serializeAws_restXmlUpdateFieldLevelEncryptionConfigCommand;
const serializeAws_restXmlUpdateFieldLevelEncryptionProfileCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/field-level-encryption-profile/{Id}/config";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    if (input.FieldLevelEncryptionProfileConfig !== undefined) {
        body = serializeAws_restXmlFieldLevelEncryptionProfileConfig(input.FieldLevelEncryptionProfileConfig, context);
    }
    let contents;
    if (input.FieldLevelEncryptionProfileConfig !== undefined) {
        contents = serializeAws_restXmlFieldLevelEncryptionProfileConfig(input.FieldLevelEncryptionProfileConfig, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlUpdateFieldLevelEncryptionProfileCommand = serializeAws_restXmlUpdateFieldLevelEncryptionProfileCommand;
const serializeAws_restXmlUpdateFunctionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/function/{Name}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new xml_builder_1.XmlNode("UpdateFunctionRequest");
    bodyNode.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input.FunctionCode !== undefined) {
        const node = xml_builder_1.XmlNode.of("FunctionBlob", context.base64Encoder(input.FunctionCode)).withName("FunctionCode");
        bodyNode.addChildNode(node);
    }
    if (input.FunctionConfig !== undefined) {
        const node = serializeAws_restXmlFunctionConfig(input.FunctionConfig, context).withName("FunctionConfig");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlUpdateFunctionCommand = serializeAws_restXmlUpdateFunctionCommand;
const serializeAws_restXmlUpdateKeyGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/key-group/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    if (input.KeyGroupConfig !== undefined) {
        body = serializeAws_restXmlKeyGroupConfig(input.KeyGroupConfig, context);
    }
    let contents;
    if (input.KeyGroupConfig !== undefined) {
        contents = serializeAws_restXmlKeyGroupConfig(input.KeyGroupConfig, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlUpdateKeyGroupCommand = serializeAws_restXmlUpdateKeyGroupCommand;
const serializeAws_restXmlUpdateOriginAccessControlCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/origin-access-control/{Id}/config";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    if (input.OriginAccessControlConfig !== undefined) {
        body = serializeAws_restXmlOriginAccessControlConfig(input.OriginAccessControlConfig, context);
    }
    let contents;
    if (input.OriginAccessControlConfig !== undefined) {
        contents = serializeAws_restXmlOriginAccessControlConfig(input.OriginAccessControlConfig, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlUpdateOriginAccessControlCommand = serializeAws_restXmlUpdateOriginAccessControlCommand;
const serializeAws_restXmlUpdateOriginRequestPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/origin-request-policy/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    if (input.OriginRequestPolicyConfig !== undefined) {
        body = serializeAws_restXmlOriginRequestPolicyConfig(input.OriginRequestPolicyConfig, context);
    }
    let contents;
    if (input.OriginRequestPolicyConfig !== undefined) {
        contents = serializeAws_restXmlOriginRequestPolicyConfig(input.OriginRequestPolicyConfig, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlUpdateOriginRequestPolicyCommand = serializeAws_restXmlUpdateOriginRequestPolicyCommand;
const serializeAws_restXmlUpdatePublicKeyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/public-key/{Id}/config";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    if (input.PublicKeyConfig !== undefined) {
        body = serializeAws_restXmlPublicKeyConfig(input.PublicKeyConfig, context);
    }
    let contents;
    if (input.PublicKeyConfig !== undefined) {
        contents = serializeAws_restXmlPublicKeyConfig(input.PublicKeyConfig, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlUpdatePublicKeyCommand = serializeAws_restXmlUpdatePublicKeyCommand;
const serializeAws_restXmlUpdateRealtimeLogConfigCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/realtime-log-config";
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new xml_builder_1.XmlNode("UpdateRealtimeLogConfigRequest");
    bodyNode.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input.ARN !== undefined) {
        const node = xml_builder_1.XmlNode.of("string", input.ARN).withName("ARN");
        bodyNode.addChildNode(node);
    }
    if (input.EndPoints !== undefined) {
        const nodes = serializeAws_restXmlEndPointList(input.EndPoints, context);
        const containerNode = new xml_builder_1.XmlNode("EndPoints");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.Fields !== undefined) {
        const nodes = serializeAws_restXmlFieldList(input.Fields, context);
        const containerNode = new xml_builder_1.XmlNode("Fields");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.Name !== undefined) {
        const node = xml_builder_1.XmlNode.of("string", input.Name).withName("Name");
        bodyNode.addChildNode(node);
    }
    if (input.SamplingRate !== undefined) {
        const node = xml_builder_1.XmlNode.of("long", String(input.SamplingRate)).withName("SamplingRate");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlUpdateRealtimeLogConfigCommand = serializeAws_restXmlUpdateRealtimeLogConfigCommand;
const serializeAws_restXmlUpdateResponseHeadersPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2020-05-31/response-headers-policy/{Id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    if (input.ResponseHeadersPolicyConfig !== undefined) {
        body = serializeAws_restXmlResponseHeadersPolicyConfig(input.ResponseHeadersPolicyConfig, context);
    }
    let contents;
    if (input.ResponseHeadersPolicyConfig !== undefined) {
        contents = serializeAws_restXmlResponseHeadersPolicyConfig(input.ResponseHeadersPolicyConfig, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlUpdateResponseHeadersPolicyCommand = serializeAws_restXmlUpdateResponseHeadersPolicyCommand;
const serializeAws_restXmlUpdateStreamingDistributionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "if-match": input.IfMatch,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2020-05-31/streaming-distribution/{Id}/config";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    if (input.StreamingDistributionConfig !== undefined) {
        body = serializeAws_restXmlStreamingDistributionConfig(input.StreamingDistributionConfig, context);
    }
    let contents;
    if (input.StreamingDistributionConfig !== undefined) {
        contents = serializeAws_restXmlStreamingDistributionConfig(input.StreamingDistributionConfig, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restXmlUpdateStreamingDistributionCommand = serializeAws_restXmlUpdateStreamingDistributionCommand;
const deserializeAws_restXmlAssociateAliasCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlAssociateAliasCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
exports.deserializeAws_restXmlAssociateAliasCommand = deserializeAws_restXmlAssociateAliasCommand;
const deserializeAws_restXmlAssociateAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await deserializeAws_restXmlIllegalUpdateResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await deserializeAws_restXmlNoSuchDistributionResponse(parsedOutput, context);
        case "TooManyDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyDistributionCNAMEs":
            throw await deserializeAws_restXmlTooManyDistributionCNAMEsResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlCopyDistributionCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return deserializeAws_restXmlCopyDistributionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Distribution = deserializeAws_restXmlDistribution(data, context);
    return contents;
};
exports.deserializeAws_restXmlCopyDistributionCommand = deserializeAws_restXmlCopyDistributionCommand;
const deserializeAws_restXmlCopyDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "CNAMEAlreadyExists":
        case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
            throw await deserializeAws_restXmlCNAMEAlreadyExistsResponse(parsedOutput, context);
        case "DistributionAlreadyExists":
        case "com.amazonaws.cloudfront#DistributionAlreadyExists":
            throw await deserializeAws_restXmlDistributionAlreadyExistsResponse(parsedOutput, context);
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
        case "com.amazonaws.cloudfront#IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
            throw await deserializeAws_restXmlIllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorResponse(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "InvalidDefaultRootObject":
        case "com.amazonaws.cloudfront#InvalidDefaultRootObject":
            throw await deserializeAws_restXmlInvalidDefaultRootObjectResponse(parsedOutput, context);
        case "InvalidErrorCode":
        case "com.amazonaws.cloudfront#InvalidErrorCode":
            throw await deserializeAws_restXmlInvalidErrorCodeResponse(parsedOutput, context);
        case "InvalidForwardCookies":
        case "com.amazonaws.cloudfront#InvalidForwardCookies":
            throw await deserializeAws_restXmlInvalidForwardCookiesResponse(parsedOutput, context);
        case "InvalidFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidFunctionAssociation":
            throw await deserializeAws_restXmlInvalidFunctionAssociationResponse(parsedOutput, context);
        case "InvalidGeoRestrictionParameter":
        case "com.amazonaws.cloudfront#InvalidGeoRestrictionParameter":
            throw await deserializeAws_restXmlInvalidGeoRestrictionParameterResponse(parsedOutput, context);
        case "InvalidHeadersForS3Origin":
        case "com.amazonaws.cloudfront#InvalidHeadersForS3Origin":
            throw await deserializeAws_restXmlInvalidHeadersForS3OriginResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "InvalidLambdaFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidLambdaFunctionAssociation":
            throw await deserializeAws_restXmlInvalidLambdaFunctionAssociationResponse(parsedOutput, context);
        case "InvalidLocationCode":
        case "com.amazonaws.cloudfront#InvalidLocationCode":
            throw await deserializeAws_restXmlInvalidLocationCodeResponse(parsedOutput, context);
        case "InvalidMinimumProtocolVersion":
        case "com.amazonaws.cloudfront#InvalidMinimumProtocolVersion":
            throw await deserializeAws_restXmlInvalidMinimumProtocolVersionResponse(parsedOutput, context);
        case "InvalidOrigin":
        case "com.amazonaws.cloudfront#InvalidOrigin":
            throw await deserializeAws_restXmlInvalidOriginResponse(parsedOutput, context);
        case "InvalidOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidOriginAccessControl":
            throw await deserializeAws_restXmlInvalidOriginAccessControlResponse(parsedOutput, context);
        case "InvalidOriginAccessIdentity":
        case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
            throw await deserializeAws_restXmlInvalidOriginAccessIdentityResponse(parsedOutput, context);
        case "InvalidOriginKeepaliveTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginKeepaliveTimeout":
            throw await deserializeAws_restXmlInvalidOriginKeepaliveTimeoutResponse(parsedOutput, context);
        case "InvalidOriginReadTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginReadTimeout":
            throw await deserializeAws_restXmlInvalidOriginReadTimeoutResponse(parsedOutput, context);
        case "InvalidProtocolSettings":
        case "com.amazonaws.cloudfront#InvalidProtocolSettings":
            throw await deserializeAws_restXmlInvalidProtocolSettingsResponse(parsedOutput, context);
        case "InvalidQueryStringParameters":
        case "com.amazonaws.cloudfront#InvalidQueryStringParameters":
            throw await deserializeAws_restXmlInvalidQueryStringParametersResponse(parsedOutput, context);
        case "InvalidRelativePath":
        case "com.amazonaws.cloudfront#InvalidRelativePath":
            throw await deserializeAws_restXmlInvalidRelativePathResponse(parsedOutput, context);
        case "InvalidRequiredProtocol":
        case "com.amazonaws.cloudfront#InvalidRequiredProtocol":
            throw await deserializeAws_restXmlInvalidRequiredProtocolResponse(parsedOutput, context);
        case "InvalidResponseCode":
        case "com.amazonaws.cloudfront#InvalidResponseCode":
            throw await deserializeAws_restXmlInvalidResponseCodeResponse(parsedOutput, context);
        case "InvalidTTLOrder":
        case "com.amazonaws.cloudfront#InvalidTTLOrder":
            throw await deserializeAws_restXmlInvalidTTLOrderResponse(parsedOutput, context);
        case "InvalidViewerCertificate":
        case "com.amazonaws.cloudfront#InvalidViewerCertificate":
            throw await deserializeAws_restXmlInvalidViewerCertificateResponse(parsedOutput, context);
        case "InvalidWebACLId":
        case "com.amazonaws.cloudfront#InvalidWebACLId":
            throw await deserializeAws_restXmlInvalidWebACLIdResponse(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await deserializeAws_restXmlMissingBodyResponse(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await deserializeAws_restXmlNoSuchCachePolicyResponse(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await deserializeAws_restXmlNoSuchDistributionResponse(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await deserializeAws_restXmlNoSuchFieldLevelEncryptionConfigResponse(parsedOutput, context);
        case "NoSuchOrigin":
        case "com.amazonaws.cloudfront#NoSuchOrigin":
            throw await deserializeAws_restXmlNoSuchOriginResponse(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await deserializeAws_restXmlNoSuchOriginRequestPolicyResponse(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await deserializeAws_restXmlNoSuchRealtimeLogConfigResponse(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await deserializeAws_restXmlNoSuchResponseHeadersPolicyResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        case "RealtimeLogConfigOwnerMismatch":
        case "com.amazonaws.cloudfront#RealtimeLogConfigOwnerMismatch":
            throw await deserializeAws_restXmlRealtimeLogConfigOwnerMismatchResponse(parsedOutput, context);
        case "TooManyCacheBehaviors":
        case "com.amazonaws.cloudfront#TooManyCacheBehaviors":
            throw await deserializeAws_restXmlTooManyCacheBehaviorsResponse(parsedOutput, context);
        case "TooManyCertificates":
        case "com.amazonaws.cloudfront#TooManyCertificates":
            throw await deserializeAws_restXmlTooManyCertificatesResponse(parsedOutput, context);
        case "TooManyCookieNamesInWhiteList":
        case "com.amazonaws.cloudfront#TooManyCookieNamesInWhiteList":
            throw await deserializeAws_restXmlTooManyCookieNamesInWhiteListResponse(parsedOutput, context);
        case "TooManyDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyDistributionCNAMEs":
            throw await deserializeAws_restXmlTooManyDistributionCNAMEsResponse(parsedOutput, context);
        case "TooManyDistributions":
        case "com.amazonaws.cloudfront#TooManyDistributions":
            throw await deserializeAws_restXmlTooManyDistributionsResponse(parsedOutput, context);
        case "TooManyDistributionsAssociatedToCachePolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToCachePolicy":
            throw await deserializeAws_restXmlTooManyDistributionsAssociatedToCachePolicyResponse(parsedOutput, context);
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
            throw await deserializeAws_restXmlTooManyDistributionsAssociatedToFieldLevelEncryptionConfigResponse(parsedOutput, context);
        case "TooManyDistributionsAssociatedToKeyGroup":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToKeyGroup":
            throw await deserializeAws_restXmlTooManyDistributionsAssociatedToKeyGroupResponse(parsedOutput, context);
        case "TooManyDistributionsAssociatedToOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToOriginRequestPolicy":
            throw await deserializeAws_restXmlTooManyDistributionsAssociatedToOriginRequestPolicyResponse(parsedOutput, context);
        case "TooManyDistributionsAssociatedToResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToResponseHeadersPolicy":
            throw await deserializeAws_restXmlTooManyDistributionsAssociatedToResponseHeadersPolicyResponse(parsedOutput, context);
        case "TooManyDistributionsWithFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithFunctionAssociations":
            throw await deserializeAws_restXmlTooManyDistributionsWithFunctionAssociationsResponse(parsedOutput, context);
        case "TooManyDistributionsWithLambdaAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithLambdaAssociations":
            throw await deserializeAws_restXmlTooManyDistributionsWithLambdaAssociationsResponse(parsedOutput, context);
        case "TooManyDistributionsWithSingleFunctionARN":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithSingleFunctionARN":
            throw await deserializeAws_restXmlTooManyDistributionsWithSingleFunctionARNResponse(parsedOutput, context);
        case "TooManyFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyFunctionAssociations":
            throw await deserializeAws_restXmlTooManyFunctionAssociationsResponse(parsedOutput, context);
        case "TooManyHeadersInForwardedValues":
        case "com.amazonaws.cloudfront#TooManyHeadersInForwardedValues":
            throw await deserializeAws_restXmlTooManyHeadersInForwardedValuesResponse(parsedOutput, context);
        case "TooManyKeyGroupsAssociatedToDistribution":
        case "com.amazonaws.cloudfront#TooManyKeyGroupsAssociatedToDistribution":
            throw await deserializeAws_restXmlTooManyKeyGroupsAssociatedToDistributionResponse(parsedOutput, context);
        case "TooManyLambdaFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyLambdaFunctionAssociations":
            throw await deserializeAws_restXmlTooManyLambdaFunctionAssociationsResponse(parsedOutput, context);
        case "TooManyOriginCustomHeaders":
        case "com.amazonaws.cloudfront#TooManyOriginCustomHeaders":
            throw await deserializeAws_restXmlTooManyOriginCustomHeadersResponse(parsedOutput, context);
        case "TooManyOriginGroupsPerDistribution":
        case "com.amazonaws.cloudfront#TooManyOriginGroupsPerDistribution":
            throw await deserializeAws_restXmlTooManyOriginGroupsPerDistributionResponse(parsedOutput, context);
        case "TooManyOrigins":
        case "com.amazonaws.cloudfront#TooManyOrigins":
            throw await deserializeAws_restXmlTooManyOriginsResponse(parsedOutput, context);
        case "TooManyQueryStringParameters":
        case "com.amazonaws.cloudfront#TooManyQueryStringParameters":
            throw await deserializeAws_restXmlTooManyQueryStringParametersResponse(parsedOutput, context);
        case "TooManyTrustedSigners":
        case "com.amazonaws.cloudfront#TooManyTrustedSigners":
            throw await deserializeAws_restXmlTooManyTrustedSignersResponse(parsedOutput, context);
        case "TrustedKeyGroupDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedKeyGroupDoesNotExist":
            throw await deserializeAws_restXmlTrustedKeyGroupDoesNotExistResponse(parsedOutput, context);
        case "TrustedSignerDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
            throw await deserializeAws_restXmlTrustedSignerDoesNotExistResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlCreateCachePolicyCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return deserializeAws_restXmlCreateCachePolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CachePolicy = deserializeAws_restXmlCachePolicy(data, context);
    return contents;
};
exports.deserializeAws_restXmlCreateCachePolicyCommand = deserializeAws_restXmlCreateCachePolicyCommand;
const deserializeAws_restXmlCreateCachePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "CachePolicyAlreadyExists":
        case "com.amazonaws.cloudfront#CachePolicyAlreadyExists":
            throw await deserializeAws_restXmlCachePolicyAlreadyExistsResponse(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "TooManyCachePolicies":
        case "com.amazonaws.cloudfront#TooManyCachePolicies":
            throw await deserializeAws_restXmlTooManyCachePoliciesResponse(parsedOutput, context);
        case "TooManyCookiesInCachePolicy":
        case "com.amazonaws.cloudfront#TooManyCookiesInCachePolicy":
            throw await deserializeAws_restXmlTooManyCookiesInCachePolicyResponse(parsedOutput, context);
        case "TooManyHeadersInCachePolicy":
        case "com.amazonaws.cloudfront#TooManyHeadersInCachePolicy":
            throw await deserializeAws_restXmlTooManyHeadersInCachePolicyResponse(parsedOutput, context);
        case "TooManyQueryStringsInCachePolicy":
        case "com.amazonaws.cloudfront#TooManyQueryStringsInCachePolicy":
            throw await deserializeAws_restXmlTooManyQueryStringsInCachePolicyResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlCreateCloudFrontOriginAccessIdentityCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return deserializeAws_restXmlCreateCloudFrontOriginAccessIdentityCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CloudFrontOriginAccessIdentity = deserializeAws_restXmlCloudFrontOriginAccessIdentity(data, context);
    return contents;
};
exports.deserializeAws_restXmlCreateCloudFrontOriginAccessIdentityCommand = deserializeAws_restXmlCreateCloudFrontOriginAccessIdentityCommand;
const deserializeAws_restXmlCreateCloudFrontOriginAccessIdentityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CloudFrontOriginAccessIdentityAlreadyExists":
        case "com.amazonaws.cloudfront#CloudFrontOriginAccessIdentityAlreadyExists":
            throw await deserializeAws_restXmlCloudFrontOriginAccessIdentityAlreadyExistsResponse(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await deserializeAws_restXmlMissingBodyResponse(parsedOutput, context);
        case "TooManyCloudFrontOriginAccessIdentities":
        case "com.amazonaws.cloudfront#TooManyCloudFrontOriginAccessIdentities":
            throw await deserializeAws_restXmlTooManyCloudFrontOriginAccessIdentitiesResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlCreateContinuousDeploymentPolicyCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return deserializeAws_restXmlCreateContinuousDeploymentPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ContinuousDeploymentPolicy = deserializeAws_restXmlContinuousDeploymentPolicy(data, context);
    return contents;
};
exports.deserializeAws_restXmlCreateContinuousDeploymentPolicyCommand = deserializeAws_restXmlCreateContinuousDeploymentPolicyCommand;
const deserializeAws_restXmlCreateContinuousDeploymentPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "StagingDistributionInUse":
        case "com.amazonaws.cloudfront#StagingDistributionInUse":
            throw await deserializeAws_restXmlStagingDistributionInUseResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlCreateDistributionCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return deserializeAws_restXmlCreateDistributionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Distribution = deserializeAws_restXmlDistribution(data, context);
    return contents;
};
exports.deserializeAws_restXmlCreateDistributionCommand = deserializeAws_restXmlCreateDistributionCommand;
const deserializeAws_restXmlCreateDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "CNAMEAlreadyExists":
        case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
            throw await deserializeAws_restXmlCNAMEAlreadyExistsResponse(parsedOutput, context);
        case "DistributionAlreadyExists":
        case "com.amazonaws.cloudfront#DistributionAlreadyExists":
            throw await deserializeAws_restXmlDistributionAlreadyExistsResponse(parsedOutput, context);
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
        case "com.amazonaws.cloudfront#IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
            throw await deserializeAws_restXmlIllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorResponse(parsedOutput, context);
        case "IllegalOriginAccessConfiguration":
        case "com.amazonaws.cloudfront#IllegalOriginAccessConfiguration":
            throw await deserializeAws_restXmlIllegalOriginAccessConfigurationResponse(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "InvalidDefaultRootObject":
        case "com.amazonaws.cloudfront#InvalidDefaultRootObject":
            throw await deserializeAws_restXmlInvalidDefaultRootObjectResponse(parsedOutput, context);
        case "InvalidDomainNameForOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidDomainNameForOriginAccessControl":
            throw await deserializeAws_restXmlInvalidDomainNameForOriginAccessControlResponse(parsedOutput, context);
        case "InvalidErrorCode":
        case "com.amazonaws.cloudfront#InvalidErrorCode":
            throw await deserializeAws_restXmlInvalidErrorCodeResponse(parsedOutput, context);
        case "InvalidForwardCookies":
        case "com.amazonaws.cloudfront#InvalidForwardCookies":
            throw await deserializeAws_restXmlInvalidForwardCookiesResponse(parsedOutput, context);
        case "InvalidFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidFunctionAssociation":
            throw await deserializeAws_restXmlInvalidFunctionAssociationResponse(parsedOutput, context);
        case "InvalidGeoRestrictionParameter":
        case "com.amazonaws.cloudfront#InvalidGeoRestrictionParameter":
            throw await deserializeAws_restXmlInvalidGeoRestrictionParameterResponse(parsedOutput, context);
        case "InvalidHeadersForS3Origin":
        case "com.amazonaws.cloudfront#InvalidHeadersForS3Origin":
            throw await deserializeAws_restXmlInvalidHeadersForS3OriginResponse(parsedOutput, context);
        case "InvalidLambdaFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidLambdaFunctionAssociation":
            throw await deserializeAws_restXmlInvalidLambdaFunctionAssociationResponse(parsedOutput, context);
        case "InvalidLocationCode":
        case "com.amazonaws.cloudfront#InvalidLocationCode":
            throw await deserializeAws_restXmlInvalidLocationCodeResponse(parsedOutput, context);
        case "InvalidMinimumProtocolVersion":
        case "com.amazonaws.cloudfront#InvalidMinimumProtocolVersion":
            throw await deserializeAws_restXmlInvalidMinimumProtocolVersionResponse(parsedOutput, context);
        case "InvalidOrigin":
        case "com.amazonaws.cloudfront#InvalidOrigin":
            throw await deserializeAws_restXmlInvalidOriginResponse(parsedOutput, context);
        case "InvalidOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidOriginAccessControl":
            throw await deserializeAws_restXmlInvalidOriginAccessControlResponse(parsedOutput, context);
        case "InvalidOriginAccessIdentity":
        case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
            throw await deserializeAws_restXmlInvalidOriginAccessIdentityResponse(parsedOutput, context);
        case "InvalidOriginKeepaliveTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginKeepaliveTimeout":
            throw await deserializeAws_restXmlInvalidOriginKeepaliveTimeoutResponse(parsedOutput, context);
        case "InvalidOriginReadTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginReadTimeout":
            throw await deserializeAws_restXmlInvalidOriginReadTimeoutResponse(parsedOutput, context);
        case "InvalidProtocolSettings":
        case "com.amazonaws.cloudfront#InvalidProtocolSettings":
            throw await deserializeAws_restXmlInvalidProtocolSettingsResponse(parsedOutput, context);
        case "InvalidQueryStringParameters":
        case "com.amazonaws.cloudfront#InvalidQueryStringParameters":
            throw await deserializeAws_restXmlInvalidQueryStringParametersResponse(parsedOutput, context);
        case "InvalidRelativePath":
        case "com.amazonaws.cloudfront#InvalidRelativePath":
            throw await deserializeAws_restXmlInvalidRelativePathResponse(parsedOutput, context);
        case "InvalidRequiredProtocol":
        case "com.amazonaws.cloudfront#InvalidRequiredProtocol":
            throw await deserializeAws_restXmlInvalidRequiredProtocolResponse(parsedOutput, context);
        case "InvalidResponseCode":
        case "com.amazonaws.cloudfront#InvalidResponseCode":
            throw await deserializeAws_restXmlInvalidResponseCodeResponse(parsedOutput, context);
        case "InvalidTTLOrder":
        case "com.amazonaws.cloudfront#InvalidTTLOrder":
            throw await deserializeAws_restXmlInvalidTTLOrderResponse(parsedOutput, context);
        case "InvalidViewerCertificate":
        case "com.amazonaws.cloudfront#InvalidViewerCertificate":
            throw await deserializeAws_restXmlInvalidViewerCertificateResponse(parsedOutput, context);
        case "InvalidWebACLId":
        case "com.amazonaws.cloudfront#InvalidWebACLId":
            throw await deserializeAws_restXmlInvalidWebACLIdResponse(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await deserializeAws_restXmlMissingBodyResponse(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await deserializeAws_restXmlNoSuchCachePolicyResponse(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await deserializeAws_restXmlNoSuchFieldLevelEncryptionConfigResponse(parsedOutput, context);
        case "NoSuchOrigin":
        case "com.amazonaws.cloudfront#NoSuchOrigin":
            throw await deserializeAws_restXmlNoSuchOriginResponse(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await deserializeAws_restXmlNoSuchOriginRequestPolicyResponse(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await deserializeAws_restXmlNoSuchRealtimeLogConfigResponse(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await deserializeAws_restXmlNoSuchResponseHeadersPolicyResponse(parsedOutput, context);
        case "RealtimeLogConfigOwnerMismatch":
        case "com.amazonaws.cloudfront#RealtimeLogConfigOwnerMismatch":
            throw await deserializeAws_restXmlRealtimeLogConfigOwnerMismatchResponse(parsedOutput, context);
        case "TooManyCacheBehaviors":
        case "com.amazonaws.cloudfront#TooManyCacheBehaviors":
            throw await deserializeAws_restXmlTooManyCacheBehaviorsResponse(parsedOutput, context);
        case "TooManyCertificates":
        case "com.amazonaws.cloudfront#TooManyCertificates":
            throw await deserializeAws_restXmlTooManyCertificatesResponse(parsedOutput, context);
        case "TooManyCookieNamesInWhiteList":
        case "com.amazonaws.cloudfront#TooManyCookieNamesInWhiteList":
            throw await deserializeAws_restXmlTooManyCookieNamesInWhiteListResponse(parsedOutput, context);
        case "TooManyDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyDistributionCNAMEs":
            throw await deserializeAws_restXmlTooManyDistributionCNAMEsResponse(parsedOutput, context);
        case "TooManyDistributions":
        case "com.amazonaws.cloudfront#TooManyDistributions":
            throw await deserializeAws_restXmlTooManyDistributionsResponse(parsedOutput, context);
        case "TooManyDistributionsAssociatedToCachePolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToCachePolicy":
            throw await deserializeAws_restXmlTooManyDistributionsAssociatedToCachePolicyResponse(parsedOutput, context);
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
            throw await deserializeAws_restXmlTooManyDistributionsAssociatedToFieldLevelEncryptionConfigResponse(parsedOutput, context);
        case "TooManyDistributionsAssociatedToKeyGroup":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToKeyGroup":
            throw await deserializeAws_restXmlTooManyDistributionsAssociatedToKeyGroupResponse(parsedOutput, context);
        case "TooManyDistributionsAssociatedToOriginAccessControl":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToOriginAccessControl":
            throw await deserializeAws_restXmlTooManyDistributionsAssociatedToOriginAccessControlResponse(parsedOutput, context);
        case "TooManyDistributionsAssociatedToOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToOriginRequestPolicy":
            throw await deserializeAws_restXmlTooManyDistributionsAssociatedToOriginRequestPolicyResponse(parsedOutput, context);
        case "TooManyDistributionsAssociatedToResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToResponseHeadersPolicy":
            throw await deserializeAws_restXmlTooManyDistributionsAssociatedToResponseHeadersPolicyResponse(parsedOutput, context);
        case "TooManyDistributionsWithFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithFunctionAssociations":
            throw await deserializeAws_restXmlTooManyDistributionsWithFunctionAssociationsResponse(parsedOutput, context);
        case "TooManyDistributionsWithLambdaAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithLambdaAssociations":
            throw await deserializeAws_restXmlTooManyDistributionsWithLambdaAssociationsResponse(parsedOutput, context);
        case "TooManyDistributionsWithSingleFunctionARN":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithSingleFunctionARN":
            throw await deserializeAws_restXmlTooManyDistributionsWithSingleFunctionARNResponse(parsedOutput, context);
        case "TooManyFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyFunctionAssociations":
            throw await deserializeAws_restXmlTooManyFunctionAssociationsResponse(parsedOutput, context);
        case "TooManyHeadersInForwardedValues":
        case "com.amazonaws.cloudfront#TooManyHeadersInForwardedValues":
            throw await deserializeAws_restXmlTooManyHeadersInForwardedValuesResponse(parsedOutput, context);
        case "TooManyKeyGroupsAssociatedToDistribution":
        case "com.amazonaws.cloudfront#TooManyKeyGroupsAssociatedToDistribution":
            throw await deserializeAws_restXmlTooManyKeyGroupsAssociatedToDistributionResponse(parsedOutput, context);
        case "TooManyLambdaFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyLambdaFunctionAssociations":
            throw await deserializeAws_restXmlTooManyLambdaFunctionAssociationsResponse(parsedOutput, context);
        case "TooManyOriginCustomHeaders":
        case "com.amazonaws.cloudfront#TooManyOriginCustomHeaders":
            throw await deserializeAws_restXmlTooManyOriginCustomHeadersResponse(parsedOutput, context);
        case "TooManyOriginGroupsPerDistribution":
        case "com.amazonaws.cloudfront#TooManyOriginGroupsPerDistribution":
            throw await deserializeAws_restXmlTooManyOriginGroupsPerDistributionResponse(parsedOutput, context);
        case "TooManyOrigins":
        case "com.amazonaws.cloudfront#TooManyOrigins":
            throw await deserializeAws_restXmlTooManyOriginsResponse(parsedOutput, context);
        case "TooManyQueryStringParameters":
        case "com.amazonaws.cloudfront#TooManyQueryStringParameters":
            throw await deserializeAws_restXmlTooManyQueryStringParametersResponse(parsedOutput, context);
        case "TooManyTrustedSigners":
        case "com.amazonaws.cloudfront#TooManyTrustedSigners":
            throw await deserializeAws_restXmlTooManyTrustedSignersResponse(parsedOutput, context);
        case "TrustedKeyGroupDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedKeyGroupDoesNotExist":
            throw await deserializeAws_restXmlTrustedKeyGroupDoesNotExistResponse(parsedOutput, context);
        case "TrustedSignerDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
            throw await deserializeAws_restXmlTrustedSignerDoesNotExistResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlCreateDistributionWithTagsCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return deserializeAws_restXmlCreateDistributionWithTagsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Distribution = deserializeAws_restXmlDistribution(data, context);
    return contents;
};
exports.deserializeAws_restXmlCreateDistributionWithTagsCommand = deserializeAws_restXmlCreateDistributionWithTagsCommand;
const deserializeAws_restXmlCreateDistributionWithTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "CNAMEAlreadyExists":
        case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
            throw await deserializeAws_restXmlCNAMEAlreadyExistsResponse(parsedOutput, context);
        case "DistributionAlreadyExists":
        case "com.amazonaws.cloudfront#DistributionAlreadyExists":
            throw await deserializeAws_restXmlDistributionAlreadyExistsResponse(parsedOutput, context);
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
        case "com.amazonaws.cloudfront#IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
            throw await deserializeAws_restXmlIllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorResponse(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "InvalidDefaultRootObject":
        case "com.amazonaws.cloudfront#InvalidDefaultRootObject":
            throw await deserializeAws_restXmlInvalidDefaultRootObjectResponse(parsedOutput, context);
        case "InvalidDomainNameForOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidDomainNameForOriginAccessControl":
            throw await deserializeAws_restXmlInvalidDomainNameForOriginAccessControlResponse(parsedOutput, context);
        case "InvalidErrorCode":
        case "com.amazonaws.cloudfront#InvalidErrorCode":
            throw await deserializeAws_restXmlInvalidErrorCodeResponse(parsedOutput, context);
        case "InvalidForwardCookies":
        case "com.amazonaws.cloudfront#InvalidForwardCookies":
            throw await deserializeAws_restXmlInvalidForwardCookiesResponse(parsedOutput, context);
        case "InvalidFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidFunctionAssociation":
            throw await deserializeAws_restXmlInvalidFunctionAssociationResponse(parsedOutput, context);
        case "InvalidGeoRestrictionParameter":
        case "com.amazonaws.cloudfront#InvalidGeoRestrictionParameter":
            throw await deserializeAws_restXmlInvalidGeoRestrictionParameterResponse(parsedOutput, context);
        case "InvalidHeadersForS3Origin":
        case "com.amazonaws.cloudfront#InvalidHeadersForS3Origin":
            throw await deserializeAws_restXmlInvalidHeadersForS3OriginResponse(parsedOutput, context);
        case "InvalidLambdaFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidLambdaFunctionAssociation":
            throw await deserializeAws_restXmlInvalidLambdaFunctionAssociationResponse(parsedOutput, context);
        case "InvalidLocationCode":
        case "com.amazonaws.cloudfront#InvalidLocationCode":
            throw await deserializeAws_restXmlInvalidLocationCodeResponse(parsedOutput, context);
        case "InvalidMinimumProtocolVersion":
        case "com.amazonaws.cloudfront#InvalidMinimumProtocolVersion":
            throw await deserializeAws_restXmlInvalidMinimumProtocolVersionResponse(parsedOutput, context);
        case "InvalidOrigin":
        case "com.amazonaws.cloudfront#InvalidOrigin":
            throw await deserializeAws_restXmlInvalidOriginResponse(parsedOutput, context);
        case "InvalidOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidOriginAccessControl":
            throw await deserializeAws_restXmlInvalidOriginAccessControlResponse(parsedOutput, context);
        case "InvalidOriginAccessIdentity":
        case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
            throw await deserializeAws_restXmlInvalidOriginAccessIdentityResponse(parsedOutput, context);
        case "InvalidOriginKeepaliveTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginKeepaliveTimeout":
            throw await deserializeAws_restXmlInvalidOriginKeepaliveTimeoutResponse(parsedOutput, context);
        case "InvalidOriginReadTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginReadTimeout":
            throw await deserializeAws_restXmlInvalidOriginReadTimeoutResponse(parsedOutput, context);
        case "InvalidProtocolSettings":
        case "com.amazonaws.cloudfront#InvalidProtocolSettings":
            throw await deserializeAws_restXmlInvalidProtocolSettingsResponse(parsedOutput, context);
        case "InvalidQueryStringParameters":
        case "com.amazonaws.cloudfront#InvalidQueryStringParameters":
            throw await deserializeAws_restXmlInvalidQueryStringParametersResponse(parsedOutput, context);
        case "InvalidRelativePath":
        case "com.amazonaws.cloudfront#InvalidRelativePath":
            throw await deserializeAws_restXmlInvalidRelativePathResponse(parsedOutput, context);
        case "InvalidRequiredProtocol":
        case "com.amazonaws.cloudfront#InvalidRequiredProtocol":
            throw await deserializeAws_restXmlInvalidRequiredProtocolResponse(parsedOutput, context);
        case "InvalidResponseCode":
        case "com.amazonaws.cloudfront#InvalidResponseCode":
            throw await deserializeAws_restXmlInvalidResponseCodeResponse(parsedOutput, context);
        case "InvalidTTLOrder":
        case "com.amazonaws.cloudfront#InvalidTTLOrder":
            throw await deserializeAws_restXmlInvalidTTLOrderResponse(parsedOutput, context);
        case "InvalidTagging":
        case "com.amazonaws.cloudfront#InvalidTagging":
            throw await deserializeAws_restXmlInvalidTaggingResponse(parsedOutput, context);
        case "InvalidViewerCertificate":
        case "com.amazonaws.cloudfront#InvalidViewerCertificate":
            throw await deserializeAws_restXmlInvalidViewerCertificateResponse(parsedOutput, context);
        case "InvalidWebACLId":
        case "com.amazonaws.cloudfront#InvalidWebACLId":
            throw await deserializeAws_restXmlInvalidWebACLIdResponse(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await deserializeAws_restXmlMissingBodyResponse(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await deserializeAws_restXmlNoSuchCachePolicyResponse(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await deserializeAws_restXmlNoSuchFieldLevelEncryptionConfigResponse(parsedOutput, context);
        case "NoSuchOrigin":
        case "com.amazonaws.cloudfront#NoSuchOrigin":
            throw await deserializeAws_restXmlNoSuchOriginResponse(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await deserializeAws_restXmlNoSuchOriginRequestPolicyResponse(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await deserializeAws_restXmlNoSuchRealtimeLogConfigResponse(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await deserializeAws_restXmlNoSuchResponseHeadersPolicyResponse(parsedOutput, context);
        case "RealtimeLogConfigOwnerMismatch":
        case "com.amazonaws.cloudfront#RealtimeLogConfigOwnerMismatch":
            throw await deserializeAws_restXmlRealtimeLogConfigOwnerMismatchResponse(parsedOutput, context);
        case "TooManyCacheBehaviors":
        case "com.amazonaws.cloudfront#TooManyCacheBehaviors":
            throw await deserializeAws_restXmlTooManyCacheBehaviorsResponse(parsedOutput, context);
        case "TooManyCertificates":
        case "com.amazonaws.cloudfront#TooManyCertificates":
            throw await deserializeAws_restXmlTooManyCertificatesResponse(parsedOutput, context);
        case "TooManyCookieNamesInWhiteList":
        case "com.amazonaws.cloudfront#TooManyCookieNamesInWhiteList":
            throw await deserializeAws_restXmlTooManyCookieNamesInWhiteListResponse(parsedOutput, context);
        case "TooManyDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyDistributionCNAMEs":
            throw await deserializeAws_restXmlTooManyDistributionCNAMEsResponse(parsedOutput, context);
        case "TooManyDistributions":
        case "com.amazonaws.cloudfront#TooManyDistributions":
            throw await deserializeAws_restXmlTooManyDistributionsResponse(parsedOutput, context);
        case "TooManyDistributionsAssociatedToCachePolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToCachePolicy":
            throw await deserializeAws_restXmlTooManyDistributionsAssociatedToCachePolicyResponse(parsedOutput, context);
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
            throw await deserializeAws_restXmlTooManyDistributionsAssociatedToFieldLevelEncryptionConfigResponse(parsedOutput, context);
        case "TooManyDistributionsAssociatedToKeyGroup":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToKeyGroup":
            throw await deserializeAws_restXmlTooManyDistributionsAssociatedToKeyGroupResponse(parsedOutput, context);
        case "TooManyDistributionsAssociatedToOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToOriginRequestPolicy":
            throw await deserializeAws_restXmlTooManyDistributionsAssociatedToOriginRequestPolicyResponse(parsedOutput, context);
        case "TooManyDistributionsAssociatedToResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToResponseHeadersPolicy":
            throw await deserializeAws_restXmlTooManyDistributionsAssociatedToResponseHeadersPolicyResponse(parsedOutput, context);
        case "TooManyDistributionsWithFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithFunctionAssociations":
            throw await deserializeAws_restXmlTooManyDistributionsWithFunctionAssociationsResponse(parsedOutput, context);
        case "TooManyDistributionsWithLambdaAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithLambdaAssociations":
            throw await deserializeAws_restXmlTooManyDistributionsWithLambdaAssociationsResponse(parsedOutput, context);
        case "TooManyDistributionsWithSingleFunctionARN":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithSingleFunctionARN":
            throw await deserializeAws_restXmlTooManyDistributionsWithSingleFunctionARNResponse(parsedOutput, context);
        case "TooManyFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyFunctionAssociations":
            throw await deserializeAws_restXmlTooManyFunctionAssociationsResponse(parsedOutput, context);
        case "TooManyHeadersInForwardedValues":
        case "com.amazonaws.cloudfront#TooManyHeadersInForwardedValues":
            throw await deserializeAws_restXmlTooManyHeadersInForwardedValuesResponse(parsedOutput, context);
        case "TooManyKeyGroupsAssociatedToDistribution":
        case "com.amazonaws.cloudfront#TooManyKeyGroupsAssociatedToDistribution":
            throw await deserializeAws_restXmlTooManyKeyGroupsAssociatedToDistributionResponse(parsedOutput, context);
        case "TooManyLambdaFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyLambdaFunctionAssociations":
            throw await deserializeAws_restXmlTooManyLambdaFunctionAssociationsResponse(parsedOutput, context);
        case "TooManyOriginCustomHeaders":
        case "com.amazonaws.cloudfront#TooManyOriginCustomHeaders":
            throw await deserializeAws_restXmlTooManyOriginCustomHeadersResponse(parsedOutput, context);
        case "TooManyOriginGroupsPerDistribution":
        case "com.amazonaws.cloudfront#TooManyOriginGroupsPerDistribution":
            throw await deserializeAws_restXmlTooManyOriginGroupsPerDistributionResponse(parsedOutput, context);
        case "TooManyOrigins":
        case "com.amazonaws.cloudfront#TooManyOrigins":
            throw await deserializeAws_restXmlTooManyOriginsResponse(parsedOutput, context);
        case "TooManyQueryStringParameters":
        case "com.amazonaws.cloudfront#TooManyQueryStringParameters":
            throw await deserializeAws_restXmlTooManyQueryStringParametersResponse(parsedOutput, context);
        case "TooManyTrustedSigners":
        case "com.amazonaws.cloudfront#TooManyTrustedSigners":
            throw await deserializeAws_restXmlTooManyTrustedSignersResponse(parsedOutput, context);
        case "TrustedKeyGroupDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedKeyGroupDoesNotExist":
            throw await deserializeAws_restXmlTrustedKeyGroupDoesNotExistResponse(parsedOutput, context);
        case "TrustedSignerDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
            throw await deserializeAws_restXmlTrustedSignerDoesNotExistResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlCreateFieldLevelEncryptionConfigCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return deserializeAws_restXmlCreateFieldLevelEncryptionConfigCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryption = deserializeAws_restXmlFieldLevelEncryption(data, context);
    return contents;
};
exports.deserializeAws_restXmlCreateFieldLevelEncryptionConfigCommand = deserializeAws_restXmlCreateFieldLevelEncryptionConfigCommand;
const deserializeAws_restXmlCreateFieldLevelEncryptionConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "FieldLevelEncryptionConfigAlreadyExists":
        case "com.amazonaws.cloudfront#FieldLevelEncryptionConfigAlreadyExists":
            throw await deserializeAws_restXmlFieldLevelEncryptionConfigAlreadyExistsResponse(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionProfile":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
            throw await deserializeAws_restXmlNoSuchFieldLevelEncryptionProfileResponse(parsedOutput, context);
        case "QueryArgProfileEmpty":
        case "com.amazonaws.cloudfront#QueryArgProfileEmpty":
            throw await deserializeAws_restXmlQueryArgProfileEmptyResponse(parsedOutput, context);
        case "TooManyFieldLevelEncryptionConfigs":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionConfigs":
            throw await deserializeAws_restXmlTooManyFieldLevelEncryptionConfigsResponse(parsedOutput, context);
        case "TooManyFieldLevelEncryptionContentTypeProfiles":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionContentTypeProfiles":
            throw await deserializeAws_restXmlTooManyFieldLevelEncryptionContentTypeProfilesResponse(parsedOutput, context);
        case "TooManyFieldLevelEncryptionQueryArgProfiles":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionQueryArgProfiles":
            throw await deserializeAws_restXmlTooManyFieldLevelEncryptionQueryArgProfilesResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlCreateFieldLevelEncryptionProfileCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return deserializeAws_restXmlCreateFieldLevelEncryptionProfileCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryptionProfile = deserializeAws_restXmlFieldLevelEncryptionProfile(data, context);
    return contents;
};
exports.deserializeAws_restXmlCreateFieldLevelEncryptionProfileCommand = deserializeAws_restXmlCreateFieldLevelEncryptionProfileCommand;
const deserializeAws_restXmlCreateFieldLevelEncryptionProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "FieldLevelEncryptionProfileAlreadyExists":
        case "com.amazonaws.cloudfront#FieldLevelEncryptionProfileAlreadyExists":
            throw await deserializeAws_restXmlFieldLevelEncryptionProfileAlreadyExistsResponse(parsedOutput, context);
        case "FieldLevelEncryptionProfileSizeExceeded":
        case "com.amazonaws.cloudfront#FieldLevelEncryptionProfileSizeExceeded":
            throw await deserializeAws_restXmlFieldLevelEncryptionProfileSizeExceededResponse(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "NoSuchPublicKey":
        case "com.amazonaws.cloudfront#NoSuchPublicKey":
            throw await deserializeAws_restXmlNoSuchPublicKeyResponse(parsedOutput, context);
        case "TooManyFieldLevelEncryptionEncryptionEntities":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionEncryptionEntities":
            throw await deserializeAws_restXmlTooManyFieldLevelEncryptionEncryptionEntitiesResponse(parsedOutput, context);
        case "TooManyFieldLevelEncryptionFieldPatterns":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionFieldPatterns":
            throw await deserializeAws_restXmlTooManyFieldLevelEncryptionFieldPatternsResponse(parsedOutput, context);
        case "TooManyFieldLevelEncryptionProfiles":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionProfiles":
            throw await deserializeAws_restXmlTooManyFieldLevelEncryptionProfilesResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlCreateFunctionCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return deserializeAws_restXmlCreateFunctionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FunctionSummary = deserializeAws_restXmlFunctionSummary(data, context);
    return contents;
};
exports.deserializeAws_restXmlCreateFunctionCommand = deserializeAws_restXmlCreateFunctionCommand;
const deserializeAws_restXmlCreateFunctionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "FunctionAlreadyExists":
        case "com.amazonaws.cloudfront#FunctionAlreadyExists":
            throw await deserializeAws_restXmlFunctionAlreadyExistsResponse(parsedOutput, context);
        case "FunctionSizeLimitExceeded":
        case "com.amazonaws.cloudfront#FunctionSizeLimitExceeded":
            throw await deserializeAws_restXmlFunctionSizeLimitExceededResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "TooManyFunctions":
        case "com.amazonaws.cloudfront#TooManyFunctions":
            throw await deserializeAws_restXmlTooManyFunctionsResponse(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await deserializeAws_restXmlUnsupportedOperationResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlCreateInvalidationCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return deserializeAws_restXmlCreateInvalidationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Invalidation = deserializeAws_restXmlInvalidation(data, context);
    return contents;
};
exports.deserializeAws_restXmlCreateInvalidationCommand = deserializeAws_restXmlCreateInvalidationCommand;
const deserializeAws_restXmlCreateInvalidationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "BatchTooLarge":
        case "com.amazonaws.cloudfront#BatchTooLarge":
            throw await deserializeAws_restXmlBatchTooLargeResponse(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await deserializeAws_restXmlMissingBodyResponse(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await deserializeAws_restXmlNoSuchDistributionResponse(parsedOutput, context);
        case "TooManyInvalidationsInProgress":
        case "com.amazonaws.cloudfront#TooManyInvalidationsInProgress":
            throw await deserializeAws_restXmlTooManyInvalidationsInProgressResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlCreateKeyGroupCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return deserializeAws_restXmlCreateKeyGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.KeyGroup = deserializeAws_restXmlKeyGroup(data, context);
    return contents;
};
exports.deserializeAws_restXmlCreateKeyGroupCommand = deserializeAws_restXmlCreateKeyGroupCommand;
const deserializeAws_restXmlCreateKeyGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "KeyGroupAlreadyExists":
        case "com.amazonaws.cloudfront#KeyGroupAlreadyExists":
            throw await deserializeAws_restXmlKeyGroupAlreadyExistsResponse(parsedOutput, context);
        case "TooManyKeyGroups":
        case "com.amazonaws.cloudfront#TooManyKeyGroups":
            throw await deserializeAws_restXmlTooManyKeyGroupsResponse(parsedOutput, context);
        case "TooManyPublicKeysInKeyGroup":
        case "com.amazonaws.cloudfront#TooManyPublicKeysInKeyGroup":
            throw await deserializeAws_restXmlTooManyPublicKeysInKeyGroupResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlCreateMonitoringSubscriptionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlCreateMonitoringSubscriptionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.MonitoringSubscription = deserializeAws_restXmlMonitoringSubscription(data, context);
    return contents;
};
exports.deserializeAws_restXmlCreateMonitoringSubscriptionCommand = deserializeAws_restXmlCreateMonitoringSubscriptionCommand;
const deserializeAws_restXmlCreateMonitoringSubscriptionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "MonitoringSubscriptionAlreadyExists":
        case "com.amazonaws.cloudfront#MonitoringSubscriptionAlreadyExists":
            throw await deserializeAws_restXmlMonitoringSubscriptionAlreadyExistsResponse(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await deserializeAws_restXmlNoSuchDistributionResponse(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await deserializeAws_restXmlUnsupportedOperationResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlCreateOriginAccessControlCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return deserializeAws_restXmlCreateOriginAccessControlCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginAccessControl = deserializeAws_restXmlOriginAccessControl(data, context);
    return contents;
};
exports.deserializeAws_restXmlCreateOriginAccessControlCommand = deserializeAws_restXmlCreateOriginAccessControlCommand;
const deserializeAws_restXmlCreateOriginAccessControlCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "OriginAccessControlAlreadyExists":
        case "com.amazonaws.cloudfront#OriginAccessControlAlreadyExists":
            throw await deserializeAws_restXmlOriginAccessControlAlreadyExistsResponse(parsedOutput, context);
        case "TooManyOriginAccessControls":
        case "com.amazonaws.cloudfront#TooManyOriginAccessControls":
            throw await deserializeAws_restXmlTooManyOriginAccessControlsResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlCreateOriginRequestPolicyCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return deserializeAws_restXmlCreateOriginRequestPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginRequestPolicy = deserializeAws_restXmlOriginRequestPolicy(data, context);
    return contents;
};
exports.deserializeAws_restXmlCreateOriginRequestPolicyCommand = deserializeAws_restXmlCreateOriginRequestPolicyCommand;
const deserializeAws_restXmlCreateOriginRequestPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "OriginRequestPolicyAlreadyExists":
        case "com.amazonaws.cloudfront#OriginRequestPolicyAlreadyExists":
            throw await deserializeAws_restXmlOriginRequestPolicyAlreadyExistsResponse(parsedOutput, context);
        case "TooManyCookiesInOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyCookiesInOriginRequestPolicy":
            throw await deserializeAws_restXmlTooManyCookiesInOriginRequestPolicyResponse(parsedOutput, context);
        case "TooManyHeadersInOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyHeadersInOriginRequestPolicy":
            throw await deserializeAws_restXmlTooManyHeadersInOriginRequestPolicyResponse(parsedOutput, context);
        case "TooManyOriginRequestPolicies":
        case "com.amazonaws.cloudfront#TooManyOriginRequestPolicies":
            throw await deserializeAws_restXmlTooManyOriginRequestPoliciesResponse(parsedOutput, context);
        case "TooManyQueryStringsInOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyQueryStringsInOriginRequestPolicy":
            throw await deserializeAws_restXmlTooManyQueryStringsInOriginRequestPolicyResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlCreatePublicKeyCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return deserializeAws_restXmlCreatePublicKeyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.PublicKey = deserializeAws_restXmlPublicKey(data, context);
    return contents;
};
exports.deserializeAws_restXmlCreatePublicKeyCommand = deserializeAws_restXmlCreatePublicKeyCommand;
const deserializeAws_restXmlCreatePublicKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "PublicKeyAlreadyExists":
        case "com.amazonaws.cloudfront#PublicKeyAlreadyExists":
            throw await deserializeAws_restXmlPublicKeyAlreadyExistsResponse(parsedOutput, context);
        case "TooManyPublicKeys":
        case "com.amazonaws.cloudfront#TooManyPublicKeys":
            throw await deserializeAws_restXmlTooManyPublicKeysResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlCreateRealtimeLogConfigCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return deserializeAws_restXmlCreateRealtimeLogConfigCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data["RealtimeLogConfig"] !== undefined) {
        contents.RealtimeLogConfig = deserializeAws_restXmlRealtimeLogConfig(data["RealtimeLogConfig"], context);
    }
    return contents;
};
exports.deserializeAws_restXmlCreateRealtimeLogConfigCommand = deserializeAws_restXmlCreateRealtimeLogConfigCommand;
const deserializeAws_restXmlCreateRealtimeLogConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "RealtimeLogConfigAlreadyExists":
        case "com.amazonaws.cloudfront#RealtimeLogConfigAlreadyExists":
            throw await deserializeAws_restXmlRealtimeLogConfigAlreadyExistsResponse(parsedOutput, context);
        case "TooManyRealtimeLogConfigs":
        case "com.amazonaws.cloudfront#TooManyRealtimeLogConfigs":
            throw await deserializeAws_restXmlTooManyRealtimeLogConfigsResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlCreateResponseHeadersPolicyCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return deserializeAws_restXmlCreateResponseHeadersPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ResponseHeadersPolicy = deserializeAws_restXmlResponseHeadersPolicy(data, context);
    return contents;
};
exports.deserializeAws_restXmlCreateResponseHeadersPolicyCommand = deserializeAws_restXmlCreateResponseHeadersPolicyCommand;
const deserializeAws_restXmlCreateResponseHeadersPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "ResponseHeadersPolicyAlreadyExists":
        case "com.amazonaws.cloudfront#ResponseHeadersPolicyAlreadyExists":
            throw await deserializeAws_restXmlResponseHeadersPolicyAlreadyExistsResponse(parsedOutput, context);
        case "TooLongCSPInResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooLongCSPInResponseHeadersPolicy":
            throw await deserializeAws_restXmlTooLongCSPInResponseHeadersPolicyResponse(parsedOutput, context);
        case "TooManyCustomHeadersInResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooManyCustomHeadersInResponseHeadersPolicy":
            throw await deserializeAws_restXmlTooManyCustomHeadersInResponseHeadersPolicyResponse(parsedOutput, context);
        case "TooManyResponseHeadersPolicies":
        case "com.amazonaws.cloudfront#TooManyResponseHeadersPolicies":
            throw await deserializeAws_restXmlTooManyResponseHeadersPoliciesResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlCreateStreamingDistributionCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return deserializeAws_restXmlCreateStreamingDistributionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.StreamingDistribution = deserializeAws_restXmlStreamingDistribution(data, context);
    return contents;
};
exports.deserializeAws_restXmlCreateStreamingDistributionCommand = deserializeAws_restXmlCreateStreamingDistributionCommand;
const deserializeAws_restXmlCreateStreamingDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "CNAMEAlreadyExists":
        case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
            throw await deserializeAws_restXmlCNAMEAlreadyExistsResponse(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "InvalidOrigin":
        case "com.amazonaws.cloudfront#InvalidOrigin":
            throw await deserializeAws_restXmlInvalidOriginResponse(parsedOutput, context);
        case "InvalidOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidOriginAccessControl":
            throw await deserializeAws_restXmlInvalidOriginAccessControlResponse(parsedOutput, context);
        case "InvalidOriginAccessIdentity":
        case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
            throw await deserializeAws_restXmlInvalidOriginAccessIdentityResponse(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await deserializeAws_restXmlMissingBodyResponse(parsedOutput, context);
        case "StreamingDistributionAlreadyExists":
        case "com.amazonaws.cloudfront#StreamingDistributionAlreadyExists":
            throw await deserializeAws_restXmlStreamingDistributionAlreadyExistsResponse(parsedOutput, context);
        case "TooManyStreamingDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyStreamingDistributionCNAMEs":
            throw await deserializeAws_restXmlTooManyStreamingDistributionCNAMEsResponse(parsedOutput, context);
        case "TooManyStreamingDistributions":
        case "com.amazonaws.cloudfront#TooManyStreamingDistributions":
            throw await deserializeAws_restXmlTooManyStreamingDistributionsResponse(parsedOutput, context);
        case "TooManyTrustedSigners":
        case "com.amazonaws.cloudfront#TooManyTrustedSigners":
            throw await deserializeAws_restXmlTooManyTrustedSignersResponse(parsedOutput, context);
        case "TrustedSignerDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
            throw await deserializeAws_restXmlTrustedSignerDoesNotExistResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlCreateStreamingDistributionWithTagsCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return deserializeAws_restXmlCreateStreamingDistributionWithTagsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.StreamingDistribution = deserializeAws_restXmlStreamingDistribution(data, context);
    return contents;
};
exports.deserializeAws_restXmlCreateStreamingDistributionWithTagsCommand = deserializeAws_restXmlCreateStreamingDistributionWithTagsCommand;
const deserializeAws_restXmlCreateStreamingDistributionWithTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "CNAMEAlreadyExists":
        case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
            throw await deserializeAws_restXmlCNAMEAlreadyExistsResponse(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "InvalidOrigin":
        case "com.amazonaws.cloudfront#InvalidOrigin":
            throw await deserializeAws_restXmlInvalidOriginResponse(parsedOutput, context);
        case "InvalidOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidOriginAccessControl":
            throw await deserializeAws_restXmlInvalidOriginAccessControlResponse(parsedOutput, context);
        case "InvalidOriginAccessIdentity":
        case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
            throw await deserializeAws_restXmlInvalidOriginAccessIdentityResponse(parsedOutput, context);
        case "InvalidTagging":
        case "com.amazonaws.cloudfront#InvalidTagging":
            throw await deserializeAws_restXmlInvalidTaggingResponse(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await deserializeAws_restXmlMissingBodyResponse(parsedOutput, context);
        case "StreamingDistributionAlreadyExists":
        case "com.amazonaws.cloudfront#StreamingDistributionAlreadyExists":
            throw await deserializeAws_restXmlStreamingDistributionAlreadyExistsResponse(parsedOutput, context);
        case "TooManyStreamingDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyStreamingDistributionCNAMEs":
            throw await deserializeAws_restXmlTooManyStreamingDistributionCNAMEsResponse(parsedOutput, context);
        case "TooManyStreamingDistributions":
        case "com.amazonaws.cloudfront#TooManyStreamingDistributions":
            throw await deserializeAws_restXmlTooManyStreamingDistributionsResponse(parsedOutput, context);
        case "TooManyTrustedSigners":
        case "com.amazonaws.cloudfront#TooManyTrustedSigners":
            throw await deserializeAws_restXmlTooManyTrustedSignersResponse(parsedOutput, context);
        case "TrustedSignerDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
            throw await deserializeAws_restXmlTrustedSignerDoesNotExistResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlDeleteCachePolicyCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return deserializeAws_restXmlDeleteCachePolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
exports.deserializeAws_restXmlDeleteCachePolicyCommand = deserializeAws_restXmlDeleteCachePolicyCommand;
const deserializeAws_restXmlDeleteCachePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "CachePolicyInUse":
        case "com.amazonaws.cloudfront#CachePolicyInUse":
            throw await deserializeAws_restXmlCachePolicyInUseResponse(parsedOutput, context);
        case "IllegalDelete":
        case "com.amazonaws.cloudfront#IllegalDelete":
            throw await deserializeAws_restXmlIllegalDeleteResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await deserializeAws_restXmlNoSuchCachePolicyResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlDeleteCloudFrontOriginAccessIdentityCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return deserializeAws_restXmlDeleteCloudFrontOriginAccessIdentityCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
exports.deserializeAws_restXmlDeleteCloudFrontOriginAccessIdentityCommand = deserializeAws_restXmlDeleteCloudFrontOriginAccessIdentityCommand;
const deserializeAws_restXmlDeleteCloudFrontOriginAccessIdentityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "CloudFrontOriginAccessIdentityInUse":
        case "com.amazonaws.cloudfront#CloudFrontOriginAccessIdentityInUse":
            throw await deserializeAws_restXmlCloudFrontOriginAccessIdentityInUseResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "NoSuchCloudFrontOriginAccessIdentity":
        case "com.amazonaws.cloudfront#NoSuchCloudFrontOriginAccessIdentity":
            throw await deserializeAws_restXmlNoSuchCloudFrontOriginAccessIdentityResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlDeleteContinuousDeploymentPolicyCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return deserializeAws_restXmlDeleteContinuousDeploymentPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
exports.deserializeAws_restXmlDeleteContinuousDeploymentPolicyCommand = deserializeAws_restXmlDeleteContinuousDeploymentPolicyCommand;
const deserializeAws_restXmlDeleteContinuousDeploymentPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlDeleteDistributionCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return deserializeAws_restXmlDeleteDistributionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
exports.deserializeAws_restXmlDeleteDistributionCommand = deserializeAws_restXmlDeleteDistributionCommand;
const deserializeAws_restXmlDeleteDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "DistributionNotDisabled":
        case "com.amazonaws.cloudfront#DistributionNotDisabled":
            throw await deserializeAws_restXmlDistributionNotDisabledResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await deserializeAws_restXmlNoSuchDistributionResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlDeleteFieldLevelEncryptionConfigCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return deserializeAws_restXmlDeleteFieldLevelEncryptionConfigCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
exports.deserializeAws_restXmlDeleteFieldLevelEncryptionConfigCommand = deserializeAws_restXmlDeleteFieldLevelEncryptionConfigCommand;
const deserializeAws_restXmlDeleteFieldLevelEncryptionConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "FieldLevelEncryptionConfigInUse":
        case "com.amazonaws.cloudfront#FieldLevelEncryptionConfigInUse":
            throw await deserializeAws_restXmlFieldLevelEncryptionConfigInUseResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await deserializeAws_restXmlNoSuchFieldLevelEncryptionConfigResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlDeleteFieldLevelEncryptionProfileCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return deserializeAws_restXmlDeleteFieldLevelEncryptionProfileCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
exports.deserializeAws_restXmlDeleteFieldLevelEncryptionProfileCommand = deserializeAws_restXmlDeleteFieldLevelEncryptionProfileCommand;
const deserializeAws_restXmlDeleteFieldLevelEncryptionProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "FieldLevelEncryptionProfileInUse":
        case "com.amazonaws.cloudfront#FieldLevelEncryptionProfileInUse":
            throw await deserializeAws_restXmlFieldLevelEncryptionProfileInUseResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionProfile":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
            throw await deserializeAws_restXmlNoSuchFieldLevelEncryptionProfileResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlDeleteFunctionCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return deserializeAws_restXmlDeleteFunctionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
exports.deserializeAws_restXmlDeleteFunctionCommand = deserializeAws_restXmlDeleteFunctionCommand;
const deserializeAws_restXmlDeleteFunctionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "FunctionInUse":
        case "com.amazonaws.cloudfront#FunctionInUse":
            throw await deserializeAws_restXmlFunctionInUseResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "NoSuchFunctionExists":
        case "com.amazonaws.cloudfront#NoSuchFunctionExists":
            throw await deserializeAws_restXmlNoSuchFunctionExistsResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await deserializeAws_restXmlUnsupportedOperationResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlDeleteKeyGroupCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return deserializeAws_restXmlDeleteKeyGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
exports.deserializeAws_restXmlDeleteKeyGroupCommand = deserializeAws_restXmlDeleteKeyGroupCommand;
const deserializeAws_restXmlDeleteKeyGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "NoSuchResource":
        case "com.amazonaws.cloudfront#NoSuchResource":
            throw await deserializeAws_restXmlNoSuchResourceResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        case "ResourceInUse":
        case "com.amazonaws.cloudfront#ResourceInUse":
            throw await deserializeAws_restXmlResourceInUseResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlDeleteMonitoringSubscriptionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlDeleteMonitoringSubscriptionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
exports.deserializeAws_restXmlDeleteMonitoringSubscriptionCommand = deserializeAws_restXmlDeleteMonitoringSubscriptionCommand;
const deserializeAws_restXmlDeleteMonitoringSubscriptionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await deserializeAws_restXmlNoSuchDistributionResponse(parsedOutput, context);
        case "NoSuchMonitoringSubscription":
        case "com.amazonaws.cloudfront#NoSuchMonitoringSubscription":
            throw await deserializeAws_restXmlNoSuchMonitoringSubscriptionResponse(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await deserializeAws_restXmlUnsupportedOperationResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlDeleteOriginAccessControlCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return deserializeAws_restXmlDeleteOriginAccessControlCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
exports.deserializeAws_restXmlDeleteOriginAccessControlCommand = deserializeAws_restXmlDeleteOriginAccessControlCommand;
const deserializeAws_restXmlDeleteOriginAccessControlCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "NoSuchOriginAccessControl":
        case "com.amazonaws.cloudfront#NoSuchOriginAccessControl":
            throw await deserializeAws_restXmlNoSuchOriginAccessControlResponse(parsedOutput, context);
        case "OriginAccessControlInUse":
        case "com.amazonaws.cloudfront#OriginAccessControlInUse":
            throw await deserializeAws_restXmlOriginAccessControlInUseResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlDeleteOriginRequestPolicyCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return deserializeAws_restXmlDeleteOriginRequestPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
exports.deserializeAws_restXmlDeleteOriginRequestPolicyCommand = deserializeAws_restXmlDeleteOriginRequestPolicyCommand;
const deserializeAws_restXmlDeleteOriginRequestPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "IllegalDelete":
        case "com.amazonaws.cloudfront#IllegalDelete":
            throw await deserializeAws_restXmlIllegalDeleteResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await deserializeAws_restXmlNoSuchOriginRequestPolicyResponse(parsedOutput, context);
        case "OriginRequestPolicyInUse":
        case "com.amazonaws.cloudfront#OriginRequestPolicyInUse":
            throw await deserializeAws_restXmlOriginRequestPolicyInUseResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlDeletePublicKeyCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return deserializeAws_restXmlDeletePublicKeyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
exports.deserializeAws_restXmlDeletePublicKeyCommand = deserializeAws_restXmlDeletePublicKeyCommand;
const deserializeAws_restXmlDeletePublicKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "NoSuchPublicKey":
        case "com.amazonaws.cloudfront#NoSuchPublicKey":
            throw await deserializeAws_restXmlNoSuchPublicKeyResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        case "PublicKeyInUse":
        case "com.amazonaws.cloudfront#PublicKeyInUse":
            throw await deserializeAws_restXmlPublicKeyInUseResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlDeleteRealtimeLogConfigCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return deserializeAws_restXmlDeleteRealtimeLogConfigCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
exports.deserializeAws_restXmlDeleteRealtimeLogConfigCommand = deserializeAws_restXmlDeleteRealtimeLogConfigCommand;
const deserializeAws_restXmlDeleteRealtimeLogConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await deserializeAws_restXmlNoSuchRealtimeLogConfigResponse(parsedOutput, context);
        case "RealtimeLogConfigInUse":
        case "com.amazonaws.cloudfront#RealtimeLogConfigInUse":
            throw await deserializeAws_restXmlRealtimeLogConfigInUseResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlDeleteResponseHeadersPolicyCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return deserializeAws_restXmlDeleteResponseHeadersPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
exports.deserializeAws_restXmlDeleteResponseHeadersPolicyCommand = deserializeAws_restXmlDeleteResponseHeadersPolicyCommand;
const deserializeAws_restXmlDeleteResponseHeadersPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "IllegalDelete":
        case "com.amazonaws.cloudfront#IllegalDelete":
            throw await deserializeAws_restXmlIllegalDeleteResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await deserializeAws_restXmlNoSuchResponseHeadersPolicyResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        case "ResponseHeadersPolicyInUse":
        case "com.amazonaws.cloudfront#ResponseHeadersPolicyInUse":
            throw await deserializeAws_restXmlResponseHeadersPolicyInUseResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlDeleteStreamingDistributionCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return deserializeAws_restXmlDeleteStreamingDistributionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
exports.deserializeAws_restXmlDeleteStreamingDistributionCommand = deserializeAws_restXmlDeleteStreamingDistributionCommand;
const deserializeAws_restXmlDeleteStreamingDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "NoSuchStreamingDistribution":
        case "com.amazonaws.cloudfront#NoSuchStreamingDistribution":
            throw await deserializeAws_restXmlNoSuchStreamingDistributionResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        case "StreamingDistributionNotDisabled":
        case "com.amazonaws.cloudfront#StreamingDistributionNotDisabled":
            throw await deserializeAws_restXmlStreamingDistributionNotDisabledResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlDescribeFunctionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlDescribeFunctionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FunctionSummary = deserializeAws_restXmlFunctionSummary(data, context);
    return contents;
};
exports.deserializeAws_restXmlDescribeFunctionCommand = deserializeAws_restXmlDescribeFunctionCommand;
const deserializeAws_restXmlDescribeFunctionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchFunctionExists":
        case "com.amazonaws.cloudfront#NoSuchFunctionExists":
            throw await deserializeAws_restXmlNoSuchFunctionExistsResponse(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await deserializeAws_restXmlUnsupportedOperationResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetCachePolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetCachePolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CachePolicy = deserializeAws_restXmlCachePolicy(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetCachePolicyCommand = deserializeAws_restXmlGetCachePolicyCommand;
const deserializeAws_restXmlGetCachePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await deserializeAws_restXmlNoSuchCachePolicyResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetCachePolicyConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetCachePolicyConfigCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CachePolicyConfig = deserializeAws_restXmlCachePolicyConfig(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetCachePolicyConfigCommand = deserializeAws_restXmlGetCachePolicyConfigCommand;
const deserializeAws_restXmlGetCachePolicyConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await deserializeAws_restXmlNoSuchCachePolicyResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetCloudFrontOriginAccessIdentityCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetCloudFrontOriginAccessIdentityCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CloudFrontOriginAccessIdentity = deserializeAws_restXmlCloudFrontOriginAccessIdentity(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetCloudFrontOriginAccessIdentityCommand = deserializeAws_restXmlGetCloudFrontOriginAccessIdentityCommand;
const deserializeAws_restXmlGetCloudFrontOriginAccessIdentityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "NoSuchCloudFrontOriginAccessIdentity":
        case "com.amazonaws.cloudfront#NoSuchCloudFrontOriginAccessIdentity":
            throw await deserializeAws_restXmlNoSuchCloudFrontOriginAccessIdentityResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetCloudFrontOriginAccessIdentityConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetCloudFrontOriginAccessIdentityConfigCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CloudFrontOriginAccessIdentityConfig = deserializeAws_restXmlCloudFrontOriginAccessIdentityConfig(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetCloudFrontOriginAccessIdentityConfigCommand = deserializeAws_restXmlGetCloudFrontOriginAccessIdentityConfigCommand;
const deserializeAws_restXmlGetCloudFrontOriginAccessIdentityConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "NoSuchCloudFrontOriginAccessIdentity":
        case "com.amazonaws.cloudfront#NoSuchCloudFrontOriginAccessIdentity":
            throw await deserializeAws_restXmlNoSuchCloudFrontOriginAccessIdentityResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetContinuousDeploymentPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetContinuousDeploymentPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ContinuousDeploymentPolicy = deserializeAws_restXmlContinuousDeploymentPolicy(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetContinuousDeploymentPolicyCommand = deserializeAws_restXmlGetContinuousDeploymentPolicyCommand;
const deserializeAws_restXmlGetContinuousDeploymentPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetContinuousDeploymentPolicyConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetContinuousDeploymentPolicyConfigCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ContinuousDeploymentPolicyConfig = deserializeAws_restXmlContinuousDeploymentPolicyConfig(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetContinuousDeploymentPolicyConfigCommand = deserializeAws_restXmlGetContinuousDeploymentPolicyConfigCommand;
const deserializeAws_restXmlGetContinuousDeploymentPolicyConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetDistributionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetDistributionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Distribution = deserializeAws_restXmlDistribution(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetDistributionCommand = deserializeAws_restXmlGetDistributionCommand;
const deserializeAws_restXmlGetDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await deserializeAws_restXmlNoSuchDistributionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetDistributionConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetDistributionConfigCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.DistributionConfig = deserializeAws_restXmlDistributionConfig(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetDistributionConfigCommand = deserializeAws_restXmlGetDistributionConfigCommand;
const deserializeAws_restXmlGetDistributionConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await deserializeAws_restXmlNoSuchDistributionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetFieldLevelEncryptionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetFieldLevelEncryptionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryption = deserializeAws_restXmlFieldLevelEncryption(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetFieldLevelEncryptionCommand = deserializeAws_restXmlGetFieldLevelEncryptionCommand;
const deserializeAws_restXmlGetFieldLevelEncryptionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await deserializeAws_restXmlNoSuchFieldLevelEncryptionConfigResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetFieldLevelEncryptionConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetFieldLevelEncryptionConfigCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryptionConfig = deserializeAws_restXmlFieldLevelEncryptionConfig(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetFieldLevelEncryptionConfigCommand = deserializeAws_restXmlGetFieldLevelEncryptionConfigCommand;
const deserializeAws_restXmlGetFieldLevelEncryptionConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await deserializeAws_restXmlNoSuchFieldLevelEncryptionConfigResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetFieldLevelEncryptionProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetFieldLevelEncryptionProfileCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryptionProfile = deserializeAws_restXmlFieldLevelEncryptionProfile(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetFieldLevelEncryptionProfileCommand = deserializeAws_restXmlGetFieldLevelEncryptionProfileCommand;
const deserializeAws_restXmlGetFieldLevelEncryptionProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionProfile":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
            throw await deserializeAws_restXmlNoSuchFieldLevelEncryptionProfileResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetFieldLevelEncryptionProfileConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetFieldLevelEncryptionProfileConfigCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryptionProfileConfig = deserializeAws_restXmlFieldLevelEncryptionProfileConfig(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetFieldLevelEncryptionProfileConfigCommand = deserializeAws_restXmlGetFieldLevelEncryptionProfileConfigCommand;
const deserializeAws_restXmlGetFieldLevelEncryptionProfileConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionProfile":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
            throw await deserializeAws_restXmlNoSuchFieldLevelEncryptionProfileResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetFunctionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetFunctionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
        ContentType: [, output.headers["content-type"]],
    });
    const data = await collectBody(output.body, context);
    contents.FunctionCode = data;
    return contents;
};
exports.deserializeAws_restXmlGetFunctionCommand = deserializeAws_restXmlGetFunctionCommand;
const deserializeAws_restXmlGetFunctionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchFunctionExists":
        case "com.amazonaws.cloudfront#NoSuchFunctionExists":
            throw await deserializeAws_restXmlNoSuchFunctionExistsResponse(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await deserializeAws_restXmlUnsupportedOperationResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetInvalidationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetInvalidationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Invalidation = deserializeAws_restXmlInvalidation(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetInvalidationCommand = deserializeAws_restXmlGetInvalidationCommand;
const deserializeAws_restXmlGetInvalidationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await deserializeAws_restXmlNoSuchDistributionResponse(parsedOutput, context);
        case "NoSuchInvalidation":
        case "com.amazonaws.cloudfront#NoSuchInvalidation":
            throw await deserializeAws_restXmlNoSuchInvalidationResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetKeyGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetKeyGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.KeyGroup = deserializeAws_restXmlKeyGroup(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetKeyGroupCommand = deserializeAws_restXmlGetKeyGroupCommand;
const deserializeAws_restXmlGetKeyGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchResource":
        case "com.amazonaws.cloudfront#NoSuchResource":
            throw await deserializeAws_restXmlNoSuchResourceResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetKeyGroupConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetKeyGroupConfigCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.KeyGroupConfig = deserializeAws_restXmlKeyGroupConfig(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetKeyGroupConfigCommand = deserializeAws_restXmlGetKeyGroupConfigCommand;
const deserializeAws_restXmlGetKeyGroupConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchResource":
        case "com.amazonaws.cloudfront#NoSuchResource":
            throw await deserializeAws_restXmlNoSuchResourceResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetMonitoringSubscriptionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetMonitoringSubscriptionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.MonitoringSubscription = deserializeAws_restXmlMonitoringSubscription(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetMonitoringSubscriptionCommand = deserializeAws_restXmlGetMonitoringSubscriptionCommand;
const deserializeAws_restXmlGetMonitoringSubscriptionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await deserializeAws_restXmlNoSuchDistributionResponse(parsedOutput, context);
        case "NoSuchMonitoringSubscription":
        case "com.amazonaws.cloudfront#NoSuchMonitoringSubscription":
            throw await deserializeAws_restXmlNoSuchMonitoringSubscriptionResponse(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await deserializeAws_restXmlUnsupportedOperationResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetOriginAccessControlCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetOriginAccessControlCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginAccessControl = deserializeAws_restXmlOriginAccessControl(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetOriginAccessControlCommand = deserializeAws_restXmlGetOriginAccessControlCommand;
const deserializeAws_restXmlGetOriginAccessControlCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "NoSuchOriginAccessControl":
        case "com.amazonaws.cloudfront#NoSuchOriginAccessControl":
            throw await deserializeAws_restXmlNoSuchOriginAccessControlResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetOriginAccessControlConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetOriginAccessControlConfigCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginAccessControlConfig = deserializeAws_restXmlOriginAccessControlConfig(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetOriginAccessControlConfigCommand = deserializeAws_restXmlGetOriginAccessControlConfigCommand;
const deserializeAws_restXmlGetOriginAccessControlConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "NoSuchOriginAccessControl":
        case "com.amazonaws.cloudfront#NoSuchOriginAccessControl":
            throw await deserializeAws_restXmlNoSuchOriginAccessControlResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetOriginRequestPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetOriginRequestPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginRequestPolicy = deserializeAws_restXmlOriginRequestPolicy(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetOriginRequestPolicyCommand = deserializeAws_restXmlGetOriginRequestPolicyCommand;
const deserializeAws_restXmlGetOriginRequestPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await deserializeAws_restXmlNoSuchOriginRequestPolicyResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetOriginRequestPolicyConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetOriginRequestPolicyConfigCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginRequestPolicyConfig = deserializeAws_restXmlOriginRequestPolicyConfig(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetOriginRequestPolicyConfigCommand = deserializeAws_restXmlGetOriginRequestPolicyConfigCommand;
const deserializeAws_restXmlGetOriginRequestPolicyConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await deserializeAws_restXmlNoSuchOriginRequestPolicyResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetPublicKeyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetPublicKeyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.PublicKey = deserializeAws_restXmlPublicKey(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetPublicKeyCommand = deserializeAws_restXmlGetPublicKeyCommand;
const deserializeAws_restXmlGetPublicKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "NoSuchPublicKey":
        case "com.amazonaws.cloudfront#NoSuchPublicKey":
            throw await deserializeAws_restXmlNoSuchPublicKeyResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetPublicKeyConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetPublicKeyConfigCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.PublicKeyConfig = deserializeAws_restXmlPublicKeyConfig(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetPublicKeyConfigCommand = deserializeAws_restXmlGetPublicKeyConfigCommand;
const deserializeAws_restXmlGetPublicKeyConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "NoSuchPublicKey":
        case "com.amazonaws.cloudfront#NoSuchPublicKey":
            throw await deserializeAws_restXmlNoSuchPublicKeyResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetRealtimeLogConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetRealtimeLogConfigCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data["RealtimeLogConfig"] !== undefined) {
        contents.RealtimeLogConfig = deserializeAws_restXmlRealtimeLogConfig(data["RealtimeLogConfig"], context);
    }
    return contents;
};
exports.deserializeAws_restXmlGetRealtimeLogConfigCommand = deserializeAws_restXmlGetRealtimeLogConfigCommand;
const deserializeAws_restXmlGetRealtimeLogConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await deserializeAws_restXmlNoSuchRealtimeLogConfigResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetResponseHeadersPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetResponseHeadersPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ResponseHeadersPolicy = deserializeAws_restXmlResponseHeadersPolicy(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetResponseHeadersPolicyCommand = deserializeAws_restXmlGetResponseHeadersPolicyCommand;
const deserializeAws_restXmlGetResponseHeadersPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await deserializeAws_restXmlNoSuchResponseHeadersPolicyResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetResponseHeadersPolicyConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetResponseHeadersPolicyConfigCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ResponseHeadersPolicyConfig = deserializeAws_restXmlResponseHeadersPolicyConfig(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetResponseHeadersPolicyConfigCommand = deserializeAws_restXmlGetResponseHeadersPolicyConfigCommand;
const deserializeAws_restXmlGetResponseHeadersPolicyConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await deserializeAws_restXmlNoSuchResponseHeadersPolicyResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetStreamingDistributionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetStreamingDistributionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.StreamingDistribution = deserializeAws_restXmlStreamingDistribution(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetStreamingDistributionCommand = deserializeAws_restXmlGetStreamingDistributionCommand;
const deserializeAws_restXmlGetStreamingDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "NoSuchStreamingDistribution":
        case "com.amazonaws.cloudfront#NoSuchStreamingDistribution":
            throw await deserializeAws_restXmlNoSuchStreamingDistributionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlGetStreamingDistributionConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlGetStreamingDistributionConfigCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.StreamingDistributionConfig = deserializeAws_restXmlStreamingDistributionConfig(data, context);
    return contents;
};
exports.deserializeAws_restXmlGetStreamingDistributionConfigCommand = deserializeAws_restXmlGetStreamingDistributionConfigCommand;
const deserializeAws_restXmlGetStreamingDistributionConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "NoSuchStreamingDistribution":
        case "com.amazonaws.cloudfront#NoSuchStreamingDistribution":
            throw await deserializeAws_restXmlNoSuchStreamingDistributionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlListCachePoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlListCachePoliciesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CachePolicyList = deserializeAws_restXmlCachePolicyList(data, context);
    return contents;
};
exports.deserializeAws_restXmlListCachePoliciesCommand = deserializeAws_restXmlListCachePoliciesCommand;
const deserializeAws_restXmlListCachePoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await deserializeAws_restXmlNoSuchCachePolicyResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlListCloudFrontOriginAccessIdentitiesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlListCloudFrontOriginAccessIdentitiesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CloudFrontOriginAccessIdentityList = deserializeAws_restXmlCloudFrontOriginAccessIdentityList(data, context);
    return contents;
};
exports.deserializeAws_restXmlListCloudFrontOriginAccessIdentitiesCommand = deserializeAws_restXmlListCloudFrontOriginAccessIdentitiesCommand;
const deserializeAws_restXmlListCloudFrontOriginAccessIdentitiesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlListConflictingAliasesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlListConflictingAliasesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ConflictingAliasesList = deserializeAws_restXmlConflictingAliasesList(data, context);
    return contents;
};
exports.deserializeAws_restXmlListConflictingAliasesCommand = deserializeAws_restXmlListConflictingAliasesCommand;
const deserializeAws_restXmlListConflictingAliasesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await deserializeAws_restXmlNoSuchDistributionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlListContinuousDeploymentPoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlListContinuousDeploymentPoliciesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ContinuousDeploymentPolicyList = deserializeAws_restXmlContinuousDeploymentPolicyList(data, context);
    return contents;
};
exports.deserializeAws_restXmlListContinuousDeploymentPoliciesCommand = deserializeAws_restXmlListContinuousDeploymentPoliciesCommand;
const deserializeAws_restXmlListContinuousDeploymentPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlListDistributionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlListDistributionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.DistributionList = deserializeAws_restXmlDistributionList(data, context);
    return contents;
};
exports.deserializeAws_restXmlListDistributionsCommand = deserializeAws_restXmlListDistributionsCommand;
const deserializeAws_restXmlListDistributionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlListDistributionsByCachePolicyIdCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlListDistributionsByCachePolicyIdCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.DistributionIdList = deserializeAws_restXmlDistributionIdList(data, context);
    return contents;
};
exports.deserializeAws_restXmlListDistributionsByCachePolicyIdCommand = deserializeAws_restXmlListDistributionsByCachePolicyIdCommand;
const deserializeAws_restXmlListDistributionsByCachePolicyIdCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await deserializeAws_restXmlNoSuchCachePolicyResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlListDistributionsByKeyGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlListDistributionsByKeyGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.DistributionIdList = deserializeAws_restXmlDistributionIdList(data, context);
    return contents;
};
exports.deserializeAws_restXmlListDistributionsByKeyGroupCommand = deserializeAws_restXmlListDistributionsByKeyGroupCommand;
const deserializeAws_restXmlListDistributionsByKeyGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "NoSuchResource":
        case "com.amazonaws.cloudfront#NoSuchResource":
            throw await deserializeAws_restXmlNoSuchResourceResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlListDistributionsByOriginRequestPolicyIdCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlListDistributionsByOriginRequestPolicyIdCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.DistributionIdList = deserializeAws_restXmlDistributionIdList(data, context);
    return contents;
};
exports.deserializeAws_restXmlListDistributionsByOriginRequestPolicyIdCommand = deserializeAws_restXmlListDistributionsByOriginRequestPolicyIdCommand;
const deserializeAws_restXmlListDistributionsByOriginRequestPolicyIdCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await deserializeAws_restXmlNoSuchOriginRequestPolicyResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlListDistributionsByRealtimeLogConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlListDistributionsByRealtimeLogConfigCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.DistributionList = deserializeAws_restXmlDistributionList(data, context);
    return contents;
};
exports.deserializeAws_restXmlListDistributionsByRealtimeLogConfigCommand = deserializeAws_restXmlListDistributionsByRealtimeLogConfigCommand;
const deserializeAws_restXmlListDistributionsByRealtimeLogConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlListDistributionsByResponseHeadersPolicyIdCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlListDistributionsByResponseHeadersPolicyIdCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.DistributionIdList = deserializeAws_restXmlDistributionIdList(data, context);
    return contents;
};
exports.deserializeAws_restXmlListDistributionsByResponseHeadersPolicyIdCommand = deserializeAws_restXmlListDistributionsByResponseHeadersPolicyIdCommand;
const deserializeAws_restXmlListDistributionsByResponseHeadersPolicyIdCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await deserializeAws_restXmlNoSuchResponseHeadersPolicyResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlListDistributionsByWebACLIdCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlListDistributionsByWebACLIdCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.DistributionList = deserializeAws_restXmlDistributionList(data, context);
    return contents;
};
exports.deserializeAws_restXmlListDistributionsByWebACLIdCommand = deserializeAws_restXmlListDistributionsByWebACLIdCommand;
const deserializeAws_restXmlListDistributionsByWebACLIdCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "InvalidWebACLId":
        case "com.amazonaws.cloudfront#InvalidWebACLId":
            throw await deserializeAws_restXmlInvalidWebACLIdResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlListFieldLevelEncryptionConfigsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlListFieldLevelEncryptionConfigsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryptionList = deserializeAws_restXmlFieldLevelEncryptionList(data, context);
    return contents;
};
exports.deserializeAws_restXmlListFieldLevelEncryptionConfigsCommand = deserializeAws_restXmlListFieldLevelEncryptionConfigsCommand;
const deserializeAws_restXmlListFieldLevelEncryptionConfigsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlListFieldLevelEncryptionProfilesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlListFieldLevelEncryptionProfilesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryptionProfileList = deserializeAws_restXmlFieldLevelEncryptionProfileList(data, context);
    return contents;
};
exports.deserializeAws_restXmlListFieldLevelEncryptionProfilesCommand = deserializeAws_restXmlListFieldLevelEncryptionProfilesCommand;
const deserializeAws_restXmlListFieldLevelEncryptionProfilesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlListFunctionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlListFunctionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FunctionList = deserializeAws_restXmlFunctionList(data, context);
    return contents;
};
exports.deserializeAws_restXmlListFunctionsCommand = deserializeAws_restXmlListFunctionsCommand;
const deserializeAws_restXmlListFunctionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await deserializeAws_restXmlUnsupportedOperationResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlListInvalidationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlListInvalidationsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.InvalidationList = deserializeAws_restXmlInvalidationList(data, context);
    return contents;
};
exports.deserializeAws_restXmlListInvalidationsCommand = deserializeAws_restXmlListInvalidationsCommand;
const deserializeAws_restXmlListInvalidationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await deserializeAws_restXmlNoSuchDistributionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlListKeyGroupsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlListKeyGroupsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.KeyGroupList = deserializeAws_restXmlKeyGroupList(data, context);
    return contents;
};
exports.deserializeAws_restXmlListKeyGroupsCommand = deserializeAws_restXmlListKeyGroupsCommand;
const deserializeAws_restXmlListKeyGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlListOriginAccessControlsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlListOriginAccessControlsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginAccessControlList = deserializeAws_restXmlOriginAccessControlList(data, context);
    return contents;
};
exports.deserializeAws_restXmlListOriginAccessControlsCommand = deserializeAws_restXmlListOriginAccessControlsCommand;
const deserializeAws_restXmlListOriginAccessControlsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlListOriginRequestPoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlListOriginRequestPoliciesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginRequestPolicyList = deserializeAws_restXmlOriginRequestPolicyList(data, context);
    return contents;
};
exports.deserializeAws_restXmlListOriginRequestPoliciesCommand = deserializeAws_restXmlListOriginRequestPoliciesCommand;
const deserializeAws_restXmlListOriginRequestPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await deserializeAws_restXmlNoSuchOriginRequestPolicyResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlListPublicKeysCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlListPublicKeysCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.PublicKeyList = deserializeAws_restXmlPublicKeyList(data, context);
    return contents;
};
exports.deserializeAws_restXmlListPublicKeysCommand = deserializeAws_restXmlListPublicKeysCommand;
const deserializeAws_restXmlListPublicKeysCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlListRealtimeLogConfigsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlListRealtimeLogConfigsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.RealtimeLogConfigs = deserializeAws_restXmlRealtimeLogConfigs(data, context);
    return contents;
};
exports.deserializeAws_restXmlListRealtimeLogConfigsCommand = deserializeAws_restXmlListRealtimeLogConfigsCommand;
const deserializeAws_restXmlListRealtimeLogConfigsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await deserializeAws_restXmlNoSuchRealtimeLogConfigResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlListResponseHeadersPoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlListResponseHeadersPoliciesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ResponseHeadersPolicyList = deserializeAws_restXmlResponseHeadersPolicyList(data, context);
    return contents;
};
exports.deserializeAws_restXmlListResponseHeadersPoliciesCommand = deserializeAws_restXmlListResponseHeadersPoliciesCommand;
const deserializeAws_restXmlListResponseHeadersPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await deserializeAws_restXmlNoSuchResponseHeadersPolicyResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlListStreamingDistributionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlListStreamingDistributionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.StreamingDistributionList = deserializeAws_restXmlStreamingDistributionList(data, context);
    return contents;
};
exports.deserializeAws_restXmlListStreamingDistributionsCommand = deserializeAws_restXmlListStreamingDistributionsCommand;
const deserializeAws_restXmlListStreamingDistributionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlListTagsForResourceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Tags = deserializeAws_restXmlTags(data, context);
    return contents;
};
exports.deserializeAws_restXmlListTagsForResourceCommand = deserializeAws_restXmlListTagsForResourceCommand;
const deserializeAws_restXmlListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "InvalidTagging":
        case "com.amazonaws.cloudfront#InvalidTagging":
            throw await deserializeAws_restXmlInvalidTaggingResponse(parsedOutput, context);
        case "NoSuchResource":
        case "com.amazonaws.cloudfront#NoSuchResource":
            throw await deserializeAws_restXmlNoSuchResourceResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlPublishFunctionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlPublishFunctionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FunctionSummary = deserializeAws_restXmlFunctionSummary(data, context);
    return contents;
};
exports.deserializeAws_restXmlPublishFunctionCommand = deserializeAws_restXmlPublishFunctionCommand;
const deserializeAws_restXmlPublishFunctionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "NoSuchFunctionExists":
        case "com.amazonaws.cloudfront#NoSuchFunctionExists":
            throw await deserializeAws_restXmlNoSuchFunctionExistsResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await deserializeAws_restXmlUnsupportedOperationResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlTagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return deserializeAws_restXmlTagResourceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
exports.deserializeAws_restXmlTagResourceCommand = deserializeAws_restXmlTagResourceCommand;
const deserializeAws_restXmlTagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "InvalidTagging":
        case "com.amazonaws.cloudfront#InvalidTagging":
            throw await deserializeAws_restXmlInvalidTaggingResponse(parsedOutput, context);
        case "NoSuchResource":
        case "com.amazonaws.cloudfront#NoSuchResource":
            throw await deserializeAws_restXmlNoSuchResourceResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlTestFunctionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlTestFunctionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.TestResult = deserializeAws_restXmlTestResult(data, context);
    return contents;
};
exports.deserializeAws_restXmlTestFunctionCommand = deserializeAws_restXmlTestFunctionCommand;
const deserializeAws_restXmlTestFunctionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "NoSuchFunctionExists":
        case "com.amazonaws.cloudfront#NoSuchFunctionExists":
            throw await deserializeAws_restXmlNoSuchFunctionExistsResponse(parsedOutput, context);
        case "TestFunctionFailed":
        case "com.amazonaws.cloudfront#TestFunctionFailed":
            throw await deserializeAws_restXmlTestFunctionFailedResponse(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await deserializeAws_restXmlUnsupportedOperationResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlUntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return deserializeAws_restXmlUntagResourceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
exports.deserializeAws_restXmlUntagResourceCommand = deserializeAws_restXmlUntagResourceCommand;
const deserializeAws_restXmlUntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "InvalidTagging":
        case "com.amazonaws.cloudfront#InvalidTagging":
            throw await deserializeAws_restXmlInvalidTaggingResponse(parsedOutput, context);
        case "NoSuchResource":
        case "com.amazonaws.cloudfront#NoSuchResource":
            throw await deserializeAws_restXmlNoSuchResourceResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlUpdateCachePolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlUpdateCachePolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CachePolicy = deserializeAws_restXmlCachePolicy(data, context);
    return contents;
};
exports.deserializeAws_restXmlUpdateCachePolicyCommand = deserializeAws_restXmlUpdateCachePolicyCommand;
const deserializeAws_restXmlUpdateCachePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "CachePolicyAlreadyExists":
        case "com.amazonaws.cloudfront#CachePolicyAlreadyExists":
            throw await deserializeAws_restXmlCachePolicyAlreadyExistsResponse(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await deserializeAws_restXmlIllegalUpdateResponse(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await deserializeAws_restXmlNoSuchCachePolicyResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        case "TooManyCookiesInCachePolicy":
        case "com.amazonaws.cloudfront#TooManyCookiesInCachePolicy":
            throw await deserializeAws_restXmlTooManyCookiesInCachePolicyResponse(parsedOutput, context);
        case "TooManyHeadersInCachePolicy":
        case "com.amazonaws.cloudfront#TooManyHeadersInCachePolicy":
            throw await deserializeAws_restXmlTooManyHeadersInCachePolicyResponse(parsedOutput, context);
        case "TooManyQueryStringsInCachePolicy":
        case "com.amazonaws.cloudfront#TooManyQueryStringsInCachePolicy":
            throw await deserializeAws_restXmlTooManyQueryStringsInCachePolicyResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlUpdateCloudFrontOriginAccessIdentityCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlUpdateCloudFrontOriginAccessIdentityCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CloudFrontOriginAccessIdentity = deserializeAws_restXmlCloudFrontOriginAccessIdentity(data, context);
    return contents;
};
exports.deserializeAws_restXmlUpdateCloudFrontOriginAccessIdentityCommand = deserializeAws_restXmlUpdateCloudFrontOriginAccessIdentityCommand;
const deserializeAws_restXmlUpdateCloudFrontOriginAccessIdentityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await deserializeAws_restXmlIllegalUpdateResponse(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await deserializeAws_restXmlMissingBodyResponse(parsedOutput, context);
        case "NoSuchCloudFrontOriginAccessIdentity":
        case "com.amazonaws.cloudfront#NoSuchCloudFrontOriginAccessIdentity":
            throw await deserializeAws_restXmlNoSuchCloudFrontOriginAccessIdentityResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlUpdateContinuousDeploymentPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlUpdateContinuousDeploymentPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ContinuousDeploymentPolicy = deserializeAws_restXmlContinuousDeploymentPolicy(data, context);
    return contents;
};
exports.deserializeAws_restXmlUpdateContinuousDeploymentPolicyCommand = deserializeAws_restXmlUpdateContinuousDeploymentPolicyCommand;
const deserializeAws_restXmlUpdateContinuousDeploymentPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        case "StagingDistributionInUse":
        case "com.amazonaws.cloudfront#StagingDistributionInUse":
            throw await deserializeAws_restXmlStagingDistributionInUseResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlUpdateDistributionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlUpdateDistributionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Distribution = deserializeAws_restXmlDistribution(data, context);
    return contents;
};
exports.deserializeAws_restXmlUpdateDistributionCommand = deserializeAws_restXmlUpdateDistributionCommand;
const deserializeAws_restXmlUpdateDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "CNAMEAlreadyExists":
        case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
            throw await deserializeAws_restXmlCNAMEAlreadyExistsResponse(parsedOutput, context);
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
        case "com.amazonaws.cloudfront#IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
            throw await deserializeAws_restXmlIllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorResponse(parsedOutput, context);
        case "IllegalOriginAccessConfiguration":
        case "com.amazonaws.cloudfront#IllegalOriginAccessConfiguration":
            throw await deserializeAws_restXmlIllegalOriginAccessConfigurationResponse(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await deserializeAws_restXmlIllegalUpdateResponse(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "InvalidDefaultRootObject":
        case "com.amazonaws.cloudfront#InvalidDefaultRootObject":
            throw await deserializeAws_restXmlInvalidDefaultRootObjectResponse(parsedOutput, context);
        case "InvalidDomainNameForOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidDomainNameForOriginAccessControl":
            throw await deserializeAws_restXmlInvalidDomainNameForOriginAccessControlResponse(parsedOutput, context);
        case "InvalidErrorCode":
        case "com.amazonaws.cloudfront#InvalidErrorCode":
            throw await deserializeAws_restXmlInvalidErrorCodeResponse(parsedOutput, context);
        case "InvalidForwardCookies":
        case "com.amazonaws.cloudfront#InvalidForwardCookies":
            throw await deserializeAws_restXmlInvalidForwardCookiesResponse(parsedOutput, context);
        case "InvalidFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidFunctionAssociation":
            throw await deserializeAws_restXmlInvalidFunctionAssociationResponse(parsedOutput, context);
        case "InvalidGeoRestrictionParameter":
        case "com.amazonaws.cloudfront#InvalidGeoRestrictionParameter":
            throw await deserializeAws_restXmlInvalidGeoRestrictionParameterResponse(parsedOutput, context);
        case "InvalidHeadersForS3Origin":
        case "com.amazonaws.cloudfront#InvalidHeadersForS3Origin":
            throw await deserializeAws_restXmlInvalidHeadersForS3OriginResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "InvalidLambdaFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidLambdaFunctionAssociation":
            throw await deserializeAws_restXmlInvalidLambdaFunctionAssociationResponse(parsedOutput, context);
        case "InvalidLocationCode":
        case "com.amazonaws.cloudfront#InvalidLocationCode":
            throw await deserializeAws_restXmlInvalidLocationCodeResponse(parsedOutput, context);
        case "InvalidMinimumProtocolVersion":
        case "com.amazonaws.cloudfront#InvalidMinimumProtocolVersion":
            throw await deserializeAws_restXmlInvalidMinimumProtocolVersionResponse(parsedOutput, context);
        case "InvalidOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidOriginAccessControl":
            throw await deserializeAws_restXmlInvalidOriginAccessControlResponse(parsedOutput, context);
        case "InvalidOriginAccessIdentity":
        case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
            throw await deserializeAws_restXmlInvalidOriginAccessIdentityResponse(parsedOutput, context);
        case "InvalidOriginKeepaliveTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginKeepaliveTimeout":
            throw await deserializeAws_restXmlInvalidOriginKeepaliveTimeoutResponse(parsedOutput, context);
        case "InvalidOriginReadTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginReadTimeout":
            throw await deserializeAws_restXmlInvalidOriginReadTimeoutResponse(parsedOutput, context);
        case "InvalidQueryStringParameters":
        case "com.amazonaws.cloudfront#InvalidQueryStringParameters":
            throw await deserializeAws_restXmlInvalidQueryStringParametersResponse(parsedOutput, context);
        case "InvalidRelativePath":
        case "com.amazonaws.cloudfront#InvalidRelativePath":
            throw await deserializeAws_restXmlInvalidRelativePathResponse(parsedOutput, context);
        case "InvalidRequiredProtocol":
        case "com.amazonaws.cloudfront#InvalidRequiredProtocol":
            throw await deserializeAws_restXmlInvalidRequiredProtocolResponse(parsedOutput, context);
        case "InvalidResponseCode":
        case "com.amazonaws.cloudfront#InvalidResponseCode":
            throw await deserializeAws_restXmlInvalidResponseCodeResponse(parsedOutput, context);
        case "InvalidTTLOrder":
        case "com.amazonaws.cloudfront#InvalidTTLOrder":
            throw await deserializeAws_restXmlInvalidTTLOrderResponse(parsedOutput, context);
        case "InvalidViewerCertificate":
        case "com.amazonaws.cloudfront#InvalidViewerCertificate":
            throw await deserializeAws_restXmlInvalidViewerCertificateResponse(parsedOutput, context);
        case "InvalidWebACLId":
        case "com.amazonaws.cloudfront#InvalidWebACLId":
            throw await deserializeAws_restXmlInvalidWebACLIdResponse(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await deserializeAws_restXmlMissingBodyResponse(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await deserializeAws_restXmlNoSuchCachePolicyResponse(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await deserializeAws_restXmlNoSuchDistributionResponse(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await deserializeAws_restXmlNoSuchFieldLevelEncryptionConfigResponse(parsedOutput, context);
        case "NoSuchOrigin":
        case "com.amazonaws.cloudfront#NoSuchOrigin":
            throw await deserializeAws_restXmlNoSuchOriginResponse(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await deserializeAws_restXmlNoSuchOriginRequestPolicyResponse(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await deserializeAws_restXmlNoSuchRealtimeLogConfigResponse(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await deserializeAws_restXmlNoSuchResponseHeadersPolicyResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        case "RealtimeLogConfigOwnerMismatch":
        case "com.amazonaws.cloudfront#RealtimeLogConfigOwnerMismatch":
            throw await deserializeAws_restXmlRealtimeLogConfigOwnerMismatchResponse(parsedOutput, context);
        case "StagingDistributionInUse":
        case "com.amazonaws.cloudfront#StagingDistributionInUse":
            throw await deserializeAws_restXmlStagingDistributionInUseResponse(parsedOutput, context);
        case "TooManyCacheBehaviors":
        case "com.amazonaws.cloudfront#TooManyCacheBehaviors":
            throw await deserializeAws_restXmlTooManyCacheBehaviorsResponse(parsedOutput, context);
        case "TooManyCertificates":
        case "com.amazonaws.cloudfront#TooManyCertificates":
            throw await deserializeAws_restXmlTooManyCertificatesResponse(parsedOutput, context);
        case "TooManyCookieNamesInWhiteList":
        case "com.amazonaws.cloudfront#TooManyCookieNamesInWhiteList":
            throw await deserializeAws_restXmlTooManyCookieNamesInWhiteListResponse(parsedOutput, context);
        case "TooManyDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyDistributionCNAMEs":
            throw await deserializeAws_restXmlTooManyDistributionCNAMEsResponse(parsedOutput, context);
        case "TooManyDistributionsAssociatedToCachePolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToCachePolicy":
            throw await deserializeAws_restXmlTooManyDistributionsAssociatedToCachePolicyResponse(parsedOutput, context);
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
            throw await deserializeAws_restXmlTooManyDistributionsAssociatedToFieldLevelEncryptionConfigResponse(parsedOutput, context);
        case "TooManyDistributionsAssociatedToKeyGroup":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToKeyGroup":
            throw await deserializeAws_restXmlTooManyDistributionsAssociatedToKeyGroupResponse(parsedOutput, context);
        case "TooManyDistributionsAssociatedToOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToOriginRequestPolicy":
            throw await deserializeAws_restXmlTooManyDistributionsAssociatedToOriginRequestPolicyResponse(parsedOutput, context);
        case "TooManyDistributionsAssociatedToResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToResponseHeadersPolicy":
            throw await deserializeAws_restXmlTooManyDistributionsAssociatedToResponseHeadersPolicyResponse(parsedOutput, context);
        case "TooManyDistributionsWithFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithFunctionAssociations":
            throw await deserializeAws_restXmlTooManyDistributionsWithFunctionAssociationsResponse(parsedOutput, context);
        case "TooManyDistributionsWithLambdaAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithLambdaAssociations":
            throw await deserializeAws_restXmlTooManyDistributionsWithLambdaAssociationsResponse(parsedOutput, context);
        case "TooManyDistributionsWithSingleFunctionARN":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithSingleFunctionARN":
            throw await deserializeAws_restXmlTooManyDistributionsWithSingleFunctionARNResponse(parsedOutput, context);
        case "TooManyFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyFunctionAssociations":
            throw await deserializeAws_restXmlTooManyFunctionAssociationsResponse(parsedOutput, context);
        case "TooManyHeadersInForwardedValues":
        case "com.amazonaws.cloudfront#TooManyHeadersInForwardedValues":
            throw await deserializeAws_restXmlTooManyHeadersInForwardedValuesResponse(parsedOutput, context);
        case "TooManyKeyGroupsAssociatedToDistribution":
        case "com.amazonaws.cloudfront#TooManyKeyGroupsAssociatedToDistribution":
            throw await deserializeAws_restXmlTooManyKeyGroupsAssociatedToDistributionResponse(parsedOutput, context);
        case "TooManyLambdaFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyLambdaFunctionAssociations":
            throw await deserializeAws_restXmlTooManyLambdaFunctionAssociationsResponse(parsedOutput, context);
        case "TooManyOriginCustomHeaders":
        case "com.amazonaws.cloudfront#TooManyOriginCustomHeaders":
            throw await deserializeAws_restXmlTooManyOriginCustomHeadersResponse(parsedOutput, context);
        case "TooManyOriginGroupsPerDistribution":
        case "com.amazonaws.cloudfront#TooManyOriginGroupsPerDistribution":
            throw await deserializeAws_restXmlTooManyOriginGroupsPerDistributionResponse(parsedOutput, context);
        case "TooManyOrigins":
        case "com.amazonaws.cloudfront#TooManyOrigins":
            throw await deserializeAws_restXmlTooManyOriginsResponse(parsedOutput, context);
        case "TooManyQueryStringParameters":
        case "com.amazonaws.cloudfront#TooManyQueryStringParameters":
            throw await deserializeAws_restXmlTooManyQueryStringParametersResponse(parsedOutput, context);
        case "TooManyTrustedSigners":
        case "com.amazonaws.cloudfront#TooManyTrustedSigners":
            throw await deserializeAws_restXmlTooManyTrustedSignersResponse(parsedOutput, context);
        case "TrustedKeyGroupDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedKeyGroupDoesNotExist":
            throw await deserializeAws_restXmlTrustedKeyGroupDoesNotExistResponse(parsedOutput, context);
        case "TrustedSignerDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
            throw await deserializeAws_restXmlTrustedSignerDoesNotExistResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlUpdateFieldLevelEncryptionConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlUpdateFieldLevelEncryptionConfigCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryption = deserializeAws_restXmlFieldLevelEncryption(data, context);
    return contents;
};
exports.deserializeAws_restXmlUpdateFieldLevelEncryptionConfigCommand = deserializeAws_restXmlUpdateFieldLevelEncryptionConfigCommand;
const deserializeAws_restXmlUpdateFieldLevelEncryptionConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await deserializeAws_restXmlIllegalUpdateResponse(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await deserializeAws_restXmlNoSuchFieldLevelEncryptionConfigResponse(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionProfile":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
            throw await deserializeAws_restXmlNoSuchFieldLevelEncryptionProfileResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        case "QueryArgProfileEmpty":
        case "com.amazonaws.cloudfront#QueryArgProfileEmpty":
            throw await deserializeAws_restXmlQueryArgProfileEmptyResponse(parsedOutput, context);
        case "TooManyFieldLevelEncryptionContentTypeProfiles":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionContentTypeProfiles":
            throw await deserializeAws_restXmlTooManyFieldLevelEncryptionContentTypeProfilesResponse(parsedOutput, context);
        case "TooManyFieldLevelEncryptionQueryArgProfiles":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionQueryArgProfiles":
            throw await deserializeAws_restXmlTooManyFieldLevelEncryptionQueryArgProfilesResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlUpdateFieldLevelEncryptionProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlUpdateFieldLevelEncryptionProfileCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryptionProfile = deserializeAws_restXmlFieldLevelEncryptionProfile(data, context);
    return contents;
};
exports.deserializeAws_restXmlUpdateFieldLevelEncryptionProfileCommand = deserializeAws_restXmlUpdateFieldLevelEncryptionProfileCommand;
const deserializeAws_restXmlUpdateFieldLevelEncryptionProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "FieldLevelEncryptionProfileAlreadyExists":
        case "com.amazonaws.cloudfront#FieldLevelEncryptionProfileAlreadyExists":
            throw await deserializeAws_restXmlFieldLevelEncryptionProfileAlreadyExistsResponse(parsedOutput, context);
        case "FieldLevelEncryptionProfileSizeExceeded":
        case "com.amazonaws.cloudfront#FieldLevelEncryptionProfileSizeExceeded":
            throw await deserializeAws_restXmlFieldLevelEncryptionProfileSizeExceededResponse(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await deserializeAws_restXmlIllegalUpdateResponse(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionProfile":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
            throw await deserializeAws_restXmlNoSuchFieldLevelEncryptionProfileResponse(parsedOutput, context);
        case "NoSuchPublicKey":
        case "com.amazonaws.cloudfront#NoSuchPublicKey":
            throw await deserializeAws_restXmlNoSuchPublicKeyResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        case "TooManyFieldLevelEncryptionEncryptionEntities":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionEncryptionEntities":
            throw await deserializeAws_restXmlTooManyFieldLevelEncryptionEncryptionEntitiesResponse(parsedOutput, context);
        case "TooManyFieldLevelEncryptionFieldPatterns":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionFieldPatterns":
            throw await deserializeAws_restXmlTooManyFieldLevelEncryptionFieldPatternsResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlUpdateFunctionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlUpdateFunctionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["ettag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FunctionSummary = deserializeAws_restXmlFunctionSummary(data, context);
    return contents;
};
exports.deserializeAws_restXmlUpdateFunctionCommand = deserializeAws_restXmlUpdateFunctionCommand;
const deserializeAws_restXmlUpdateFunctionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "FunctionSizeLimitExceeded":
        case "com.amazonaws.cloudfront#FunctionSizeLimitExceeded":
            throw await deserializeAws_restXmlFunctionSizeLimitExceededResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "NoSuchFunctionExists":
        case "com.amazonaws.cloudfront#NoSuchFunctionExists":
            throw await deserializeAws_restXmlNoSuchFunctionExistsResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await deserializeAws_restXmlUnsupportedOperationResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlUpdateKeyGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlUpdateKeyGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.KeyGroup = deserializeAws_restXmlKeyGroup(data, context);
    return contents;
};
exports.deserializeAws_restXmlUpdateKeyGroupCommand = deserializeAws_restXmlUpdateKeyGroupCommand;
const deserializeAws_restXmlUpdateKeyGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "KeyGroupAlreadyExists":
        case "com.amazonaws.cloudfront#KeyGroupAlreadyExists":
            throw await deserializeAws_restXmlKeyGroupAlreadyExistsResponse(parsedOutput, context);
        case "NoSuchResource":
        case "com.amazonaws.cloudfront#NoSuchResource":
            throw await deserializeAws_restXmlNoSuchResourceResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        case "TooManyPublicKeysInKeyGroup":
        case "com.amazonaws.cloudfront#TooManyPublicKeysInKeyGroup":
            throw await deserializeAws_restXmlTooManyPublicKeysInKeyGroupResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlUpdateOriginAccessControlCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlUpdateOriginAccessControlCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginAccessControl = deserializeAws_restXmlOriginAccessControl(data, context);
    return contents;
};
exports.deserializeAws_restXmlUpdateOriginAccessControlCommand = deserializeAws_restXmlUpdateOriginAccessControlCommand;
const deserializeAws_restXmlUpdateOriginAccessControlCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await deserializeAws_restXmlIllegalUpdateResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "NoSuchOriginAccessControl":
        case "com.amazonaws.cloudfront#NoSuchOriginAccessControl":
            throw await deserializeAws_restXmlNoSuchOriginAccessControlResponse(parsedOutput, context);
        case "OriginAccessControlAlreadyExists":
        case "com.amazonaws.cloudfront#OriginAccessControlAlreadyExists":
            throw await deserializeAws_restXmlOriginAccessControlAlreadyExistsResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlUpdateOriginRequestPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlUpdateOriginRequestPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginRequestPolicy = deserializeAws_restXmlOriginRequestPolicy(data, context);
    return contents;
};
exports.deserializeAws_restXmlUpdateOriginRequestPolicyCommand = deserializeAws_restXmlUpdateOriginRequestPolicyCommand;
const deserializeAws_restXmlUpdateOriginRequestPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await deserializeAws_restXmlIllegalUpdateResponse(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await deserializeAws_restXmlNoSuchOriginRequestPolicyResponse(parsedOutput, context);
        case "OriginRequestPolicyAlreadyExists":
        case "com.amazonaws.cloudfront#OriginRequestPolicyAlreadyExists":
            throw await deserializeAws_restXmlOriginRequestPolicyAlreadyExistsResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        case "TooManyCookiesInOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyCookiesInOriginRequestPolicy":
            throw await deserializeAws_restXmlTooManyCookiesInOriginRequestPolicyResponse(parsedOutput, context);
        case "TooManyHeadersInOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyHeadersInOriginRequestPolicy":
            throw await deserializeAws_restXmlTooManyHeadersInOriginRequestPolicyResponse(parsedOutput, context);
        case "TooManyQueryStringsInOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyQueryStringsInOriginRequestPolicy":
            throw await deserializeAws_restXmlTooManyQueryStringsInOriginRequestPolicyResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlUpdatePublicKeyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlUpdatePublicKeyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.PublicKey = deserializeAws_restXmlPublicKey(data, context);
    return contents;
};
exports.deserializeAws_restXmlUpdatePublicKeyCommand = deserializeAws_restXmlUpdatePublicKeyCommand;
const deserializeAws_restXmlUpdatePublicKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "CannotChangeImmutablePublicKeyFields":
        case "com.amazonaws.cloudfront#CannotChangeImmutablePublicKeyFields":
            throw await deserializeAws_restXmlCannotChangeImmutablePublicKeyFieldsResponse(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await deserializeAws_restXmlIllegalUpdateResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "NoSuchPublicKey":
        case "com.amazonaws.cloudfront#NoSuchPublicKey":
            throw await deserializeAws_restXmlNoSuchPublicKeyResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlUpdateRealtimeLogConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlUpdateRealtimeLogConfigCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data["RealtimeLogConfig"] !== undefined) {
        contents.RealtimeLogConfig = deserializeAws_restXmlRealtimeLogConfig(data["RealtimeLogConfig"], context);
    }
    return contents;
};
exports.deserializeAws_restXmlUpdateRealtimeLogConfigCommand = deserializeAws_restXmlUpdateRealtimeLogConfigCommand;
const deserializeAws_restXmlUpdateRealtimeLogConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await deserializeAws_restXmlNoSuchRealtimeLogConfigResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlUpdateResponseHeadersPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlUpdateResponseHeadersPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ResponseHeadersPolicy = deserializeAws_restXmlResponseHeadersPolicy(data, context);
    return contents;
};
exports.deserializeAws_restXmlUpdateResponseHeadersPolicyCommand = deserializeAws_restXmlUpdateResponseHeadersPolicyCommand;
const deserializeAws_restXmlUpdateResponseHeadersPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await deserializeAws_restXmlIllegalUpdateResponse(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await deserializeAws_restXmlNoSuchResponseHeadersPolicyResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        case "ResponseHeadersPolicyAlreadyExists":
        case "com.amazonaws.cloudfront#ResponseHeadersPolicyAlreadyExists":
            throw await deserializeAws_restXmlResponseHeadersPolicyAlreadyExistsResponse(parsedOutput, context);
        case "TooLongCSPInResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooLongCSPInResponseHeadersPolicy":
            throw await deserializeAws_restXmlTooLongCSPInResponseHeadersPolicyResponse(parsedOutput, context);
        case "TooManyCustomHeadersInResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooManyCustomHeadersInResponseHeadersPolicy":
            throw await deserializeAws_restXmlTooManyCustomHeadersInResponseHeadersPolicyResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restXmlUpdateStreamingDistributionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restXmlUpdateStreamingDistributionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        ETag: [, output.headers["etag"]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.StreamingDistribution = deserializeAws_restXmlStreamingDistribution(data, context);
    return contents;
};
exports.deserializeAws_restXmlUpdateStreamingDistributionCommand = deserializeAws_restXmlUpdateStreamingDistributionCommand;
const deserializeAws_restXmlUpdateStreamingDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context);
        case "CNAMEAlreadyExists":
        case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
            throw await deserializeAws_restXmlCNAMEAlreadyExistsResponse(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await deserializeAws_restXmlIllegalUpdateResponse(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context);
        case "InvalidOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidOriginAccessControl":
            throw await deserializeAws_restXmlInvalidOriginAccessControlResponse(parsedOutput, context);
        case "InvalidOriginAccessIdentity":
        case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
            throw await deserializeAws_restXmlInvalidOriginAccessIdentityResponse(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await deserializeAws_restXmlMissingBodyResponse(parsedOutput, context);
        case "NoSuchStreamingDistribution":
        case "com.amazonaws.cloudfront#NoSuchStreamingDistribution":
            throw await deserializeAws_restXmlNoSuchStreamingDistributionResponse(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context);
        case "TooManyStreamingDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyStreamingDistributionCNAMEs":
            throw await deserializeAws_restXmlTooManyStreamingDistributionCNAMEsResponse(parsedOutput, context);
        case "TooManyTrustedSigners":
        case "com.amazonaws.cloudfront#TooManyTrustedSigners":
            throw await deserializeAws_restXmlTooManyTrustedSignersResponse(parsedOutput, context);
        case "TrustedSignerDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
            throw await deserializeAws_restXmlTrustedSignerDoesNotExistResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: CloudFrontServiceException_1.CloudFrontServiceException,
                errorCode,
            });
    }
};
const map = smithy_client_1.map;
const deserializeAws_restXmlAccessDeniedResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.AccessDenied({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlBatchTooLargeResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.BatchTooLarge({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlCachePolicyAlreadyExistsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.CachePolicyAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlCachePolicyInUseResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.CachePolicyInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlCannotChangeImmutablePublicKeyFieldsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.CannotChangeImmutablePublicKeyFields({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlCloudFrontOriginAccessIdentityAlreadyExistsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.CloudFrontOriginAccessIdentityAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlCloudFrontOriginAccessIdentityInUseResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_1_1.CloudFrontOriginAccessIdentityInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlCNAMEAlreadyExistsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.CNAMEAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlDistributionAlreadyExistsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.DistributionAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlDistributionNotDisabledResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_1_1.DistributionNotDisabled({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlFieldLevelEncryptionConfigAlreadyExistsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.FieldLevelEncryptionConfigAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlFieldLevelEncryptionConfigInUseResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_1_1.FieldLevelEncryptionConfigInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlFieldLevelEncryptionProfileAlreadyExistsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.FieldLevelEncryptionProfileAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlFieldLevelEncryptionProfileInUseResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_1_1.FieldLevelEncryptionProfileInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlFieldLevelEncryptionProfileSizeExceededResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.FieldLevelEncryptionProfileSizeExceeded({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlFunctionAlreadyExistsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.FunctionAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlFunctionInUseResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_1_1.FunctionInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlFunctionSizeLimitExceededResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.FunctionSizeLimitExceeded({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlIllegalDeleteResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_1_1.IllegalDelete({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlIllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlIllegalOriginAccessConfigurationResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.IllegalOriginAccessConfiguration({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlIllegalUpdateResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.IllegalUpdate({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInconsistentQuantitiesResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InconsistentQuantities({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidArgumentResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidArgument({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidDefaultRootObjectResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidDefaultRootObject({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidDomainNameForOriginAccessControlResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidDomainNameForOriginAccessControl({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidErrorCodeResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidErrorCode({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidForwardCookiesResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidForwardCookies({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidFunctionAssociationResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidFunctionAssociation({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidGeoRestrictionParameterResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidGeoRestrictionParameter({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidHeadersForS3OriginResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidHeadersForS3Origin({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidIfMatchVersionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidIfMatchVersion({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidLambdaFunctionAssociationResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidLambdaFunctionAssociation({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidLocationCodeResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidLocationCode({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidMinimumProtocolVersionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidMinimumProtocolVersion({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidOriginResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidOrigin({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidOriginAccessControlResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidOriginAccessControl({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidOriginAccessIdentityResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidOriginAccessIdentity({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidOriginKeepaliveTimeoutResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidOriginKeepaliveTimeout({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidOriginReadTimeoutResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidOriginReadTimeout({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidProtocolSettingsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidProtocolSettings({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidQueryStringParametersResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidQueryStringParameters({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidRelativePathResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidRelativePath({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidRequiredProtocolResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidRequiredProtocol({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidResponseCodeResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidResponseCode({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidTaggingResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidTagging({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidTTLOrderResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidTTLOrder({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidViewerCertificateResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidViewerCertificate({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlInvalidWebACLIdResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.InvalidWebACLId({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlKeyGroupAlreadyExistsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.KeyGroupAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlMissingBodyResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.MissingBody({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlMonitoringSubscriptionAlreadyExistsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.MonitoringSubscriptionAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlNoSuchCachePolicyResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.NoSuchCachePolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlNoSuchCloudFrontOriginAccessIdentityResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_1_1.NoSuchCloudFrontOriginAccessIdentity({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlNoSuchDistributionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.NoSuchDistribution({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlNoSuchFieldLevelEncryptionConfigResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.NoSuchFieldLevelEncryptionConfig({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlNoSuchFieldLevelEncryptionProfileResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.NoSuchFieldLevelEncryptionProfile({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlNoSuchFunctionExistsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_1_1.NoSuchFunctionExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlNoSuchInvalidationResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_1_1.NoSuchInvalidation({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlNoSuchMonitoringSubscriptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_1_1.NoSuchMonitoringSubscription({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlNoSuchOriginResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.NoSuchOrigin({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlNoSuchOriginAccessControlResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_1_1.NoSuchOriginAccessControl({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlNoSuchOriginRequestPolicyResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.NoSuchOriginRequestPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlNoSuchPublicKeyResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.NoSuchPublicKey({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlNoSuchRealtimeLogConfigResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.NoSuchRealtimeLogConfig({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlNoSuchResourceResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_1_1.NoSuchResource({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlNoSuchResponseHeadersPolicyResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.NoSuchResponseHeadersPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlNoSuchStreamingDistributionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_1_1.NoSuchStreamingDistribution({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlOriginAccessControlAlreadyExistsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.OriginAccessControlAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlOriginAccessControlInUseResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_1_1.OriginAccessControlInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlOriginRequestPolicyAlreadyExistsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.OriginRequestPolicyAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlOriginRequestPolicyInUseResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_1_1.OriginRequestPolicyInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlPreconditionFailedResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.PreconditionFailed({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlPublicKeyAlreadyExistsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.PublicKeyAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlPublicKeyInUseResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_1_1.PublicKeyInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlQueryArgProfileEmptyResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.QueryArgProfileEmpty({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlRealtimeLogConfigAlreadyExistsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.RealtimeLogConfigAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlRealtimeLogConfigInUseResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_1_1.RealtimeLogConfigInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlRealtimeLogConfigOwnerMismatchResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.RealtimeLogConfigOwnerMismatch({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlResourceInUseResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_1_1.ResourceInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlResponseHeadersPolicyAlreadyExistsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.ResponseHeadersPolicyAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlResponseHeadersPolicyInUseResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_1_1.ResponseHeadersPolicyInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlStagingDistributionInUseResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.StagingDistributionInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlStreamingDistributionAlreadyExistsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_1_1.StreamingDistributionAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlStreamingDistributionNotDisabledResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_1_1.StreamingDistributionNotDisabled({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTestFunctionFailedResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_1_1.TestFunctionFailed({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooLongCSPInResponseHeadersPolicyResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooLongCSPInResponseHeadersPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyCacheBehaviorsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyCacheBehaviors({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyCachePoliciesResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyCachePolicies({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyCertificatesResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyCertificates({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyCloudFrontOriginAccessIdentitiesResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyCloudFrontOriginAccessIdentities({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyCookieNamesInWhiteListResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyCookieNamesInWhiteList({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyCookiesInCachePolicyResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyCookiesInCachePolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyCookiesInOriginRequestPolicyResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyCookiesInOriginRequestPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyCustomHeadersInResponseHeadersPolicyResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyCustomHeadersInResponseHeadersPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyDistributionCNAMEsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyDistributionCNAMEs({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyDistributionsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyDistributions({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyDistributionsAssociatedToCachePolicyResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyDistributionsAssociatedToCachePolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyDistributionsAssociatedToFieldLevelEncryptionConfigResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyDistributionsAssociatedToFieldLevelEncryptionConfig({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyDistributionsAssociatedToKeyGroupResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyDistributionsAssociatedToKeyGroup({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyDistributionsAssociatedToOriginAccessControlResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyDistributionsAssociatedToOriginAccessControl({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyDistributionsAssociatedToOriginRequestPolicyResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyDistributionsAssociatedToOriginRequestPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyDistributionsAssociatedToResponseHeadersPolicyResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyDistributionsAssociatedToResponseHeadersPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyDistributionsWithFunctionAssociationsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyDistributionsWithFunctionAssociations({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyDistributionsWithLambdaAssociationsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyDistributionsWithLambdaAssociations({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyDistributionsWithSingleFunctionARNResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyDistributionsWithSingleFunctionARN({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyFieldLevelEncryptionConfigsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyFieldLevelEncryptionConfigs({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyFieldLevelEncryptionContentTypeProfilesResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyFieldLevelEncryptionContentTypeProfiles({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyFieldLevelEncryptionEncryptionEntitiesResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyFieldLevelEncryptionEncryptionEntities({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyFieldLevelEncryptionFieldPatternsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyFieldLevelEncryptionFieldPatterns({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyFieldLevelEncryptionProfilesResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyFieldLevelEncryptionProfiles({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyFieldLevelEncryptionQueryArgProfilesResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyFieldLevelEncryptionQueryArgProfiles({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyFunctionAssociationsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyFunctionAssociations({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyFunctionsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyFunctions({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyHeadersInCachePolicyResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyHeadersInCachePolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyHeadersInForwardedValuesResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyHeadersInForwardedValues({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyHeadersInOriginRequestPolicyResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyHeadersInOriginRequestPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyInvalidationsInProgressResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyInvalidationsInProgress({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyKeyGroupsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyKeyGroups({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyKeyGroupsAssociatedToDistributionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyKeyGroupsAssociatedToDistribution({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyLambdaFunctionAssociationsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyLambdaFunctionAssociations({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyOriginAccessControlsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyOriginAccessControls({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyOriginCustomHeadersResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyOriginCustomHeaders({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyOriginGroupsPerDistributionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyOriginGroupsPerDistribution({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyOriginRequestPoliciesResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyOriginRequestPolicies({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyOriginsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyOrigins({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyPublicKeysResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyPublicKeys({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyPublicKeysInKeyGroupResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyPublicKeysInKeyGroup({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyQueryStringParametersResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyQueryStringParameters({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyQueryStringsInCachePolicyResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyQueryStringsInCachePolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyQueryStringsInOriginRequestPolicyResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyQueryStringsInOriginRequestPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyRealtimeLogConfigsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyRealtimeLogConfigs({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyResponseHeadersPoliciesResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyResponseHeadersPolicies({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyStreamingDistributionCNAMEsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_1_1.TooManyStreamingDistributionCNAMEs({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyStreamingDistributionsResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_1_1.TooManyStreamingDistributions({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTooManyTrustedSignersResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TooManyTrustedSigners({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTrustedKeyGroupDoesNotExistResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TrustedKeyGroupDoesNotExist({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlTrustedSignerDoesNotExistResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.TrustedSignerDoesNotExist({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const deserializeAws_restXmlUnsupportedOperationResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(data["Message"]);
    }
    const exception = new models_0_1.UnsupportedOperation({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const serializeAws_restXmlAccessControlAllowHeadersList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = xml_builder_1.XmlNode.of("string", entry);
        return node.withName("Header");
    });
};
const serializeAws_restXmlAccessControlAllowMethodsList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = xml_builder_1.XmlNode.of("ResponseHeadersPolicyAccessControlAllowMethodsValues", entry);
        return node.withName("Method");
    });
};
const serializeAws_restXmlAccessControlAllowOriginsList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = xml_builder_1.XmlNode.of("string", entry);
        return node.withName("Origin");
    });
};
const serializeAws_restXmlAccessControlExposeHeadersList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = xml_builder_1.XmlNode.of("string", entry);
        return node.withName("Header");
    });
};
const serializeAws_restXmlAliases = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("Aliases");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlAliasList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlAliasList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = xml_builder_1.XmlNode.of("string", entry);
        return node.withName("CNAME");
    });
};
const serializeAws_restXmlAllowedMethods = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("AllowedMethods");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlMethodsList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.CachedMethods != null) {
        const node = serializeAws_restXmlCachedMethods(input.CachedMethods, context).withName("CachedMethods");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlAwsAccountNumberList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = xml_builder_1.XmlNode.of("string", entry);
        return node.withName("AwsAccountNumber");
    });
};
const serializeAws_restXmlCacheBehavior = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("CacheBehavior");
    if (input.PathPattern != null) {
        const node = xml_builder_1.XmlNode.of("string", input.PathPattern).withName("PathPattern");
        bodyNode.addChildNode(node);
    }
    if (input.TargetOriginId != null) {
        const node = xml_builder_1.XmlNode.of("string", input.TargetOriginId).withName("TargetOriginId");
        bodyNode.addChildNode(node);
    }
    if (input.TrustedSigners != null) {
        const node = serializeAws_restXmlTrustedSigners(input.TrustedSigners, context).withName("TrustedSigners");
        bodyNode.addChildNode(node);
    }
    if (input.TrustedKeyGroups != null) {
        const node = serializeAws_restXmlTrustedKeyGroups(input.TrustedKeyGroups, context).withName("TrustedKeyGroups");
        bodyNode.addChildNode(node);
    }
    if (input.ViewerProtocolPolicy != null) {
        const node = xml_builder_1.XmlNode.of("ViewerProtocolPolicy", input.ViewerProtocolPolicy).withName("ViewerProtocolPolicy");
        bodyNode.addChildNode(node);
    }
    if (input.AllowedMethods != null) {
        const node = serializeAws_restXmlAllowedMethods(input.AllowedMethods, context).withName("AllowedMethods");
        bodyNode.addChildNode(node);
    }
    if (input.SmoothStreaming != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.SmoothStreaming)).withName("SmoothStreaming");
        bodyNode.addChildNode(node);
    }
    if (input.Compress != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.Compress)).withName("Compress");
        bodyNode.addChildNode(node);
    }
    if (input.LambdaFunctionAssociations != null) {
        const node = serializeAws_restXmlLambdaFunctionAssociations(input.LambdaFunctionAssociations, context).withName("LambdaFunctionAssociations");
        bodyNode.addChildNode(node);
    }
    if (input.FunctionAssociations != null) {
        const node = serializeAws_restXmlFunctionAssociations(input.FunctionAssociations, context).withName("FunctionAssociations");
        bodyNode.addChildNode(node);
    }
    if (input.FieldLevelEncryptionId != null) {
        const node = xml_builder_1.XmlNode.of("string", input.FieldLevelEncryptionId).withName("FieldLevelEncryptionId");
        bodyNode.addChildNode(node);
    }
    if (input.RealtimeLogConfigArn != null) {
        const node = xml_builder_1.XmlNode.of("string", input.RealtimeLogConfigArn).withName("RealtimeLogConfigArn");
        bodyNode.addChildNode(node);
    }
    if (input.CachePolicyId != null) {
        const node = xml_builder_1.XmlNode.of("string", input.CachePolicyId).withName("CachePolicyId");
        bodyNode.addChildNode(node);
    }
    if (input.OriginRequestPolicyId != null) {
        const node = xml_builder_1.XmlNode.of("string", input.OriginRequestPolicyId).withName("OriginRequestPolicyId");
        bodyNode.addChildNode(node);
    }
    if (input.ResponseHeadersPolicyId != null) {
        const node = xml_builder_1.XmlNode.of("string", input.ResponseHeadersPolicyId).withName("ResponseHeadersPolicyId");
        bodyNode.addChildNode(node);
    }
    if (input.ForwardedValues != null) {
        const node = serializeAws_restXmlForwardedValues(input.ForwardedValues, context).withName("ForwardedValues");
        bodyNode.addChildNode(node);
    }
    if (input.MinTTL != null) {
        const node = xml_builder_1.XmlNode.of("long", String(input.MinTTL)).withName("MinTTL");
        bodyNode.addChildNode(node);
    }
    if (input.DefaultTTL != null) {
        const node = xml_builder_1.XmlNode.of("long", String(input.DefaultTTL)).withName("DefaultTTL");
        bodyNode.addChildNode(node);
    }
    if (input.MaxTTL != null) {
        const node = xml_builder_1.XmlNode.of("long", String(input.MaxTTL)).withName("MaxTTL");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlCacheBehaviorList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = serializeAws_restXmlCacheBehavior(entry, context);
        return node.withName("CacheBehavior");
    });
};
const serializeAws_restXmlCacheBehaviors = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("CacheBehaviors");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlCacheBehaviorList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlCachedMethods = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("CachedMethods");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlMethodsList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlCachePolicyConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("CachePolicyConfig");
    if (input.Comment != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Comment).withName("Comment");
        bodyNode.addChildNode(node);
    }
    if (input.Name != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Name).withName("Name");
        bodyNode.addChildNode(node);
    }
    if (input.DefaultTTL != null) {
        const node = xml_builder_1.XmlNode.of("long", String(input.DefaultTTL)).withName("DefaultTTL");
        bodyNode.addChildNode(node);
    }
    if (input.MaxTTL != null) {
        const node = xml_builder_1.XmlNode.of("long", String(input.MaxTTL)).withName("MaxTTL");
        bodyNode.addChildNode(node);
    }
    if (input.MinTTL != null) {
        const node = xml_builder_1.XmlNode.of("long", String(input.MinTTL)).withName("MinTTL");
        bodyNode.addChildNode(node);
    }
    if (input.ParametersInCacheKeyAndForwardedToOrigin != null) {
        const node = serializeAws_restXmlParametersInCacheKeyAndForwardedToOrigin(input.ParametersInCacheKeyAndForwardedToOrigin, context).withName("ParametersInCacheKeyAndForwardedToOrigin");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlCachePolicyCookiesConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("CachePolicyCookiesConfig");
    if (input.CookieBehavior != null) {
        const node = xml_builder_1.XmlNode.of("CachePolicyCookieBehavior", input.CookieBehavior).withName("CookieBehavior");
        bodyNode.addChildNode(node);
    }
    if (input.Cookies != null) {
        const node = serializeAws_restXmlCookieNames(input.Cookies, context).withName("Cookies");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlCachePolicyHeadersConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("CachePolicyHeadersConfig");
    if (input.HeaderBehavior != null) {
        const node = xml_builder_1.XmlNode.of("CachePolicyHeaderBehavior", input.HeaderBehavior).withName("HeaderBehavior");
        bodyNode.addChildNode(node);
    }
    if (input.Headers != null) {
        const node = serializeAws_restXmlHeaders(input.Headers, context).withName("Headers");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlCachePolicyQueryStringsConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("CachePolicyQueryStringsConfig");
    if (input.QueryStringBehavior != null) {
        const node = xml_builder_1.XmlNode
            .of("CachePolicyQueryStringBehavior", input.QueryStringBehavior)
            .withName("QueryStringBehavior");
        bodyNode.addChildNode(node);
    }
    if (input.QueryStrings != null) {
        const node = serializeAws_restXmlQueryStringNames(input.QueryStrings, context).withName("QueryStrings");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlCloudFrontOriginAccessIdentityConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("CloudFrontOriginAccessIdentityConfig");
    if (input.CallerReference != null) {
        const node = xml_builder_1.XmlNode.of("string", input.CallerReference).withName("CallerReference");
        bodyNode.addChildNode(node);
    }
    if (input.Comment != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Comment).withName("Comment");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlContentTypeProfile = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ContentTypeProfile");
    if (input.Format != null) {
        const node = xml_builder_1.XmlNode.of("Format", input.Format).withName("Format");
        bodyNode.addChildNode(node);
    }
    if (input.ProfileId != null) {
        const node = xml_builder_1.XmlNode.of("string", input.ProfileId).withName("ProfileId");
        bodyNode.addChildNode(node);
    }
    if (input.ContentType != null) {
        const node = xml_builder_1.XmlNode.of("string", input.ContentType).withName("ContentType");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlContentTypeProfileConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ContentTypeProfileConfig");
    if (input.ForwardWhenContentTypeIsUnknown != null) {
        const node = xml_builder_1.XmlNode
            .of("boolean", String(input.ForwardWhenContentTypeIsUnknown))
            .withName("ForwardWhenContentTypeIsUnknown");
        bodyNode.addChildNode(node);
    }
    if (input.ContentTypeProfiles != null) {
        const node = serializeAws_restXmlContentTypeProfiles(input.ContentTypeProfiles, context).withName("ContentTypeProfiles");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlContentTypeProfileList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = serializeAws_restXmlContentTypeProfile(entry, context);
        return node.withName("ContentTypeProfile");
    });
};
const serializeAws_restXmlContentTypeProfiles = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ContentTypeProfiles");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlContentTypeProfileList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlContinuousDeploymentPolicyConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ContinuousDeploymentPolicyConfig");
    if (input.StagingDistributionDnsNames != null) {
        const node = serializeAws_restXmlStagingDistributionDnsNames(input.StagingDistributionDnsNames, context).withName("StagingDistributionDnsNames");
        bodyNode.addChildNode(node);
    }
    if (input.Enabled != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.Enabled)).withName("Enabled");
        bodyNode.addChildNode(node);
    }
    if (input.TrafficConfig != null) {
        const node = serializeAws_restXmlTrafficConfig(input.TrafficConfig, context).withName("TrafficConfig");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlContinuousDeploymentSingleHeaderConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ContinuousDeploymentSingleHeaderConfig");
    if (input.Header != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Header).withName("Header");
        bodyNode.addChildNode(node);
    }
    if (input.Value != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Value).withName("Value");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlContinuousDeploymentSingleWeightConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ContinuousDeploymentSingleWeightConfig");
    if (input.Weight != null) {
        const node = xml_builder_1.XmlNode.of("float", String(input.Weight)).withName("Weight");
        bodyNode.addChildNode(node);
    }
    if (input.SessionStickinessConfig != null) {
        const node = serializeAws_restXmlSessionStickinessConfig(input.SessionStickinessConfig, context).withName("SessionStickinessConfig");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlCookieNameList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = xml_builder_1.XmlNode.of("string", entry);
        return node.withName("Name");
    });
};
const serializeAws_restXmlCookieNames = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("CookieNames");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlCookieNameList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlCookiePreference = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("CookiePreference");
    if (input.Forward != null) {
        const node = xml_builder_1.XmlNode.of("ItemSelection", input.Forward).withName("Forward");
        bodyNode.addChildNode(node);
    }
    if (input.WhitelistedNames != null) {
        const node = serializeAws_restXmlCookieNames(input.WhitelistedNames, context).withName("WhitelistedNames");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlCustomErrorResponse = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("CustomErrorResponse");
    if (input.ErrorCode != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.ErrorCode)).withName("ErrorCode");
        bodyNode.addChildNode(node);
    }
    if (input.ResponsePagePath != null) {
        const node = xml_builder_1.XmlNode.of("string", input.ResponsePagePath).withName("ResponsePagePath");
        bodyNode.addChildNode(node);
    }
    if (input.ResponseCode != null) {
        const node = xml_builder_1.XmlNode.of("string", input.ResponseCode).withName("ResponseCode");
        bodyNode.addChildNode(node);
    }
    if (input.ErrorCachingMinTTL != null) {
        const node = xml_builder_1.XmlNode.of("long", String(input.ErrorCachingMinTTL)).withName("ErrorCachingMinTTL");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlCustomErrorResponseList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = serializeAws_restXmlCustomErrorResponse(entry, context);
        return node.withName("CustomErrorResponse");
    });
};
const serializeAws_restXmlCustomErrorResponses = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("CustomErrorResponses");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlCustomErrorResponseList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlCustomHeaders = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("CustomHeaders");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlOriginCustomHeadersList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlCustomOriginConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("CustomOriginConfig");
    if (input.HTTPPort != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.HTTPPort)).withName("HTTPPort");
        bodyNode.addChildNode(node);
    }
    if (input.HTTPSPort != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.HTTPSPort)).withName("HTTPSPort");
        bodyNode.addChildNode(node);
    }
    if (input.OriginProtocolPolicy != null) {
        const node = xml_builder_1.XmlNode.of("OriginProtocolPolicy", input.OriginProtocolPolicy).withName("OriginProtocolPolicy");
        bodyNode.addChildNode(node);
    }
    if (input.OriginSslProtocols != null) {
        const node = serializeAws_restXmlOriginSslProtocols(input.OriginSslProtocols, context).withName("OriginSslProtocols");
        bodyNode.addChildNode(node);
    }
    if (input.OriginReadTimeout != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.OriginReadTimeout)).withName("OriginReadTimeout");
        bodyNode.addChildNode(node);
    }
    if (input.OriginKeepaliveTimeout != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.OriginKeepaliveTimeout)).withName("OriginKeepaliveTimeout");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlDefaultCacheBehavior = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("DefaultCacheBehavior");
    if (input.TargetOriginId != null) {
        const node = xml_builder_1.XmlNode.of("string", input.TargetOriginId).withName("TargetOriginId");
        bodyNode.addChildNode(node);
    }
    if (input.TrustedSigners != null) {
        const node = serializeAws_restXmlTrustedSigners(input.TrustedSigners, context).withName("TrustedSigners");
        bodyNode.addChildNode(node);
    }
    if (input.TrustedKeyGroups != null) {
        const node = serializeAws_restXmlTrustedKeyGroups(input.TrustedKeyGroups, context).withName("TrustedKeyGroups");
        bodyNode.addChildNode(node);
    }
    if (input.ViewerProtocolPolicy != null) {
        const node = xml_builder_1.XmlNode.of("ViewerProtocolPolicy", input.ViewerProtocolPolicy).withName("ViewerProtocolPolicy");
        bodyNode.addChildNode(node);
    }
    if (input.AllowedMethods != null) {
        const node = serializeAws_restXmlAllowedMethods(input.AllowedMethods, context).withName("AllowedMethods");
        bodyNode.addChildNode(node);
    }
    if (input.SmoothStreaming != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.SmoothStreaming)).withName("SmoothStreaming");
        bodyNode.addChildNode(node);
    }
    if (input.Compress != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.Compress)).withName("Compress");
        bodyNode.addChildNode(node);
    }
    if (input.LambdaFunctionAssociations != null) {
        const node = serializeAws_restXmlLambdaFunctionAssociations(input.LambdaFunctionAssociations, context).withName("LambdaFunctionAssociations");
        bodyNode.addChildNode(node);
    }
    if (input.FunctionAssociations != null) {
        const node = serializeAws_restXmlFunctionAssociations(input.FunctionAssociations, context).withName("FunctionAssociations");
        bodyNode.addChildNode(node);
    }
    if (input.FieldLevelEncryptionId != null) {
        const node = xml_builder_1.XmlNode.of("string", input.FieldLevelEncryptionId).withName("FieldLevelEncryptionId");
        bodyNode.addChildNode(node);
    }
    if (input.RealtimeLogConfigArn != null) {
        const node = xml_builder_1.XmlNode.of("string", input.RealtimeLogConfigArn).withName("RealtimeLogConfigArn");
        bodyNode.addChildNode(node);
    }
    if (input.CachePolicyId != null) {
        const node = xml_builder_1.XmlNode.of("string", input.CachePolicyId).withName("CachePolicyId");
        bodyNode.addChildNode(node);
    }
    if (input.OriginRequestPolicyId != null) {
        const node = xml_builder_1.XmlNode.of("string", input.OriginRequestPolicyId).withName("OriginRequestPolicyId");
        bodyNode.addChildNode(node);
    }
    if (input.ResponseHeadersPolicyId != null) {
        const node = xml_builder_1.XmlNode.of("string", input.ResponseHeadersPolicyId).withName("ResponseHeadersPolicyId");
        bodyNode.addChildNode(node);
    }
    if (input.ForwardedValues != null) {
        const node = serializeAws_restXmlForwardedValues(input.ForwardedValues, context).withName("ForwardedValues");
        bodyNode.addChildNode(node);
    }
    if (input.MinTTL != null) {
        const node = xml_builder_1.XmlNode.of("long", String(input.MinTTL)).withName("MinTTL");
        bodyNode.addChildNode(node);
    }
    if (input.DefaultTTL != null) {
        const node = xml_builder_1.XmlNode.of("long", String(input.DefaultTTL)).withName("DefaultTTL");
        bodyNode.addChildNode(node);
    }
    if (input.MaxTTL != null) {
        const node = xml_builder_1.XmlNode.of("long", String(input.MaxTTL)).withName("MaxTTL");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlDistributionConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("DistributionConfig");
    if (input.CallerReference != null) {
        const node = xml_builder_1.XmlNode.of("string", input.CallerReference).withName("CallerReference");
        bodyNode.addChildNode(node);
    }
    if (input.Aliases != null) {
        const node = serializeAws_restXmlAliases(input.Aliases, context).withName("Aliases");
        bodyNode.addChildNode(node);
    }
    if (input.DefaultRootObject != null) {
        const node = xml_builder_1.XmlNode.of("string", input.DefaultRootObject).withName("DefaultRootObject");
        bodyNode.addChildNode(node);
    }
    if (input.Origins != null) {
        const node = serializeAws_restXmlOrigins(input.Origins, context).withName("Origins");
        bodyNode.addChildNode(node);
    }
    if (input.OriginGroups != null) {
        const node = serializeAws_restXmlOriginGroups(input.OriginGroups, context).withName("OriginGroups");
        bodyNode.addChildNode(node);
    }
    if (input.DefaultCacheBehavior != null) {
        const node = serializeAws_restXmlDefaultCacheBehavior(input.DefaultCacheBehavior, context).withName("DefaultCacheBehavior");
        bodyNode.addChildNode(node);
    }
    if (input.CacheBehaviors != null) {
        const node = serializeAws_restXmlCacheBehaviors(input.CacheBehaviors, context).withName("CacheBehaviors");
        bodyNode.addChildNode(node);
    }
    if (input.CustomErrorResponses != null) {
        const node = serializeAws_restXmlCustomErrorResponses(input.CustomErrorResponses, context).withName("CustomErrorResponses");
        bodyNode.addChildNode(node);
    }
    if (input.Comment != null) {
        const node = xml_builder_1.XmlNode.of("CommentType", input.Comment).withName("Comment");
        bodyNode.addChildNode(node);
    }
    if (input.Logging != null) {
        const node = serializeAws_restXmlLoggingConfig(input.Logging, context).withName("Logging");
        bodyNode.addChildNode(node);
    }
    if (input.PriceClass != null) {
        const node = xml_builder_1.XmlNode.of("PriceClass", input.PriceClass).withName("PriceClass");
        bodyNode.addChildNode(node);
    }
    if (input.Enabled != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.Enabled)).withName("Enabled");
        bodyNode.addChildNode(node);
    }
    if (input.ViewerCertificate != null) {
        const node = serializeAws_restXmlViewerCertificate(input.ViewerCertificate, context).withName("ViewerCertificate");
        bodyNode.addChildNode(node);
    }
    if (input.Restrictions != null) {
        const node = serializeAws_restXmlRestrictions(input.Restrictions, context).withName("Restrictions");
        bodyNode.addChildNode(node);
    }
    if (input.WebACLId != null) {
        const node = xml_builder_1.XmlNode.of("string", input.WebACLId).withName("WebACLId");
        bodyNode.addChildNode(node);
    }
    if (input.HttpVersion != null) {
        const node = xml_builder_1.XmlNode.of("HttpVersion", input.HttpVersion).withName("HttpVersion");
        bodyNode.addChildNode(node);
    }
    if (input.IsIPV6Enabled != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.IsIPV6Enabled)).withName("IsIPV6Enabled");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlDistributionConfigWithTags = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("DistributionConfigWithTags");
    if (input.DistributionConfig != null) {
        const node = serializeAws_restXmlDistributionConfig(input.DistributionConfig, context).withName("DistributionConfig");
        bodyNode.addChildNode(node);
    }
    if (input.Tags != null) {
        const node = serializeAws_restXmlTags(input.Tags, context).withName("Tags");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlEncryptionEntities = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("EncryptionEntities");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlEncryptionEntityList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlEncryptionEntity = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("EncryptionEntity");
    if (input.PublicKeyId != null) {
        const node = xml_builder_1.XmlNode.of("string", input.PublicKeyId).withName("PublicKeyId");
        bodyNode.addChildNode(node);
    }
    if (input.ProviderId != null) {
        const node = xml_builder_1.XmlNode.of("string", input.ProviderId).withName("ProviderId");
        bodyNode.addChildNode(node);
    }
    if (input.FieldPatterns != null) {
        const node = serializeAws_restXmlFieldPatterns(input.FieldPatterns, context).withName("FieldPatterns");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlEncryptionEntityList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = serializeAws_restXmlEncryptionEntity(entry, context);
        return node.withName("EncryptionEntity");
    });
};
const serializeAws_restXmlEndPoint = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("EndPoint");
    if (input.StreamType != null) {
        const node = xml_builder_1.XmlNode.of("string", input.StreamType).withName("StreamType");
        bodyNode.addChildNode(node);
    }
    if (input.KinesisStreamConfig != null) {
        const node = serializeAws_restXmlKinesisStreamConfig(input.KinesisStreamConfig, context).withName("KinesisStreamConfig");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlEndPointList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = serializeAws_restXmlEndPoint(entry, context);
        return node.withName("member");
    });
};
const serializeAws_restXmlFieldLevelEncryptionConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("FieldLevelEncryptionConfig");
    if (input.CallerReference != null) {
        const node = xml_builder_1.XmlNode.of("string", input.CallerReference).withName("CallerReference");
        bodyNode.addChildNode(node);
    }
    if (input.Comment != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Comment).withName("Comment");
        bodyNode.addChildNode(node);
    }
    if (input.QueryArgProfileConfig != null) {
        const node = serializeAws_restXmlQueryArgProfileConfig(input.QueryArgProfileConfig, context).withName("QueryArgProfileConfig");
        bodyNode.addChildNode(node);
    }
    if (input.ContentTypeProfileConfig != null) {
        const node = serializeAws_restXmlContentTypeProfileConfig(input.ContentTypeProfileConfig, context).withName("ContentTypeProfileConfig");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlFieldLevelEncryptionProfileConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("FieldLevelEncryptionProfileConfig");
    if (input.Name != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Name).withName("Name");
        bodyNode.addChildNode(node);
    }
    if (input.CallerReference != null) {
        const node = xml_builder_1.XmlNode.of("string", input.CallerReference).withName("CallerReference");
        bodyNode.addChildNode(node);
    }
    if (input.Comment != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Comment).withName("Comment");
        bodyNode.addChildNode(node);
    }
    if (input.EncryptionEntities != null) {
        const node = serializeAws_restXmlEncryptionEntities(input.EncryptionEntities, context).withName("EncryptionEntities");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlFieldList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = xml_builder_1.XmlNode.of("string", entry);
        return node.withName("Field");
    });
};
const serializeAws_restXmlFieldPatternList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = xml_builder_1.XmlNode.of("string", entry);
        return node.withName("FieldPattern");
    });
};
const serializeAws_restXmlFieldPatterns = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("FieldPatterns");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlFieldPatternList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlForwardedValues = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ForwardedValues");
    if (input.QueryString != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.QueryString)).withName("QueryString");
        bodyNode.addChildNode(node);
    }
    if (input.Cookies != null) {
        const node = serializeAws_restXmlCookiePreference(input.Cookies, context).withName("Cookies");
        bodyNode.addChildNode(node);
    }
    if (input.Headers != null) {
        const node = serializeAws_restXmlHeaders(input.Headers, context).withName("Headers");
        bodyNode.addChildNode(node);
    }
    if (input.QueryStringCacheKeys != null) {
        const node = serializeAws_restXmlQueryStringCacheKeys(input.QueryStringCacheKeys, context).withName("QueryStringCacheKeys");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlFunctionAssociation = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("FunctionAssociation");
    if (input.FunctionARN != null) {
        const node = xml_builder_1.XmlNode.of("FunctionARN", input.FunctionARN).withName("FunctionARN");
        bodyNode.addChildNode(node);
    }
    if (input.EventType != null) {
        const node = xml_builder_1.XmlNode.of("EventType", input.EventType).withName("EventType");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlFunctionAssociationList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = serializeAws_restXmlFunctionAssociation(entry, context);
        return node.withName("FunctionAssociation");
    });
};
const serializeAws_restXmlFunctionAssociations = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("FunctionAssociations");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlFunctionAssociationList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlFunctionConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("FunctionConfig");
    if (input.Comment != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Comment).withName("Comment");
        bodyNode.addChildNode(node);
    }
    if (input.Runtime != null) {
        const node = xml_builder_1.XmlNode.of("FunctionRuntime", input.Runtime).withName("Runtime");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlGeoRestriction = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("GeoRestriction");
    if (input.RestrictionType != null) {
        const node = xml_builder_1.XmlNode.of("GeoRestrictionType", input.RestrictionType).withName("RestrictionType");
        bodyNode.addChildNode(node);
    }
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlLocationList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlHeaderList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = xml_builder_1.XmlNode.of("string", entry);
        return node.withName("Name");
    });
};
const serializeAws_restXmlHeaders = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("Headers");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlHeaderList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlInvalidationBatch = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("InvalidationBatch");
    if (input.Paths != null) {
        const node = serializeAws_restXmlPaths(input.Paths, context).withName("Paths");
        bodyNode.addChildNode(node);
    }
    if (input.CallerReference != null) {
        const node = xml_builder_1.XmlNode.of("string", input.CallerReference).withName("CallerReference");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlKeyGroupConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("KeyGroupConfig");
    if (input.Name != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Name).withName("Name");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlPublicKeyIdList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.Comment != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Comment).withName("Comment");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlKinesisStreamConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("KinesisStreamConfig");
    if (input.RoleARN != null) {
        const node = xml_builder_1.XmlNode.of("string", input.RoleARN).withName("RoleARN");
        bodyNode.addChildNode(node);
    }
    if (input.StreamARN != null) {
        const node = xml_builder_1.XmlNode.of("string", input.StreamARN).withName("StreamARN");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlLambdaFunctionAssociation = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("LambdaFunctionAssociation");
    if (input.LambdaFunctionARN != null) {
        const node = xml_builder_1.XmlNode.of("LambdaFunctionARN", input.LambdaFunctionARN).withName("LambdaFunctionARN");
        bodyNode.addChildNode(node);
    }
    if (input.EventType != null) {
        const node = xml_builder_1.XmlNode.of("EventType", input.EventType).withName("EventType");
        bodyNode.addChildNode(node);
    }
    if (input.IncludeBody != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.IncludeBody)).withName("IncludeBody");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlLambdaFunctionAssociationList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = serializeAws_restXmlLambdaFunctionAssociation(entry, context);
        return node.withName("LambdaFunctionAssociation");
    });
};
const serializeAws_restXmlLambdaFunctionAssociations = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("LambdaFunctionAssociations");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlLambdaFunctionAssociationList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlLocationList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = xml_builder_1.XmlNode.of("string", entry);
        return node.withName("Location");
    });
};
const serializeAws_restXmlLoggingConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("LoggingConfig");
    if (input.Enabled != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.Enabled)).withName("Enabled");
        bodyNode.addChildNode(node);
    }
    if (input.IncludeCookies != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.IncludeCookies)).withName("IncludeCookies");
        bodyNode.addChildNode(node);
    }
    if (input.Bucket != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Bucket).withName("Bucket");
        bodyNode.addChildNode(node);
    }
    if (input.Prefix != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Prefix).withName("Prefix");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlMethodsList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = xml_builder_1.XmlNode.of("Method", entry);
        return node.withName("Method");
    });
};
const serializeAws_restXmlMonitoringSubscription = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("MonitoringSubscription");
    if (input.RealtimeMetricsSubscriptionConfig != null) {
        const node = serializeAws_restXmlRealtimeMetricsSubscriptionConfig(input.RealtimeMetricsSubscriptionConfig, context).withName("RealtimeMetricsSubscriptionConfig");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlOrigin = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("Origin");
    if (input.Id != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Id).withName("Id");
        bodyNode.addChildNode(node);
    }
    if (input.DomainName != null) {
        const node = xml_builder_1.XmlNode.of("string", input.DomainName).withName("DomainName");
        bodyNode.addChildNode(node);
    }
    if (input.OriginPath != null) {
        const node = xml_builder_1.XmlNode.of("string", input.OriginPath).withName("OriginPath");
        bodyNode.addChildNode(node);
    }
    if (input.CustomHeaders != null) {
        const node = serializeAws_restXmlCustomHeaders(input.CustomHeaders, context).withName("CustomHeaders");
        bodyNode.addChildNode(node);
    }
    if (input.S3OriginConfig != null) {
        const node = serializeAws_restXmlS3OriginConfig(input.S3OriginConfig, context).withName("S3OriginConfig");
        bodyNode.addChildNode(node);
    }
    if (input.CustomOriginConfig != null) {
        const node = serializeAws_restXmlCustomOriginConfig(input.CustomOriginConfig, context).withName("CustomOriginConfig");
        bodyNode.addChildNode(node);
    }
    if (input.ConnectionAttempts != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.ConnectionAttempts)).withName("ConnectionAttempts");
        bodyNode.addChildNode(node);
    }
    if (input.ConnectionTimeout != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.ConnectionTimeout)).withName("ConnectionTimeout");
        bodyNode.addChildNode(node);
    }
    if (input.OriginShield != null) {
        const node = serializeAws_restXmlOriginShield(input.OriginShield, context).withName("OriginShield");
        bodyNode.addChildNode(node);
    }
    if (input.OriginAccessControlId != null) {
        const node = xml_builder_1.XmlNode.of("string", input.OriginAccessControlId).withName("OriginAccessControlId");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlOriginAccessControlConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("OriginAccessControlConfig");
    if (input.Name != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Name).withName("Name");
        bodyNode.addChildNode(node);
    }
    if (input.Description != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Description).withName("Description");
        bodyNode.addChildNode(node);
    }
    if (input.SigningProtocol != null) {
        const node = xml_builder_1.XmlNode.of("OriginAccessControlSigningProtocols", input.SigningProtocol).withName("SigningProtocol");
        bodyNode.addChildNode(node);
    }
    if (input.SigningBehavior != null) {
        const node = xml_builder_1.XmlNode.of("OriginAccessControlSigningBehaviors", input.SigningBehavior).withName("SigningBehavior");
        bodyNode.addChildNode(node);
    }
    if (input.OriginAccessControlOriginType != null) {
        const node = xml_builder_1.XmlNode
            .of("OriginAccessControlOriginTypes", input.OriginAccessControlOriginType)
            .withName("OriginAccessControlOriginType");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlOriginCustomHeader = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("OriginCustomHeader");
    if (input.HeaderName != null) {
        const node = xml_builder_1.XmlNode.of("string", input.HeaderName).withName("HeaderName");
        bodyNode.addChildNode(node);
    }
    if (input.HeaderValue != null) {
        const node = xml_builder_1.XmlNode.of("sensitiveStringType", input.HeaderValue).withName("HeaderValue");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlOriginCustomHeadersList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = serializeAws_restXmlOriginCustomHeader(entry, context);
        return node.withName("OriginCustomHeader");
    });
};
const serializeAws_restXmlOriginGroup = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("OriginGroup");
    if (input.Id != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Id).withName("Id");
        bodyNode.addChildNode(node);
    }
    if (input.FailoverCriteria != null) {
        const node = serializeAws_restXmlOriginGroupFailoverCriteria(input.FailoverCriteria, context).withName("FailoverCriteria");
        bodyNode.addChildNode(node);
    }
    if (input.Members != null) {
        const node = serializeAws_restXmlOriginGroupMembers(input.Members, context).withName("Members");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlOriginGroupFailoverCriteria = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("OriginGroupFailoverCriteria");
    if (input.StatusCodes != null) {
        const node = serializeAws_restXmlStatusCodes(input.StatusCodes, context).withName("StatusCodes");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlOriginGroupList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = serializeAws_restXmlOriginGroup(entry, context);
        return node.withName("OriginGroup");
    });
};
const serializeAws_restXmlOriginGroupMember = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("OriginGroupMember");
    if (input.OriginId != null) {
        const node = xml_builder_1.XmlNode.of("string", input.OriginId).withName("OriginId");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlOriginGroupMemberList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = serializeAws_restXmlOriginGroupMember(entry, context);
        return node.withName("OriginGroupMember");
    });
};
const serializeAws_restXmlOriginGroupMembers = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("OriginGroupMembers");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlOriginGroupMemberList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlOriginGroups = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("OriginGroups");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlOriginGroupList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlOriginList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = serializeAws_restXmlOrigin(entry, context);
        return node.withName("Origin");
    });
};
const serializeAws_restXmlOriginRequestPolicyConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("OriginRequestPolicyConfig");
    if (input.Comment != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Comment).withName("Comment");
        bodyNode.addChildNode(node);
    }
    if (input.Name != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Name).withName("Name");
        bodyNode.addChildNode(node);
    }
    if (input.HeadersConfig != null) {
        const node = serializeAws_restXmlOriginRequestPolicyHeadersConfig(input.HeadersConfig, context).withName("HeadersConfig");
        bodyNode.addChildNode(node);
    }
    if (input.CookiesConfig != null) {
        const node = serializeAws_restXmlOriginRequestPolicyCookiesConfig(input.CookiesConfig, context).withName("CookiesConfig");
        bodyNode.addChildNode(node);
    }
    if (input.QueryStringsConfig != null) {
        const node = serializeAws_restXmlOriginRequestPolicyQueryStringsConfig(input.QueryStringsConfig, context).withName("QueryStringsConfig");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlOriginRequestPolicyCookiesConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("OriginRequestPolicyCookiesConfig");
    if (input.CookieBehavior != null) {
        const node = xml_builder_1.XmlNode.of("OriginRequestPolicyCookieBehavior", input.CookieBehavior).withName("CookieBehavior");
        bodyNode.addChildNode(node);
    }
    if (input.Cookies != null) {
        const node = serializeAws_restXmlCookieNames(input.Cookies, context).withName("Cookies");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlOriginRequestPolicyHeadersConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("OriginRequestPolicyHeadersConfig");
    if (input.HeaderBehavior != null) {
        const node = xml_builder_1.XmlNode.of("OriginRequestPolicyHeaderBehavior", input.HeaderBehavior).withName("HeaderBehavior");
        bodyNode.addChildNode(node);
    }
    if (input.Headers != null) {
        const node = serializeAws_restXmlHeaders(input.Headers, context).withName("Headers");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlOriginRequestPolicyQueryStringsConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("OriginRequestPolicyQueryStringsConfig");
    if (input.QueryStringBehavior != null) {
        const node = xml_builder_1.XmlNode
            .of("OriginRequestPolicyQueryStringBehavior", input.QueryStringBehavior)
            .withName("QueryStringBehavior");
        bodyNode.addChildNode(node);
    }
    if (input.QueryStrings != null) {
        const node = serializeAws_restXmlQueryStringNames(input.QueryStrings, context).withName("QueryStrings");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlOrigins = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("Origins");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlOriginList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlOriginShield = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("OriginShield");
    if (input.Enabled != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.Enabled)).withName("Enabled");
        bodyNode.addChildNode(node);
    }
    if (input.OriginShieldRegion != null) {
        const node = xml_builder_1.XmlNode.of("OriginShieldRegion", input.OriginShieldRegion).withName("OriginShieldRegion");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlOriginSslProtocols = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("OriginSslProtocols");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlSslProtocolsList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlParametersInCacheKeyAndForwardedToOrigin = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ParametersInCacheKeyAndForwardedToOrigin");
    if (input.EnableAcceptEncodingGzip != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.EnableAcceptEncodingGzip)).withName("EnableAcceptEncodingGzip");
        bodyNode.addChildNode(node);
    }
    if (input.EnableAcceptEncodingBrotli != null) {
        const node = xml_builder_1.XmlNode
            .of("boolean", String(input.EnableAcceptEncodingBrotli))
            .withName("EnableAcceptEncodingBrotli");
        bodyNode.addChildNode(node);
    }
    if (input.HeadersConfig != null) {
        const node = serializeAws_restXmlCachePolicyHeadersConfig(input.HeadersConfig, context).withName("HeadersConfig");
        bodyNode.addChildNode(node);
    }
    if (input.CookiesConfig != null) {
        const node = serializeAws_restXmlCachePolicyCookiesConfig(input.CookiesConfig, context).withName("CookiesConfig");
        bodyNode.addChildNode(node);
    }
    if (input.QueryStringsConfig != null) {
        const node = serializeAws_restXmlCachePolicyQueryStringsConfig(input.QueryStringsConfig, context).withName("QueryStringsConfig");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlPathList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = xml_builder_1.XmlNode.of("string", entry);
        return node.withName("Path");
    });
};
const serializeAws_restXmlPaths = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("Paths");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlPathList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlPublicKeyConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("PublicKeyConfig");
    if (input.CallerReference != null) {
        const node = xml_builder_1.XmlNode.of("string", input.CallerReference).withName("CallerReference");
        bodyNode.addChildNode(node);
    }
    if (input.Name != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Name).withName("Name");
        bodyNode.addChildNode(node);
    }
    if (input.EncodedKey != null) {
        const node = xml_builder_1.XmlNode.of("string", input.EncodedKey).withName("EncodedKey");
        bodyNode.addChildNode(node);
    }
    if (input.Comment != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Comment).withName("Comment");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlPublicKeyIdList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = xml_builder_1.XmlNode.of("string", entry);
        return node.withName("PublicKey");
    });
};
const serializeAws_restXmlQueryArgProfile = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("QueryArgProfile");
    if (input.QueryArg != null) {
        const node = xml_builder_1.XmlNode.of("string", input.QueryArg).withName("QueryArg");
        bodyNode.addChildNode(node);
    }
    if (input.ProfileId != null) {
        const node = xml_builder_1.XmlNode.of("string", input.ProfileId).withName("ProfileId");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlQueryArgProfileConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("QueryArgProfileConfig");
    if (input.ForwardWhenQueryArgProfileIsUnknown != null) {
        const node = xml_builder_1.XmlNode
            .of("boolean", String(input.ForwardWhenQueryArgProfileIsUnknown))
            .withName("ForwardWhenQueryArgProfileIsUnknown");
        bodyNode.addChildNode(node);
    }
    if (input.QueryArgProfiles != null) {
        const node = serializeAws_restXmlQueryArgProfiles(input.QueryArgProfiles, context).withName("QueryArgProfiles");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlQueryArgProfileList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = serializeAws_restXmlQueryArgProfile(entry, context);
        return node.withName("QueryArgProfile");
    });
};
const serializeAws_restXmlQueryArgProfiles = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("QueryArgProfiles");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlQueryArgProfileList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlQueryStringCacheKeys = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("QueryStringCacheKeys");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlQueryStringCacheKeysList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlQueryStringCacheKeysList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = xml_builder_1.XmlNode.of("string", entry);
        return node.withName("Name");
    });
};
const serializeAws_restXmlQueryStringNames = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("QueryStringNames");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlQueryStringNamesList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlQueryStringNamesList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = xml_builder_1.XmlNode.of("string", entry);
        return node.withName("Name");
    });
};
const serializeAws_restXmlRealtimeMetricsSubscriptionConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("RealtimeMetricsSubscriptionConfig");
    if (input.RealtimeMetricsSubscriptionStatus != null) {
        const node = xml_builder_1.XmlNode
            .of("RealtimeMetricsSubscriptionStatus", input.RealtimeMetricsSubscriptionStatus)
            .withName("RealtimeMetricsSubscriptionStatus");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlResponseHeadersPolicyAccessControlAllowHeaders = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ResponseHeadersPolicyAccessControlAllowHeaders");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlAccessControlAllowHeadersList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlResponseHeadersPolicyAccessControlAllowMethods = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ResponseHeadersPolicyAccessControlAllowMethods");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlAccessControlAllowMethodsList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlResponseHeadersPolicyAccessControlAllowOrigins = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ResponseHeadersPolicyAccessControlAllowOrigins");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlAccessControlAllowOriginsList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlResponseHeadersPolicyAccessControlExposeHeaders = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ResponseHeadersPolicyAccessControlExposeHeaders");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlAccessControlExposeHeadersList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlResponseHeadersPolicyConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ResponseHeadersPolicyConfig");
    if (input.Comment != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Comment).withName("Comment");
        bodyNode.addChildNode(node);
    }
    if (input.Name != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Name).withName("Name");
        bodyNode.addChildNode(node);
    }
    if (input.CorsConfig != null) {
        const node = serializeAws_restXmlResponseHeadersPolicyCorsConfig(input.CorsConfig, context).withName("CorsConfig");
        bodyNode.addChildNode(node);
    }
    if (input.SecurityHeadersConfig != null) {
        const node = serializeAws_restXmlResponseHeadersPolicySecurityHeadersConfig(input.SecurityHeadersConfig, context).withName("SecurityHeadersConfig");
        bodyNode.addChildNode(node);
    }
    if (input.ServerTimingHeadersConfig != null) {
        const node = serializeAws_restXmlResponseHeadersPolicyServerTimingHeadersConfig(input.ServerTimingHeadersConfig, context).withName("ServerTimingHeadersConfig");
        bodyNode.addChildNode(node);
    }
    if (input.CustomHeadersConfig != null) {
        const node = serializeAws_restXmlResponseHeadersPolicyCustomHeadersConfig(input.CustomHeadersConfig, context).withName("CustomHeadersConfig");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlResponseHeadersPolicyContentSecurityPolicy = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ResponseHeadersPolicyContentSecurityPolicy");
    if (input.Override != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.Override)).withName("Override");
        bodyNode.addChildNode(node);
    }
    if (input.ContentSecurityPolicy != null) {
        const node = xml_builder_1.XmlNode.of("string", input.ContentSecurityPolicy).withName("ContentSecurityPolicy");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlResponseHeadersPolicyContentTypeOptions = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ResponseHeadersPolicyContentTypeOptions");
    if (input.Override != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.Override)).withName("Override");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlResponseHeadersPolicyCorsConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ResponseHeadersPolicyCorsConfig");
    if (input.AccessControlAllowOrigins != null) {
        const node = serializeAws_restXmlResponseHeadersPolicyAccessControlAllowOrigins(input.AccessControlAllowOrigins, context).withName("AccessControlAllowOrigins");
        bodyNode.addChildNode(node);
    }
    if (input.AccessControlAllowHeaders != null) {
        const node = serializeAws_restXmlResponseHeadersPolicyAccessControlAllowHeaders(input.AccessControlAllowHeaders, context).withName("AccessControlAllowHeaders");
        bodyNode.addChildNode(node);
    }
    if (input.AccessControlAllowMethods != null) {
        const node = serializeAws_restXmlResponseHeadersPolicyAccessControlAllowMethods(input.AccessControlAllowMethods, context).withName("AccessControlAllowMethods");
        bodyNode.addChildNode(node);
    }
    if (input.AccessControlAllowCredentials != null) {
        const node = xml_builder_1.XmlNode
            .of("boolean", String(input.AccessControlAllowCredentials))
            .withName("AccessControlAllowCredentials");
        bodyNode.addChildNode(node);
    }
    if (input.AccessControlExposeHeaders != null) {
        const node = serializeAws_restXmlResponseHeadersPolicyAccessControlExposeHeaders(input.AccessControlExposeHeaders, context).withName("AccessControlExposeHeaders");
        bodyNode.addChildNode(node);
    }
    if (input.AccessControlMaxAgeSec != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.AccessControlMaxAgeSec)).withName("AccessControlMaxAgeSec");
        bodyNode.addChildNode(node);
    }
    if (input.OriginOverride != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.OriginOverride)).withName("OriginOverride");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlResponseHeadersPolicyCustomHeader = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ResponseHeadersPolicyCustomHeader");
    if (input.Header != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Header).withName("Header");
        bodyNode.addChildNode(node);
    }
    if (input.Value != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Value).withName("Value");
        bodyNode.addChildNode(node);
    }
    if (input.Override != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.Override)).withName("Override");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlResponseHeadersPolicyCustomHeaderList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = serializeAws_restXmlResponseHeadersPolicyCustomHeader(entry, context);
        return node.withName("ResponseHeadersPolicyCustomHeader");
    });
};
const serializeAws_restXmlResponseHeadersPolicyCustomHeadersConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ResponseHeadersPolicyCustomHeadersConfig");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlResponseHeadersPolicyCustomHeaderList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlResponseHeadersPolicyFrameOptions = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ResponseHeadersPolicyFrameOptions");
    if (input.Override != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.Override)).withName("Override");
        bodyNode.addChildNode(node);
    }
    if (input.FrameOption != null) {
        const node = xml_builder_1.XmlNode.of("FrameOptionsList", input.FrameOption).withName("FrameOption");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlResponseHeadersPolicyReferrerPolicy = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ResponseHeadersPolicyReferrerPolicy");
    if (input.Override != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.Override)).withName("Override");
        bodyNode.addChildNode(node);
    }
    if (input.ReferrerPolicy != null) {
        const node = xml_builder_1.XmlNode.of("ReferrerPolicyList", input.ReferrerPolicy).withName("ReferrerPolicy");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlResponseHeadersPolicySecurityHeadersConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ResponseHeadersPolicySecurityHeadersConfig");
    if (input.XSSProtection != null) {
        const node = serializeAws_restXmlResponseHeadersPolicyXSSProtection(input.XSSProtection, context).withName("XSSProtection");
        bodyNode.addChildNode(node);
    }
    if (input.FrameOptions != null) {
        const node = serializeAws_restXmlResponseHeadersPolicyFrameOptions(input.FrameOptions, context).withName("FrameOptions");
        bodyNode.addChildNode(node);
    }
    if (input.ReferrerPolicy != null) {
        const node = serializeAws_restXmlResponseHeadersPolicyReferrerPolicy(input.ReferrerPolicy, context).withName("ReferrerPolicy");
        bodyNode.addChildNode(node);
    }
    if (input.ContentSecurityPolicy != null) {
        const node = serializeAws_restXmlResponseHeadersPolicyContentSecurityPolicy(input.ContentSecurityPolicy, context).withName("ContentSecurityPolicy");
        bodyNode.addChildNode(node);
    }
    if (input.ContentTypeOptions != null) {
        const node = serializeAws_restXmlResponseHeadersPolicyContentTypeOptions(input.ContentTypeOptions, context).withName("ContentTypeOptions");
        bodyNode.addChildNode(node);
    }
    if (input.StrictTransportSecurity != null) {
        const node = serializeAws_restXmlResponseHeadersPolicyStrictTransportSecurity(input.StrictTransportSecurity, context).withName("StrictTransportSecurity");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlResponseHeadersPolicyServerTimingHeadersConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ResponseHeadersPolicyServerTimingHeadersConfig");
    if (input.Enabled != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.Enabled)).withName("Enabled");
        bodyNode.addChildNode(node);
    }
    if (input.SamplingRate != null) {
        const node = xml_builder_1.XmlNode.of("SamplingRate", String(input.SamplingRate)).withName("SamplingRate");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlResponseHeadersPolicyStrictTransportSecurity = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ResponseHeadersPolicyStrictTransportSecurity");
    if (input.Override != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.Override)).withName("Override");
        bodyNode.addChildNode(node);
    }
    if (input.IncludeSubdomains != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.IncludeSubdomains)).withName("IncludeSubdomains");
        bodyNode.addChildNode(node);
    }
    if (input.Preload != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.Preload)).withName("Preload");
        bodyNode.addChildNode(node);
    }
    if (input.AccessControlMaxAgeSec != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.AccessControlMaxAgeSec)).withName("AccessControlMaxAgeSec");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlResponseHeadersPolicyXSSProtection = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ResponseHeadersPolicyXSSProtection");
    if (input.Override != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.Override)).withName("Override");
        bodyNode.addChildNode(node);
    }
    if (input.Protection != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.Protection)).withName("Protection");
        bodyNode.addChildNode(node);
    }
    if (input.ModeBlock != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.ModeBlock)).withName("ModeBlock");
        bodyNode.addChildNode(node);
    }
    if (input.ReportUri != null) {
        const node = xml_builder_1.XmlNode.of("string", input.ReportUri).withName("ReportUri");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlRestrictions = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("Restrictions");
    if (input.GeoRestriction != null) {
        const node = serializeAws_restXmlGeoRestriction(input.GeoRestriction, context).withName("GeoRestriction");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlS3Origin = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("S3Origin");
    if (input.DomainName != null) {
        const node = xml_builder_1.XmlNode.of("string", input.DomainName).withName("DomainName");
        bodyNode.addChildNode(node);
    }
    if (input.OriginAccessIdentity != null) {
        const node = xml_builder_1.XmlNode.of("string", input.OriginAccessIdentity).withName("OriginAccessIdentity");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlS3OriginConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("S3OriginConfig");
    if (input.OriginAccessIdentity != null) {
        const node = xml_builder_1.XmlNode.of("string", input.OriginAccessIdentity).withName("OriginAccessIdentity");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlSessionStickinessConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("SessionStickinessConfig");
    if (input.IdleTTL != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.IdleTTL)).withName("IdleTTL");
        bodyNode.addChildNode(node);
    }
    if (input.MaximumTTL != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.MaximumTTL)).withName("MaximumTTL");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlSslProtocolsList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = xml_builder_1.XmlNode.of("SslProtocol", entry);
        return node.withName("SslProtocol");
    });
};
const serializeAws_restXmlStagingDistributionDnsNameList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = xml_builder_1.XmlNode.of("string", entry);
        return node.withName("DnsName");
    });
};
const serializeAws_restXmlStagingDistributionDnsNames = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("StagingDistributionDnsNames");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlStagingDistributionDnsNameList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlStatusCodeList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = xml_builder_1.XmlNode.of("integer", String(entry));
        return node.withName("StatusCode");
    });
};
const serializeAws_restXmlStatusCodes = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("StatusCodes");
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlStatusCodeList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlStreamingDistributionConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("StreamingDistributionConfig");
    if (input.CallerReference != null) {
        const node = xml_builder_1.XmlNode.of("string", input.CallerReference).withName("CallerReference");
        bodyNode.addChildNode(node);
    }
    if (input.S3Origin != null) {
        const node = serializeAws_restXmlS3Origin(input.S3Origin, context).withName("S3Origin");
        bodyNode.addChildNode(node);
    }
    if (input.Aliases != null) {
        const node = serializeAws_restXmlAliases(input.Aliases, context).withName("Aliases");
        bodyNode.addChildNode(node);
    }
    if (input.Comment != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Comment).withName("Comment");
        bodyNode.addChildNode(node);
    }
    if (input.Logging != null) {
        const node = serializeAws_restXmlStreamingLoggingConfig(input.Logging, context).withName("Logging");
        bodyNode.addChildNode(node);
    }
    if (input.TrustedSigners != null) {
        const node = serializeAws_restXmlTrustedSigners(input.TrustedSigners, context).withName("TrustedSigners");
        bodyNode.addChildNode(node);
    }
    if (input.PriceClass != null) {
        const node = xml_builder_1.XmlNode.of("PriceClass", input.PriceClass).withName("PriceClass");
        bodyNode.addChildNode(node);
    }
    if (input.Enabled != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.Enabled)).withName("Enabled");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlStreamingDistributionConfigWithTags = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("StreamingDistributionConfigWithTags");
    if (input.StreamingDistributionConfig != null) {
        const node = serializeAws_restXmlStreamingDistributionConfig(input.StreamingDistributionConfig, context).withName("StreamingDistributionConfig");
        bodyNode.addChildNode(node);
    }
    if (input.Tags != null) {
        const node = serializeAws_restXmlTags(input.Tags, context).withName("Tags");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlStreamingLoggingConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("StreamingLoggingConfig");
    if (input.Enabled != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.Enabled)).withName("Enabled");
        bodyNode.addChildNode(node);
    }
    if (input.Bucket != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Bucket).withName("Bucket");
        bodyNode.addChildNode(node);
    }
    if (input.Prefix != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Prefix).withName("Prefix");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlTag = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("Tag");
    if (input.Key != null) {
        const node = xml_builder_1.XmlNode.of("TagKey", input.Key).withName("Key");
        bodyNode.addChildNode(node);
    }
    if (input.Value != null) {
        const node = xml_builder_1.XmlNode.of("TagValue", input.Value).withName("Value");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlTagKeyList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = xml_builder_1.XmlNode.of("TagKey", entry);
        return node.withName("Key");
    });
};
const serializeAws_restXmlTagKeys = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("TagKeys");
    if (input.Items != null) {
        const nodes = serializeAws_restXmlTagKeyList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlTagList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = serializeAws_restXmlTag(entry, context);
        return node.withName("Tag");
    });
};
const serializeAws_restXmlTags = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("Tags");
    if (input.Items != null) {
        const nodes = serializeAws_restXmlTagList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlTrafficConfig = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("TrafficConfig");
    if (input.SingleWeightConfig != null) {
        const node = serializeAws_restXmlContinuousDeploymentSingleWeightConfig(input.SingleWeightConfig, context).withName("SingleWeightConfig");
        bodyNode.addChildNode(node);
    }
    if (input.SingleHeaderConfig != null) {
        const node = serializeAws_restXmlContinuousDeploymentSingleHeaderConfig(input.SingleHeaderConfig, context).withName("SingleHeaderConfig");
        bodyNode.addChildNode(node);
    }
    if (input.Type != null) {
        const node = xml_builder_1.XmlNode.of("ContinuousDeploymentPolicyType", input.Type).withName("Type");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const serializeAws_restXmlTrustedKeyGroupIdList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = xml_builder_1.XmlNode.of("string", entry);
        return node.withName("KeyGroup");
    });
};
const serializeAws_restXmlTrustedKeyGroups = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("TrustedKeyGroups");
    if (input.Enabled != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.Enabled)).withName("Enabled");
        bodyNode.addChildNode(node);
    }
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlTrustedKeyGroupIdList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlTrustedSigners = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("TrustedSigners");
    if (input.Enabled != null) {
        const node = xml_builder_1.XmlNode.of("boolean", String(input.Enabled)).withName("Enabled");
        bodyNode.addChildNode(node);
    }
    if (input.Quantity != null) {
        const node = xml_builder_1.XmlNode.of("integer", String(input.Quantity)).withName("Quantity");
        bodyNode.addChildNode(node);
    }
    if (input.Items != null) {
        const nodes = serializeAws_restXmlAwsAccountNumberList(input.Items, context);
        const containerNode = new xml_builder_1.XmlNode("Items");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const serializeAws_restXmlViewerCertificate = (input, context) => {
    const bodyNode = new xml_builder_1.XmlNode("ViewerCertificate");
    if (input.CloudFrontDefaultCertificate != null) {
        const node = xml_builder_1.XmlNode
            .of("boolean", String(input.CloudFrontDefaultCertificate))
            .withName("CloudFrontDefaultCertificate");
        bodyNode.addChildNode(node);
    }
    if (input.IAMCertificateId != null) {
        const node = xml_builder_1.XmlNode.of("string", input.IAMCertificateId).withName("IAMCertificateId");
        bodyNode.addChildNode(node);
    }
    if (input.ACMCertificateArn != null) {
        const node = xml_builder_1.XmlNode.of("string", input.ACMCertificateArn).withName("ACMCertificateArn");
        bodyNode.addChildNode(node);
    }
    if (input.SSLSupportMethod != null) {
        const node = xml_builder_1.XmlNode.of("SSLSupportMethod", input.SSLSupportMethod).withName("SSLSupportMethod");
        bodyNode.addChildNode(node);
    }
    if (input.MinimumProtocolVersion != null) {
        const node = xml_builder_1.XmlNode
            .of("MinimumProtocolVersion", input.MinimumProtocolVersion)
            .withName("MinimumProtocolVersion");
        bodyNode.addChildNode(node);
    }
    if (input.Certificate != null) {
        const node = xml_builder_1.XmlNode.of("string", input.Certificate).withName("Certificate");
        bodyNode.addChildNode(node);
    }
    if (input.CertificateSource != null) {
        const node = xml_builder_1.XmlNode.of("CertificateSource", input.CertificateSource).withName("CertificateSource");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const deserializeAws_restXmlAccessControlAllowHeadersList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const deserializeAws_restXmlAccessControlAllowMethodsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const deserializeAws_restXmlAccessControlAllowOriginsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const deserializeAws_restXmlAccessControlExposeHeadersList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const deserializeAws_restXmlActiveTrustedKeyGroups = (output, context) => {
    const contents = {
        Enabled: undefined,
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Enabled"] !== undefined) {
        contents.Enabled = (0, smithy_client_1.parseBoolean)(output["Enabled"]);
    }
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["KeyGroup"] !== undefined) {
        contents.Items = deserializeAws_restXmlKGKeyPairIdsList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["KeyGroup"]), context);
    }
    return contents;
};
const deserializeAws_restXmlActiveTrustedSigners = (output, context) => {
    const contents = {
        Enabled: undefined,
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Enabled"] !== undefined) {
        contents.Enabled = (0, smithy_client_1.parseBoolean)(output["Enabled"]);
    }
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["Signer"] !== undefined) {
        contents.Items = deserializeAws_restXmlSignerList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["Signer"]), context);
    }
    return contents;
};
const deserializeAws_restXmlAliases = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["CNAME"] !== undefined) {
        contents.Items = deserializeAws_restXmlAliasList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["CNAME"]), context);
    }
    return contents;
};
const deserializeAws_restXmlAliasICPRecordal = (output, context) => {
    const contents = {
        CNAME: undefined,
        ICPRecordalStatus: undefined,
    };
    if (output["CNAME"] !== undefined) {
        contents.CNAME = (0, smithy_client_1.expectString)(output["CNAME"]);
    }
    if (output["ICPRecordalStatus"] !== undefined) {
        contents.ICPRecordalStatus = (0, smithy_client_1.expectString)(output["ICPRecordalStatus"]);
    }
    return contents;
};
const deserializeAws_restXmlAliasICPRecordals = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlAliasICPRecordal(entry, context);
    });
};
const deserializeAws_restXmlAliasList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const deserializeAws_restXmlAllowedMethods = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
        CachedMethods: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["Method"] !== undefined) {
        contents.Items = deserializeAws_restXmlMethodsList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["Method"]), context);
    }
    if (output["CachedMethods"] !== undefined) {
        contents.CachedMethods = deserializeAws_restXmlCachedMethods(output["CachedMethods"], context);
    }
    return contents;
};
const deserializeAws_restXmlAwsAccountNumberList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const deserializeAws_restXmlCacheBehavior = (output, context) => {
    const contents = {
        PathPattern: undefined,
        TargetOriginId: undefined,
        TrustedSigners: undefined,
        TrustedKeyGroups: undefined,
        ViewerProtocolPolicy: undefined,
        AllowedMethods: undefined,
        SmoothStreaming: undefined,
        Compress: undefined,
        LambdaFunctionAssociations: undefined,
        FunctionAssociations: undefined,
        FieldLevelEncryptionId: undefined,
        RealtimeLogConfigArn: undefined,
        CachePolicyId: undefined,
        OriginRequestPolicyId: undefined,
        ResponseHeadersPolicyId: undefined,
        ForwardedValues: undefined,
        MinTTL: undefined,
        DefaultTTL: undefined,
        MaxTTL: undefined,
    };
    if (output["PathPattern"] !== undefined) {
        contents.PathPattern = (0, smithy_client_1.expectString)(output["PathPattern"]);
    }
    if (output["TargetOriginId"] !== undefined) {
        contents.TargetOriginId = (0, smithy_client_1.expectString)(output["TargetOriginId"]);
    }
    if (output["TrustedSigners"] !== undefined) {
        contents.TrustedSigners = deserializeAws_restXmlTrustedSigners(output["TrustedSigners"], context);
    }
    if (output["TrustedKeyGroups"] !== undefined) {
        contents.TrustedKeyGroups = deserializeAws_restXmlTrustedKeyGroups(output["TrustedKeyGroups"], context);
    }
    if (output["ViewerProtocolPolicy"] !== undefined) {
        contents.ViewerProtocolPolicy = (0, smithy_client_1.expectString)(output["ViewerProtocolPolicy"]);
    }
    if (output["AllowedMethods"] !== undefined) {
        contents.AllowedMethods = deserializeAws_restXmlAllowedMethods(output["AllowedMethods"], context);
    }
    if (output["SmoothStreaming"] !== undefined) {
        contents.SmoothStreaming = (0, smithy_client_1.parseBoolean)(output["SmoothStreaming"]);
    }
    if (output["Compress"] !== undefined) {
        contents.Compress = (0, smithy_client_1.parseBoolean)(output["Compress"]);
    }
    if (output["LambdaFunctionAssociations"] !== undefined) {
        contents.LambdaFunctionAssociations = deserializeAws_restXmlLambdaFunctionAssociations(output["LambdaFunctionAssociations"], context);
    }
    if (output["FunctionAssociations"] !== undefined) {
        contents.FunctionAssociations = deserializeAws_restXmlFunctionAssociations(output["FunctionAssociations"], context);
    }
    if (output["FieldLevelEncryptionId"] !== undefined) {
        contents.FieldLevelEncryptionId = (0, smithy_client_1.expectString)(output["FieldLevelEncryptionId"]);
    }
    if (output["RealtimeLogConfigArn"] !== undefined) {
        contents.RealtimeLogConfigArn = (0, smithy_client_1.expectString)(output["RealtimeLogConfigArn"]);
    }
    if (output["CachePolicyId"] !== undefined) {
        contents.CachePolicyId = (0, smithy_client_1.expectString)(output["CachePolicyId"]);
    }
    if (output["OriginRequestPolicyId"] !== undefined) {
        contents.OriginRequestPolicyId = (0, smithy_client_1.expectString)(output["OriginRequestPolicyId"]);
    }
    if (output["ResponseHeadersPolicyId"] !== undefined) {
        contents.ResponseHeadersPolicyId = (0, smithy_client_1.expectString)(output["ResponseHeadersPolicyId"]);
    }
    if (output["ForwardedValues"] !== undefined) {
        contents.ForwardedValues = deserializeAws_restXmlForwardedValues(output["ForwardedValues"], context);
    }
    if (output["MinTTL"] !== undefined) {
        contents.MinTTL = (0, smithy_client_1.strictParseLong)(output["MinTTL"]);
    }
    if (output["DefaultTTL"] !== undefined) {
        contents.DefaultTTL = (0, smithy_client_1.strictParseLong)(output["DefaultTTL"]);
    }
    if (output["MaxTTL"] !== undefined) {
        contents.MaxTTL = (0, smithy_client_1.strictParseLong)(output["MaxTTL"]);
    }
    return contents;
};
const deserializeAws_restXmlCacheBehaviorList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlCacheBehavior(entry, context);
    });
};
const deserializeAws_restXmlCacheBehaviors = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["CacheBehavior"] !== undefined) {
        contents.Items = deserializeAws_restXmlCacheBehaviorList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["CacheBehavior"]), context);
    }
    return contents;
};
const deserializeAws_restXmlCachedMethods = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["Method"] !== undefined) {
        contents.Items = deserializeAws_restXmlMethodsList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["Method"]), context);
    }
    return contents;
};
const deserializeAws_restXmlCachePolicy = (output, context) => {
    const contents = {
        Id: undefined,
        LastModifiedTime: undefined,
        CachePolicyConfig: undefined,
    };
    if (output["Id"] !== undefined) {
        contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["LastModifiedTime"] !== undefined) {
        contents.LastModifiedTime = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTime)(output["LastModifiedTime"]));
    }
    if (output["CachePolicyConfig"] !== undefined) {
        contents.CachePolicyConfig = deserializeAws_restXmlCachePolicyConfig(output["CachePolicyConfig"], context);
    }
    return contents;
};
const deserializeAws_restXmlCachePolicyConfig = (output, context) => {
    const contents = {
        Comment: undefined,
        Name: undefined,
        DefaultTTL: undefined,
        MaxTTL: undefined,
        MinTTL: undefined,
        ParametersInCacheKeyAndForwardedToOrigin: undefined,
    };
    if (output["Comment"] !== undefined) {
        contents.Comment = (0, smithy_client_1.expectString)(output["Comment"]);
    }
    if (output["Name"] !== undefined) {
        contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
    }
    if (output["DefaultTTL"] !== undefined) {
        contents.DefaultTTL = (0, smithy_client_1.strictParseLong)(output["DefaultTTL"]);
    }
    if (output["MaxTTL"] !== undefined) {
        contents.MaxTTL = (0, smithy_client_1.strictParseLong)(output["MaxTTL"]);
    }
    if (output["MinTTL"] !== undefined) {
        contents.MinTTL = (0, smithy_client_1.strictParseLong)(output["MinTTL"]);
    }
    if (output["ParametersInCacheKeyAndForwardedToOrigin"] !== undefined) {
        contents.ParametersInCacheKeyAndForwardedToOrigin = deserializeAws_restXmlParametersInCacheKeyAndForwardedToOrigin(output["ParametersInCacheKeyAndForwardedToOrigin"], context);
    }
    return contents;
};
const deserializeAws_restXmlCachePolicyCookiesConfig = (output, context) => {
    const contents = {
        CookieBehavior: undefined,
        Cookies: undefined,
    };
    if (output["CookieBehavior"] !== undefined) {
        contents.CookieBehavior = (0, smithy_client_1.expectString)(output["CookieBehavior"]);
    }
    if (output["Cookies"] !== undefined) {
        contents.Cookies = deserializeAws_restXmlCookieNames(output["Cookies"], context);
    }
    return contents;
};
const deserializeAws_restXmlCachePolicyHeadersConfig = (output, context) => {
    const contents = {
        HeaderBehavior: undefined,
        Headers: undefined,
    };
    if (output["HeaderBehavior"] !== undefined) {
        contents.HeaderBehavior = (0, smithy_client_1.expectString)(output["HeaderBehavior"]);
    }
    if (output["Headers"] !== undefined) {
        contents.Headers = deserializeAws_restXmlHeaders(output["Headers"], context);
    }
    return contents;
};
const deserializeAws_restXmlCachePolicyList = (output, context) => {
    const contents = {
        NextMarker: undefined,
        MaxItems: undefined,
        Quantity: undefined,
        Items: undefined,
    };
    if (output["NextMarker"] !== undefined) {
        contents.NextMarker = (0, smithy_client_1.expectString)(output["NextMarker"]);
    }
    if (output["MaxItems"] !== undefined) {
        contents.MaxItems = (0, smithy_client_1.strictParseInt32)(output["MaxItems"]);
    }
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["CachePolicySummary"] !== undefined) {
        contents.Items = deserializeAws_restXmlCachePolicySummaryList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["CachePolicySummary"]), context);
    }
    return contents;
};
const deserializeAws_restXmlCachePolicyQueryStringsConfig = (output, context) => {
    const contents = {
        QueryStringBehavior: undefined,
        QueryStrings: undefined,
    };
    if (output["QueryStringBehavior"] !== undefined) {
        contents.QueryStringBehavior = (0, smithy_client_1.expectString)(output["QueryStringBehavior"]);
    }
    if (output["QueryStrings"] !== undefined) {
        contents.QueryStrings = deserializeAws_restXmlQueryStringNames(output["QueryStrings"], context);
    }
    return contents;
};
const deserializeAws_restXmlCachePolicySummary = (output, context) => {
    const contents = {
        Type: undefined,
        CachePolicy: undefined,
    };
    if (output["Type"] !== undefined) {
        contents.Type = (0, smithy_client_1.expectString)(output["Type"]);
    }
    if (output["CachePolicy"] !== undefined) {
        contents.CachePolicy = deserializeAws_restXmlCachePolicy(output["CachePolicy"], context);
    }
    return contents;
};
const deserializeAws_restXmlCachePolicySummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlCachePolicySummary(entry, context);
    });
};
const deserializeAws_restXmlCloudFrontOriginAccessIdentity = (output, context) => {
    const contents = {
        Id: undefined,
        S3CanonicalUserId: undefined,
        CloudFrontOriginAccessIdentityConfig: undefined,
    };
    if (output["Id"] !== undefined) {
        contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["S3CanonicalUserId"] !== undefined) {
        contents.S3CanonicalUserId = (0, smithy_client_1.expectString)(output["S3CanonicalUserId"]);
    }
    if (output["CloudFrontOriginAccessIdentityConfig"] !== undefined) {
        contents.CloudFrontOriginAccessIdentityConfig = deserializeAws_restXmlCloudFrontOriginAccessIdentityConfig(output["CloudFrontOriginAccessIdentityConfig"], context);
    }
    return contents;
};
const deserializeAws_restXmlCloudFrontOriginAccessIdentityConfig = (output, context) => {
    const contents = {
        CallerReference: undefined,
        Comment: undefined,
    };
    if (output["CallerReference"] !== undefined) {
        contents.CallerReference = (0, smithy_client_1.expectString)(output["CallerReference"]);
    }
    if (output["Comment"] !== undefined) {
        contents.Comment = (0, smithy_client_1.expectString)(output["Comment"]);
    }
    return contents;
};
const deserializeAws_restXmlCloudFrontOriginAccessIdentityList = (output, context) => {
    const contents = {
        Marker: undefined,
        NextMarker: undefined,
        MaxItems: undefined,
        IsTruncated: undefined,
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    if (output["NextMarker"] !== undefined) {
        contents.NextMarker = (0, smithy_client_1.expectString)(output["NextMarker"]);
    }
    if (output["MaxItems"] !== undefined) {
        contents.MaxItems = (0, smithy_client_1.strictParseInt32)(output["MaxItems"]);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["CloudFrontOriginAccessIdentitySummary"] !== undefined) {
        contents.Items = deserializeAws_restXmlCloudFrontOriginAccessIdentitySummaryList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["CloudFrontOriginAccessIdentitySummary"]), context);
    }
    return contents;
};
const deserializeAws_restXmlCloudFrontOriginAccessIdentitySummary = (output, context) => {
    const contents = {
        Id: undefined,
        S3CanonicalUserId: undefined,
        Comment: undefined,
    };
    if (output["Id"] !== undefined) {
        contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["S3CanonicalUserId"] !== undefined) {
        contents.S3CanonicalUserId = (0, smithy_client_1.expectString)(output["S3CanonicalUserId"]);
    }
    if (output["Comment"] !== undefined) {
        contents.Comment = (0, smithy_client_1.expectString)(output["Comment"]);
    }
    return contents;
};
const deserializeAws_restXmlCloudFrontOriginAccessIdentitySummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlCloudFrontOriginAccessIdentitySummary(entry, context);
    });
};
const deserializeAws_restXmlConflictingAlias = (output, context) => {
    const contents = {
        Alias: undefined,
        DistributionId: undefined,
        AccountId: undefined,
    };
    if (output["Alias"] !== undefined) {
        contents.Alias = (0, smithy_client_1.expectString)(output["Alias"]);
    }
    if (output["DistributionId"] !== undefined) {
        contents.DistributionId = (0, smithy_client_1.expectString)(output["DistributionId"]);
    }
    if (output["AccountId"] !== undefined) {
        contents.AccountId = (0, smithy_client_1.expectString)(output["AccountId"]);
    }
    return contents;
};
const deserializeAws_restXmlConflictingAliases = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlConflictingAlias(entry, context);
    });
};
const deserializeAws_restXmlConflictingAliasesList = (output, context) => {
    const contents = {
        NextMarker: undefined,
        MaxItems: undefined,
        Quantity: undefined,
        Items: undefined,
    };
    if (output["NextMarker"] !== undefined) {
        contents.NextMarker = (0, smithy_client_1.expectString)(output["NextMarker"]);
    }
    if (output["MaxItems"] !== undefined) {
        contents.MaxItems = (0, smithy_client_1.strictParseInt32)(output["MaxItems"]);
    }
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["ConflictingAlias"] !== undefined) {
        contents.Items = deserializeAws_restXmlConflictingAliases((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["ConflictingAlias"]), context);
    }
    return contents;
};
const deserializeAws_restXmlContentTypeProfile = (output, context) => {
    const contents = {
        Format: undefined,
        ProfileId: undefined,
        ContentType: undefined,
    };
    if (output["Format"] !== undefined) {
        contents.Format = (0, smithy_client_1.expectString)(output["Format"]);
    }
    if (output["ProfileId"] !== undefined) {
        contents.ProfileId = (0, smithy_client_1.expectString)(output["ProfileId"]);
    }
    if (output["ContentType"] !== undefined) {
        contents.ContentType = (0, smithy_client_1.expectString)(output["ContentType"]);
    }
    return contents;
};
const deserializeAws_restXmlContentTypeProfileConfig = (output, context) => {
    const contents = {
        ForwardWhenContentTypeIsUnknown: undefined,
        ContentTypeProfiles: undefined,
    };
    if (output["ForwardWhenContentTypeIsUnknown"] !== undefined) {
        contents.ForwardWhenContentTypeIsUnknown = (0, smithy_client_1.parseBoolean)(output["ForwardWhenContentTypeIsUnknown"]);
    }
    if (output["ContentTypeProfiles"] !== undefined) {
        contents.ContentTypeProfiles = deserializeAws_restXmlContentTypeProfiles(output["ContentTypeProfiles"], context);
    }
    return contents;
};
const deserializeAws_restXmlContentTypeProfileList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlContentTypeProfile(entry, context);
    });
};
const deserializeAws_restXmlContentTypeProfiles = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["ContentTypeProfile"] !== undefined) {
        contents.Items = deserializeAws_restXmlContentTypeProfileList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["ContentTypeProfile"]), context);
    }
    return contents;
};
const deserializeAws_restXmlContinuousDeploymentPolicy = (output, context) => {
    const contents = {
        Id: undefined,
        LastModifiedTime: undefined,
        ContinuousDeploymentPolicyConfig: undefined,
    };
    if (output["Id"] !== undefined) {
        contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["LastModifiedTime"] !== undefined) {
        contents.LastModifiedTime = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTime)(output["LastModifiedTime"]));
    }
    if (output["ContinuousDeploymentPolicyConfig"] !== undefined) {
        contents.ContinuousDeploymentPolicyConfig = deserializeAws_restXmlContinuousDeploymentPolicyConfig(output["ContinuousDeploymentPolicyConfig"], context);
    }
    return contents;
};
const deserializeAws_restXmlContinuousDeploymentPolicyConfig = (output, context) => {
    const contents = {
        StagingDistributionDnsNames: undefined,
        Enabled: undefined,
        TrafficConfig: undefined,
    };
    if (output["StagingDistributionDnsNames"] !== undefined) {
        contents.StagingDistributionDnsNames = deserializeAws_restXmlStagingDistributionDnsNames(output["StagingDistributionDnsNames"], context);
    }
    if (output["Enabled"] !== undefined) {
        contents.Enabled = (0, smithy_client_1.parseBoolean)(output["Enabled"]);
    }
    if (output["TrafficConfig"] !== undefined) {
        contents.TrafficConfig = deserializeAws_restXmlTrafficConfig(output["TrafficConfig"], context);
    }
    return contents;
};
const deserializeAws_restXmlContinuousDeploymentPolicyList = (output, context) => {
    const contents = {
        NextMarker: undefined,
        MaxItems: undefined,
        Quantity: undefined,
        Items: undefined,
    };
    if (output["NextMarker"] !== undefined) {
        contents.NextMarker = (0, smithy_client_1.expectString)(output["NextMarker"]);
    }
    if (output["MaxItems"] !== undefined) {
        contents.MaxItems = (0, smithy_client_1.strictParseInt32)(output["MaxItems"]);
    }
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["ContinuousDeploymentPolicySummary"] !== undefined) {
        contents.Items = deserializeAws_restXmlContinuousDeploymentPolicySummaryList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["ContinuousDeploymentPolicySummary"]), context);
    }
    return contents;
};
const deserializeAws_restXmlContinuousDeploymentPolicySummary = (output, context) => {
    const contents = {
        ContinuousDeploymentPolicy: undefined,
    };
    if (output["ContinuousDeploymentPolicy"] !== undefined) {
        contents.ContinuousDeploymentPolicy = deserializeAws_restXmlContinuousDeploymentPolicy(output["ContinuousDeploymentPolicy"], context);
    }
    return contents;
};
const deserializeAws_restXmlContinuousDeploymentPolicySummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlContinuousDeploymentPolicySummary(entry, context);
    });
};
const deserializeAws_restXmlContinuousDeploymentSingleHeaderConfig = (output, context) => {
    const contents = {
        Header: undefined,
        Value: undefined,
    };
    if (output["Header"] !== undefined) {
        contents.Header = (0, smithy_client_1.expectString)(output["Header"]);
    }
    if (output["Value"] !== undefined) {
        contents.Value = (0, smithy_client_1.expectString)(output["Value"]);
    }
    return contents;
};
const deserializeAws_restXmlContinuousDeploymentSingleWeightConfig = (output, context) => {
    const contents = {
        Weight: undefined,
        SessionStickinessConfig: undefined,
    };
    if (output["Weight"] !== undefined) {
        contents.Weight = (0, smithy_client_1.strictParseFloat)(output["Weight"]);
    }
    if (output["SessionStickinessConfig"] !== undefined) {
        contents.SessionStickinessConfig = deserializeAws_restXmlSessionStickinessConfig(output["SessionStickinessConfig"], context);
    }
    return contents;
};
const deserializeAws_restXmlCookieNameList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const deserializeAws_restXmlCookieNames = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["Name"] !== undefined) {
        contents.Items = deserializeAws_restXmlCookieNameList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["Name"]), context);
    }
    return contents;
};
const deserializeAws_restXmlCookiePreference = (output, context) => {
    const contents = {
        Forward: undefined,
        WhitelistedNames: undefined,
    };
    if (output["Forward"] !== undefined) {
        contents.Forward = (0, smithy_client_1.expectString)(output["Forward"]);
    }
    if (output["WhitelistedNames"] !== undefined) {
        contents.WhitelistedNames = deserializeAws_restXmlCookieNames(output["WhitelistedNames"], context);
    }
    return contents;
};
const deserializeAws_restXmlCustomErrorResponse = (output, context) => {
    const contents = {
        ErrorCode: undefined,
        ResponsePagePath: undefined,
        ResponseCode: undefined,
        ErrorCachingMinTTL: undefined,
    };
    if (output["ErrorCode"] !== undefined) {
        contents.ErrorCode = (0, smithy_client_1.strictParseInt32)(output["ErrorCode"]);
    }
    if (output["ResponsePagePath"] !== undefined) {
        contents.ResponsePagePath = (0, smithy_client_1.expectString)(output["ResponsePagePath"]);
    }
    if (output["ResponseCode"] !== undefined) {
        contents.ResponseCode = (0, smithy_client_1.expectString)(output["ResponseCode"]);
    }
    if (output["ErrorCachingMinTTL"] !== undefined) {
        contents.ErrorCachingMinTTL = (0, smithy_client_1.strictParseLong)(output["ErrorCachingMinTTL"]);
    }
    return contents;
};
const deserializeAws_restXmlCustomErrorResponseList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlCustomErrorResponse(entry, context);
    });
};
const deserializeAws_restXmlCustomErrorResponses = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["CustomErrorResponse"] !== undefined) {
        contents.Items = deserializeAws_restXmlCustomErrorResponseList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["CustomErrorResponse"]), context);
    }
    return contents;
};
const deserializeAws_restXmlCustomHeaders = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["OriginCustomHeader"] !== undefined) {
        contents.Items = deserializeAws_restXmlOriginCustomHeadersList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["OriginCustomHeader"]), context);
    }
    return contents;
};
const deserializeAws_restXmlCustomOriginConfig = (output, context) => {
    const contents = {
        HTTPPort: undefined,
        HTTPSPort: undefined,
        OriginProtocolPolicy: undefined,
        OriginSslProtocols: undefined,
        OriginReadTimeout: undefined,
        OriginKeepaliveTimeout: undefined,
    };
    if (output["HTTPPort"] !== undefined) {
        contents.HTTPPort = (0, smithy_client_1.strictParseInt32)(output["HTTPPort"]);
    }
    if (output["HTTPSPort"] !== undefined) {
        contents.HTTPSPort = (0, smithy_client_1.strictParseInt32)(output["HTTPSPort"]);
    }
    if (output["OriginProtocolPolicy"] !== undefined) {
        contents.OriginProtocolPolicy = (0, smithy_client_1.expectString)(output["OriginProtocolPolicy"]);
    }
    if (output["OriginSslProtocols"] !== undefined) {
        contents.OriginSslProtocols = deserializeAws_restXmlOriginSslProtocols(output["OriginSslProtocols"], context);
    }
    if (output["OriginReadTimeout"] !== undefined) {
        contents.OriginReadTimeout = (0, smithy_client_1.strictParseInt32)(output["OriginReadTimeout"]);
    }
    if (output["OriginKeepaliveTimeout"] !== undefined) {
        contents.OriginKeepaliveTimeout = (0, smithy_client_1.strictParseInt32)(output["OriginKeepaliveTimeout"]);
    }
    return contents;
};
const deserializeAws_restXmlDefaultCacheBehavior = (output, context) => {
    const contents = {
        TargetOriginId: undefined,
        TrustedSigners: undefined,
        TrustedKeyGroups: undefined,
        ViewerProtocolPolicy: undefined,
        AllowedMethods: undefined,
        SmoothStreaming: undefined,
        Compress: undefined,
        LambdaFunctionAssociations: undefined,
        FunctionAssociations: undefined,
        FieldLevelEncryptionId: undefined,
        RealtimeLogConfigArn: undefined,
        CachePolicyId: undefined,
        OriginRequestPolicyId: undefined,
        ResponseHeadersPolicyId: undefined,
        ForwardedValues: undefined,
        MinTTL: undefined,
        DefaultTTL: undefined,
        MaxTTL: undefined,
    };
    if (output["TargetOriginId"] !== undefined) {
        contents.TargetOriginId = (0, smithy_client_1.expectString)(output["TargetOriginId"]);
    }
    if (output["TrustedSigners"] !== undefined) {
        contents.TrustedSigners = deserializeAws_restXmlTrustedSigners(output["TrustedSigners"], context);
    }
    if (output["TrustedKeyGroups"] !== undefined) {
        contents.TrustedKeyGroups = deserializeAws_restXmlTrustedKeyGroups(output["TrustedKeyGroups"], context);
    }
    if (output["ViewerProtocolPolicy"] !== undefined) {
        contents.ViewerProtocolPolicy = (0, smithy_client_1.expectString)(output["ViewerProtocolPolicy"]);
    }
    if (output["AllowedMethods"] !== undefined) {
        contents.AllowedMethods = deserializeAws_restXmlAllowedMethods(output["AllowedMethods"], context);
    }
    if (output["SmoothStreaming"] !== undefined) {
        contents.SmoothStreaming = (0, smithy_client_1.parseBoolean)(output["SmoothStreaming"]);
    }
    if (output["Compress"] !== undefined) {
        contents.Compress = (0, smithy_client_1.parseBoolean)(output["Compress"]);
    }
    if (output["LambdaFunctionAssociations"] !== undefined) {
        contents.LambdaFunctionAssociations = deserializeAws_restXmlLambdaFunctionAssociations(output["LambdaFunctionAssociations"], context);
    }
    if (output["FunctionAssociations"] !== undefined) {
        contents.FunctionAssociations = deserializeAws_restXmlFunctionAssociations(output["FunctionAssociations"], context);
    }
    if (output["FieldLevelEncryptionId"] !== undefined) {
        contents.FieldLevelEncryptionId = (0, smithy_client_1.expectString)(output["FieldLevelEncryptionId"]);
    }
    if (output["RealtimeLogConfigArn"] !== undefined) {
        contents.RealtimeLogConfigArn = (0, smithy_client_1.expectString)(output["RealtimeLogConfigArn"]);
    }
    if (output["CachePolicyId"] !== undefined) {
        contents.CachePolicyId = (0, smithy_client_1.expectString)(output["CachePolicyId"]);
    }
    if (output["OriginRequestPolicyId"] !== undefined) {
        contents.OriginRequestPolicyId = (0, smithy_client_1.expectString)(output["OriginRequestPolicyId"]);
    }
    if (output["ResponseHeadersPolicyId"] !== undefined) {
        contents.ResponseHeadersPolicyId = (0, smithy_client_1.expectString)(output["ResponseHeadersPolicyId"]);
    }
    if (output["ForwardedValues"] !== undefined) {
        contents.ForwardedValues = deserializeAws_restXmlForwardedValues(output["ForwardedValues"], context);
    }
    if (output["MinTTL"] !== undefined) {
        contents.MinTTL = (0, smithy_client_1.strictParseLong)(output["MinTTL"]);
    }
    if (output["DefaultTTL"] !== undefined) {
        contents.DefaultTTL = (0, smithy_client_1.strictParseLong)(output["DefaultTTL"]);
    }
    if (output["MaxTTL"] !== undefined) {
        contents.MaxTTL = (0, smithy_client_1.strictParseLong)(output["MaxTTL"]);
    }
    return contents;
};
const deserializeAws_restXmlDistribution = (output, context) => {
    const contents = {
        Id: undefined,
        ARN: undefined,
        Status: undefined,
        LastModifiedTime: undefined,
        InProgressInvalidationBatches: undefined,
        DomainName: undefined,
        ActiveTrustedSigners: undefined,
        ActiveTrustedKeyGroups: undefined,
        DistributionConfig: undefined,
        AliasICPRecordals: undefined,
    };
    if (output["Id"] !== undefined) {
        contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["ARN"] !== undefined) {
        contents.ARN = (0, smithy_client_1.expectString)(output["ARN"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
    }
    if (output["LastModifiedTime"] !== undefined) {
        contents.LastModifiedTime = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTime)(output["LastModifiedTime"]));
    }
    if (output["InProgressInvalidationBatches"] !== undefined) {
        contents.InProgressInvalidationBatches = (0, smithy_client_1.strictParseInt32)(output["InProgressInvalidationBatches"]);
    }
    if (output["DomainName"] !== undefined) {
        contents.DomainName = (0, smithy_client_1.expectString)(output["DomainName"]);
    }
    if (output["ActiveTrustedSigners"] !== undefined) {
        contents.ActiveTrustedSigners = deserializeAws_restXmlActiveTrustedSigners(output["ActiveTrustedSigners"], context);
    }
    if (output["ActiveTrustedKeyGroups"] !== undefined) {
        contents.ActiveTrustedKeyGroups = deserializeAws_restXmlActiveTrustedKeyGroups(output["ActiveTrustedKeyGroups"], context);
    }
    if (output["DistributionConfig"] !== undefined) {
        contents.DistributionConfig = deserializeAws_restXmlDistributionConfig(output["DistributionConfig"], context);
    }
    if (output.AliasICPRecordals === "") {
        contents.AliasICPRecordals = [];
    }
    else if (output["AliasICPRecordals"] !== undefined &&
        output["AliasICPRecordals"]["AliasICPRecordal"] !== undefined) {
        contents.AliasICPRecordals = deserializeAws_restXmlAliasICPRecordals((0, smithy_client_1.getArrayIfSingleItem)(output["AliasICPRecordals"]["AliasICPRecordal"]), context);
    }
    return contents;
};
const deserializeAws_restXmlDistributionConfig = (output, context) => {
    const contents = {
        CallerReference: undefined,
        Aliases: undefined,
        DefaultRootObject: undefined,
        Origins: undefined,
        OriginGroups: undefined,
        DefaultCacheBehavior: undefined,
        CacheBehaviors: undefined,
        CustomErrorResponses: undefined,
        Comment: undefined,
        Logging: undefined,
        PriceClass: undefined,
        Enabled: undefined,
        ViewerCertificate: undefined,
        Restrictions: undefined,
        WebACLId: undefined,
        HttpVersion: undefined,
        IsIPV6Enabled: undefined,
    };
    if (output["CallerReference"] !== undefined) {
        contents.CallerReference = (0, smithy_client_1.expectString)(output["CallerReference"]);
    }
    if (output["Aliases"] !== undefined) {
        contents.Aliases = deserializeAws_restXmlAliases(output["Aliases"], context);
    }
    if (output["DefaultRootObject"] !== undefined) {
        contents.DefaultRootObject = (0, smithy_client_1.expectString)(output["DefaultRootObject"]);
    }
    if (output["Origins"] !== undefined) {
        contents.Origins = deserializeAws_restXmlOrigins(output["Origins"], context);
    }
    if (output["OriginGroups"] !== undefined) {
        contents.OriginGroups = deserializeAws_restXmlOriginGroups(output["OriginGroups"], context);
    }
    if (output["DefaultCacheBehavior"] !== undefined) {
        contents.DefaultCacheBehavior = deserializeAws_restXmlDefaultCacheBehavior(output["DefaultCacheBehavior"], context);
    }
    if (output["CacheBehaviors"] !== undefined) {
        contents.CacheBehaviors = deserializeAws_restXmlCacheBehaviors(output["CacheBehaviors"], context);
    }
    if (output["CustomErrorResponses"] !== undefined) {
        contents.CustomErrorResponses = deserializeAws_restXmlCustomErrorResponses(output["CustomErrorResponses"], context);
    }
    if (output["Comment"] !== undefined) {
        contents.Comment = (0, smithy_client_1.expectString)(output["Comment"]);
    }
    if (output["Logging"] !== undefined) {
        contents.Logging = deserializeAws_restXmlLoggingConfig(output["Logging"], context);
    }
    if (output["PriceClass"] !== undefined) {
        contents.PriceClass = (0, smithy_client_1.expectString)(output["PriceClass"]);
    }
    if (output["Enabled"] !== undefined) {
        contents.Enabled = (0, smithy_client_1.parseBoolean)(output["Enabled"]);
    }
    if (output["ViewerCertificate"] !== undefined) {
        contents.ViewerCertificate = deserializeAws_restXmlViewerCertificate(output["ViewerCertificate"], context);
    }
    if (output["Restrictions"] !== undefined) {
        contents.Restrictions = deserializeAws_restXmlRestrictions(output["Restrictions"], context);
    }
    if (output["WebACLId"] !== undefined) {
        contents.WebACLId = (0, smithy_client_1.expectString)(output["WebACLId"]);
    }
    if (output["HttpVersion"] !== undefined) {
        contents.HttpVersion = (0, smithy_client_1.expectString)(output["HttpVersion"]);
    }
    if (output["IsIPV6Enabled"] !== undefined) {
        contents.IsIPV6Enabled = (0, smithy_client_1.parseBoolean)(output["IsIPV6Enabled"]);
    }
    return contents;
};
const deserializeAws_restXmlDistributionIdList = (output, context) => {
    const contents = {
        Marker: undefined,
        NextMarker: undefined,
        MaxItems: undefined,
        IsTruncated: undefined,
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    if (output["NextMarker"] !== undefined) {
        contents.NextMarker = (0, smithy_client_1.expectString)(output["NextMarker"]);
    }
    if (output["MaxItems"] !== undefined) {
        contents.MaxItems = (0, smithy_client_1.strictParseInt32)(output["MaxItems"]);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["DistributionId"] !== undefined) {
        contents.Items = deserializeAws_restXmlDistributionIdListSummary((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["DistributionId"]), context);
    }
    return contents;
};
const deserializeAws_restXmlDistributionIdListSummary = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const deserializeAws_restXmlDistributionList = (output, context) => {
    const contents = {
        Marker: undefined,
        NextMarker: undefined,
        MaxItems: undefined,
        IsTruncated: undefined,
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    if (output["NextMarker"] !== undefined) {
        contents.NextMarker = (0, smithy_client_1.expectString)(output["NextMarker"]);
    }
    if (output["MaxItems"] !== undefined) {
        contents.MaxItems = (0, smithy_client_1.strictParseInt32)(output["MaxItems"]);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["DistributionSummary"] !== undefined) {
        contents.Items = deserializeAws_restXmlDistributionSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["DistributionSummary"]), context);
    }
    return contents;
};
const deserializeAws_restXmlDistributionSummary = (output, context) => {
    const contents = {
        Id: undefined,
        ARN: undefined,
        Status: undefined,
        LastModifiedTime: undefined,
        DomainName: undefined,
        Aliases: undefined,
        Origins: undefined,
        OriginGroups: undefined,
        DefaultCacheBehavior: undefined,
        CacheBehaviors: undefined,
        CustomErrorResponses: undefined,
        Comment: undefined,
        PriceClass: undefined,
        Enabled: undefined,
        ViewerCertificate: undefined,
        Restrictions: undefined,
        WebACLId: undefined,
        HttpVersion: undefined,
        IsIPV6Enabled: undefined,
        AliasICPRecordals: undefined,
    };
    if (output["Id"] !== undefined) {
        contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["ARN"] !== undefined) {
        contents.ARN = (0, smithy_client_1.expectString)(output["ARN"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
    }
    if (output["LastModifiedTime"] !== undefined) {
        contents.LastModifiedTime = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTime)(output["LastModifiedTime"]));
    }
    if (output["DomainName"] !== undefined) {
        contents.DomainName = (0, smithy_client_1.expectString)(output["DomainName"]);
    }
    if (output["Aliases"] !== undefined) {
        contents.Aliases = deserializeAws_restXmlAliases(output["Aliases"], context);
    }
    if (output["Origins"] !== undefined) {
        contents.Origins = deserializeAws_restXmlOrigins(output["Origins"], context);
    }
    if (output["OriginGroups"] !== undefined) {
        contents.OriginGroups = deserializeAws_restXmlOriginGroups(output["OriginGroups"], context);
    }
    if (output["DefaultCacheBehavior"] !== undefined) {
        contents.DefaultCacheBehavior = deserializeAws_restXmlDefaultCacheBehavior(output["DefaultCacheBehavior"], context);
    }
    if (output["CacheBehaviors"] !== undefined) {
        contents.CacheBehaviors = deserializeAws_restXmlCacheBehaviors(output["CacheBehaviors"], context);
    }
    if (output["CustomErrorResponses"] !== undefined) {
        contents.CustomErrorResponses = deserializeAws_restXmlCustomErrorResponses(output["CustomErrorResponses"], context);
    }
    if (output["Comment"] !== undefined) {
        contents.Comment = (0, smithy_client_1.expectString)(output["Comment"]);
    }
    if (output["PriceClass"] !== undefined) {
        contents.PriceClass = (0, smithy_client_1.expectString)(output["PriceClass"]);
    }
    if (output["Enabled"] !== undefined) {
        contents.Enabled = (0, smithy_client_1.parseBoolean)(output["Enabled"]);
    }
    if (output["ViewerCertificate"] !== undefined) {
        contents.ViewerCertificate = deserializeAws_restXmlViewerCertificate(output["ViewerCertificate"], context);
    }
    if (output["Restrictions"] !== undefined) {
        contents.Restrictions = deserializeAws_restXmlRestrictions(output["Restrictions"], context);
    }
    if (output["WebACLId"] !== undefined) {
        contents.WebACLId = (0, smithy_client_1.expectString)(output["WebACLId"]);
    }
    if (output["HttpVersion"] !== undefined) {
        contents.HttpVersion = (0, smithy_client_1.expectString)(output["HttpVersion"]);
    }
    if (output["IsIPV6Enabled"] !== undefined) {
        contents.IsIPV6Enabled = (0, smithy_client_1.parseBoolean)(output["IsIPV6Enabled"]);
    }
    if (output.AliasICPRecordals === "") {
        contents.AliasICPRecordals = [];
    }
    else if (output["AliasICPRecordals"] !== undefined &&
        output["AliasICPRecordals"]["AliasICPRecordal"] !== undefined) {
        contents.AliasICPRecordals = deserializeAws_restXmlAliasICPRecordals((0, smithy_client_1.getArrayIfSingleItem)(output["AliasICPRecordals"]["AliasICPRecordal"]), context);
    }
    return contents;
};
const deserializeAws_restXmlDistributionSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlDistributionSummary(entry, context);
    });
};
const deserializeAws_restXmlEncryptionEntities = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["EncryptionEntity"] !== undefined) {
        contents.Items = deserializeAws_restXmlEncryptionEntityList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["EncryptionEntity"]), context);
    }
    return contents;
};
const deserializeAws_restXmlEncryptionEntity = (output, context) => {
    const contents = {
        PublicKeyId: undefined,
        ProviderId: undefined,
        FieldPatterns: undefined,
    };
    if (output["PublicKeyId"] !== undefined) {
        contents.PublicKeyId = (0, smithy_client_1.expectString)(output["PublicKeyId"]);
    }
    if (output["ProviderId"] !== undefined) {
        contents.ProviderId = (0, smithy_client_1.expectString)(output["ProviderId"]);
    }
    if (output["FieldPatterns"] !== undefined) {
        contents.FieldPatterns = deserializeAws_restXmlFieldPatterns(output["FieldPatterns"], context);
    }
    return contents;
};
const deserializeAws_restXmlEncryptionEntityList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlEncryptionEntity(entry, context);
    });
};
const deserializeAws_restXmlEndPoint = (output, context) => {
    const contents = {
        StreamType: undefined,
        KinesisStreamConfig: undefined,
    };
    if (output["StreamType"] !== undefined) {
        contents.StreamType = (0, smithy_client_1.expectString)(output["StreamType"]);
    }
    if (output["KinesisStreamConfig"] !== undefined) {
        contents.KinesisStreamConfig = deserializeAws_restXmlKinesisStreamConfig(output["KinesisStreamConfig"], context);
    }
    return contents;
};
const deserializeAws_restXmlEndPointList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlEndPoint(entry, context);
    });
};
const deserializeAws_restXmlFieldLevelEncryption = (output, context) => {
    const contents = {
        Id: undefined,
        LastModifiedTime: undefined,
        FieldLevelEncryptionConfig: undefined,
    };
    if (output["Id"] !== undefined) {
        contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["LastModifiedTime"] !== undefined) {
        contents.LastModifiedTime = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTime)(output["LastModifiedTime"]));
    }
    if (output["FieldLevelEncryptionConfig"] !== undefined) {
        contents.FieldLevelEncryptionConfig = deserializeAws_restXmlFieldLevelEncryptionConfig(output["FieldLevelEncryptionConfig"], context);
    }
    return contents;
};
const deserializeAws_restXmlFieldLevelEncryptionConfig = (output, context) => {
    const contents = {
        CallerReference: undefined,
        Comment: undefined,
        QueryArgProfileConfig: undefined,
        ContentTypeProfileConfig: undefined,
    };
    if (output["CallerReference"] !== undefined) {
        contents.CallerReference = (0, smithy_client_1.expectString)(output["CallerReference"]);
    }
    if (output["Comment"] !== undefined) {
        contents.Comment = (0, smithy_client_1.expectString)(output["Comment"]);
    }
    if (output["QueryArgProfileConfig"] !== undefined) {
        contents.QueryArgProfileConfig = deserializeAws_restXmlQueryArgProfileConfig(output["QueryArgProfileConfig"], context);
    }
    if (output["ContentTypeProfileConfig"] !== undefined) {
        contents.ContentTypeProfileConfig = deserializeAws_restXmlContentTypeProfileConfig(output["ContentTypeProfileConfig"], context);
    }
    return contents;
};
const deserializeAws_restXmlFieldLevelEncryptionList = (output, context) => {
    const contents = {
        NextMarker: undefined,
        MaxItems: undefined,
        Quantity: undefined,
        Items: undefined,
    };
    if (output["NextMarker"] !== undefined) {
        contents.NextMarker = (0, smithy_client_1.expectString)(output["NextMarker"]);
    }
    if (output["MaxItems"] !== undefined) {
        contents.MaxItems = (0, smithy_client_1.strictParseInt32)(output["MaxItems"]);
    }
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["FieldLevelEncryptionSummary"] !== undefined) {
        contents.Items = deserializeAws_restXmlFieldLevelEncryptionSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["FieldLevelEncryptionSummary"]), context);
    }
    return contents;
};
const deserializeAws_restXmlFieldLevelEncryptionProfile = (output, context) => {
    const contents = {
        Id: undefined,
        LastModifiedTime: undefined,
        FieldLevelEncryptionProfileConfig: undefined,
    };
    if (output["Id"] !== undefined) {
        contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["LastModifiedTime"] !== undefined) {
        contents.LastModifiedTime = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTime)(output["LastModifiedTime"]));
    }
    if (output["FieldLevelEncryptionProfileConfig"] !== undefined) {
        contents.FieldLevelEncryptionProfileConfig = deserializeAws_restXmlFieldLevelEncryptionProfileConfig(output["FieldLevelEncryptionProfileConfig"], context);
    }
    return contents;
};
const deserializeAws_restXmlFieldLevelEncryptionProfileConfig = (output, context) => {
    const contents = {
        Name: undefined,
        CallerReference: undefined,
        Comment: undefined,
        EncryptionEntities: undefined,
    };
    if (output["Name"] !== undefined) {
        contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
    }
    if (output["CallerReference"] !== undefined) {
        contents.CallerReference = (0, smithy_client_1.expectString)(output["CallerReference"]);
    }
    if (output["Comment"] !== undefined) {
        contents.Comment = (0, smithy_client_1.expectString)(output["Comment"]);
    }
    if (output["EncryptionEntities"] !== undefined) {
        contents.EncryptionEntities = deserializeAws_restXmlEncryptionEntities(output["EncryptionEntities"], context);
    }
    return contents;
};
const deserializeAws_restXmlFieldLevelEncryptionProfileList = (output, context) => {
    const contents = {
        NextMarker: undefined,
        MaxItems: undefined,
        Quantity: undefined,
        Items: undefined,
    };
    if (output["NextMarker"] !== undefined) {
        contents.NextMarker = (0, smithy_client_1.expectString)(output["NextMarker"]);
    }
    if (output["MaxItems"] !== undefined) {
        contents.MaxItems = (0, smithy_client_1.strictParseInt32)(output["MaxItems"]);
    }
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["FieldLevelEncryptionProfileSummary"] !== undefined) {
        contents.Items = deserializeAws_restXmlFieldLevelEncryptionProfileSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["FieldLevelEncryptionProfileSummary"]), context);
    }
    return contents;
};
const deserializeAws_restXmlFieldLevelEncryptionProfileSummary = (output, context) => {
    const contents = {
        Id: undefined,
        LastModifiedTime: undefined,
        Name: undefined,
        EncryptionEntities: undefined,
        Comment: undefined,
    };
    if (output["Id"] !== undefined) {
        contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["LastModifiedTime"] !== undefined) {
        contents.LastModifiedTime = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTime)(output["LastModifiedTime"]));
    }
    if (output["Name"] !== undefined) {
        contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
    }
    if (output["EncryptionEntities"] !== undefined) {
        contents.EncryptionEntities = deserializeAws_restXmlEncryptionEntities(output["EncryptionEntities"], context);
    }
    if (output["Comment"] !== undefined) {
        contents.Comment = (0, smithy_client_1.expectString)(output["Comment"]);
    }
    return contents;
};
const deserializeAws_restXmlFieldLevelEncryptionProfileSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlFieldLevelEncryptionProfileSummary(entry, context);
    });
};
const deserializeAws_restXmlFieldLevelEncryptionSummary = (output, context) => {
    const contents = {
        Id: undefined,
        LastModifiedTime: undefined,
        Comment: undefined,
        QueryArgProfileConfig: undefined,
        ContentTypeProfileConfig: undefined,
    };
    if (output["Id"] !== undefined) {
        contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["LastModifiedTime"] !== undefined) {
        contents.LastModifiedTime = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTime)(output["LastModifiedTime"]));
    }
    if (output["Comment"] !== undefined) {
        contents.Comment = (0, smithy_client_1.expectString)(output["Comment"]);
    }
    if (output["QueryArgProfileConfig"] !== undefined) {
        contents.QueryArgProfileConfig = deserializeAws_restXmlQueryArgProfileConfig(output["QueryArgProfileConfig"], context);
    }
    if (output["ContentTypeProfileConfig"] !== undefined) {
        contents.ContentTypeProfileConfig = deserializeAws_restXmlContentTypeProfileConfig(output["ContentTypeProfileConfig"], context);
    }
    return contents;
};
const deserializeAws_restXmlFieldLevelEncryptionSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlFieldLevelEncryptionSummary(entry, context);
    });
};
const deserializeAws_restXmlFieldList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const deserializeAws_restXmlFieldPatternList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const deserializeAws_restXmlFieldPatterns = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["FieldPattern"] !== undefined) {
        contents.Items = deserializeAws_restXmlFieldPatternList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["FieldPattern"]), context);
    }
    return contents;
};
const deserializeAws_restXmlForwardedValues = (output, context) => {
    const contents = {
        QueryString: undefined,
        Cookies: undefined,
        Headers: undefined,
        QueryStringCacheKeys: undefined,
    };
    if (output["QueryString"] !== undefined) {
        contents.QueryString = (0, smithy_client_1.parseBoolean)(output["QueryString"]);
    }
    if (output["Cookies"] !== undefined) {
        contents.Cookies = deserializeAws_restXmlCookiePreference(output["Cookies"], context);
    }
    if (output["Headers"] !== undefined) {
        contents.Headers = deserializeAws_restXmlHeaders(output["Headers"], context);
    }
    if (output["QueryStringCacheKeys"] !== undefined) {
        contents.QueryStringCacheKeys = deserializeAws_restXmlQueryStringCacheKeys(output["QueryStringCacheKeys"], context);
    }
    return contents;
};
const deserializeAws_restXmlFunctionAssociation = (output, context) => {
    const contents = {
        FunctionARN: undefined,
        EventType: undefined,
    };
    if (output["FunctionARN"] !== undefined) {
        contents.FunctionARN = (0, smithy_client_1.expectString)(output["FunctionARN"]);
    }
    if (output["EventType"] !== undefined) {
        contents.EventType = (0, smithy_client_1.expectString)(output["EventType"]);
    }
    return contents;
};
const deserializeAws_restXmlFunctionAssociationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlFunctionAssociation(entry, context);
    });
};
const deserializeAws_restXmlFunctionAssociations = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["FunctionAssociation"] !== undefined) {
        contents.Items = deserializeAws_restXmlFunctionAssociationList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["FunctionAssociation"]), context);
    }
    return contents;
};
const deserializeAws_restXmlFunctionConfig = (output, context) => {
    const contents = {
        Comment: undefined,
        Runtime: undefined,
    };
    if (output["Comment"] !== undefined) {
        contents.Comment = (0, smithy_client_1.expectString)(output["Comment"]);
    }
    if (output["Runtime"] !== undefined) {
        contents.Runtime = (0, smithy_client_1.expectString)(output["Runtime"]);
    }
    return contents;
};
const deserializeAws_restXmlFunctionExecutionLogList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const deserializeAws_restXmlFunctionList = (output, context) => {
    const contents = {
        NextMarker: undefined,
        MaxItems: undefined,
        Quantity: undefined,
        Items: undefined,
    };
    if (output["NextMarker"] !== undefined) {
        contents.NextMarker = (0, smithy_client_1.expectString)(output["NextMarker"]);
    }
    if (output["MaxItems"] !== undefined) {
        contents.MaxItems = (0, smithy_client_1.strictParseInt32)(output["MaxItems"]);
    }
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["FunctionSummary"] !== undefined) {
        contents.Items = deserializeAws_restXmlFunctionSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["FunctionSummary"]), context);
    }
    return contents;
};
const deserializeAws_restXmlFunctionMetadata = (output, context) => {
    const contents = {
        FunctionARN: undefined,
        Stage: undefined,
        CreatedTime: undefined,
        LastModifiedTime: undefined,
    };
    if (output["FunctionARN"] !== undefined) {
        contents.FunctionARN = (0, smithy_client_1.expectString)(output["FunctionARN"]);
    }
    if (output["Stage"] !== undefined) {
        contents.Stage = (0, smithy_client_1.expectString)(output["Stage"]);
    }
    if (output["CreatedTime"] !== undefined) {
        contents.CreatedTime = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTime)(output["CreatedTime"]));
    }
    if (output["LastModifiedTime"] !== undefined) {
        contents.LastModifiedTime = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTime)(output["LastModifiedTime"]));
    }
    return contents;
};
const deserializeAws_restXmlFunctionSummary = (output, context) => {
    const contents = {
        Name: undefined,
        Status: undefined,
        FunctionConfig: undefined,
        FunctionMetadata: undefined,
    };
    if (output["Name"] !== undefined) {
        contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
    }
    if (output["FunctionConfig"] !== undefined) {
        contents.FunctionConfig = deserializeAws_restXmlFunctionConfig(output["FunctionConfig"], context);
    }
    if (output["FunctionMetadata"] !== undefined) {
        contents.FunctionMetadata = deserializeAws_restXmlFunctionMetadata(output["FunctionMetadata"], context);
    }
    return contents;
};
const deserializeAws_restXmlFunctionSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlFunctionSummary(entry, context);
    });
};
const deserializeAws_restXmlGeoRestriction = (output, context) => {
    const contents = {
        RestrictionType: undefined,
        Quantity: undefined,
        Items: undefined,
    };
    if (output["RestrictionType"] !== undefined) {
        contents.RestrictionType = (0, smithy_client_1.expectString)(output["RestrictionType"]);
    }
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["Location"] !== undefined) {
        contents.Items = deserializeAws_restXmlLocationList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["Location"]), context);
    }
    return contents;
};
const deserializeAws_restXmlHeaderList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const deserializeAws_restXmlHeaders = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["Name"] !== undefined) {
        contents.Items = deserializeAws_restXmlHeaderList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["Name"]), context);
    }
    return contents;
};
const deserializeAws_restXmlInvalidation = (output, context) => {
    const contents = {
        Id: undefined,
        Status: undefined,
        CreateTime: undefined,
        InvalidationBatch: undefined,
    };
    if (output["Id"] !== undefined) {
        contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
    }
    if (output["CreateTime"] !== undefined) {
        contents.CreateTime = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTime)(output["CreateTime"]));
    }
    if (output["InvalidationBatch"] !== undefined) {
        contents.InvalidationBatch = deserializeAws_restXmlInvalidationBatch(output["InvalidationBatch"], context);
    }
    return contents;
};
const deserializeAws_restXmlInvalidationBatch = (output, context) => {
    const contents = {
        Paths: undefined,
        CallerReference: undefined,
    };
    if (output["Paths"] !== undefined) {
        contents.Paths = deserializeAws_restXmlPaths(output["Paths"], context);
    }
    if (output["CallerReference"] !== undefined) {
        contents.CallerReference = (0, smithy_client_1.expectString)(output["CallerReference"]);
    }
    return contents;
};
const deserializeAws_restXmlInvalidationList = (output, context) => {
    const contents = {
        Marker: undefined,
        NextMarker: undefined,
        MaxItems: undefined,
        IsTruncated: undefined,
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    if (output["NextMarker"] !== undefined) {
        contents.NextMarker = (0, smithy_client_1.expectString)(output["NextMarker"]);
    }
    if (output["MaxItems"] !== undefined) {
        contents.MaxItems = (0, smithy_client_1.strictParseInt32)(output["MaxItems"]);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["InvalidationSummary"] !== undefined) {
        contents.Items = deserializeAws_restXmlInvalidationSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["InvalidationSummary"]), context);
    }
    return contents;
};
const deserializeAws_restXmlInvalidationSummary = (output, context) => {
    const contents = {
        Id: undefined,
        CreateTime: undefined,
        Status: undefined,
    };
    if (output["Id"] !== undefined) {
        contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["CreateTime"] !== undefined) {
        contents.CreateTime = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTime)(output["CreateTime"]));
    }
    if (output["Status"] !== undefined) {
        contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
    }
    return contents;
};
const deserializeAws_restXmlInvalidationSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlInvalidationSummary(entry, context);
    });
};
const deserializeAws_restXmlKeyGroup = (output, context) => {
    const contents = {
        Id: undefined,
        LastModifiedTime: undefined,
        KeyGroupConfig: undefined,
    };
    if (output["Id"] !== undefined) {
        contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["LastModifiedTime"] !== undefined) {
        contents.LastModifiedTime = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTime)(output["LastModifiedTime"]));
    }
    if (output["KeyGroupConfig"] !== undefined) {
        contents.KeyGroupConfig = deserializeAws_restXmlKeyGroupConfig(output["KeyGroupConfig"], context);
    }
    return contents;
};
const deserializeAws_restXmlKeyGroupConfig = (output, context) => {
    const contents = {
        Name: undefined,
        Items: undefined,
        Comment: undefined,
    };
    if (output["Name"] !== undefined) {
        contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["PublicKey"] !== undefined) {
        contents.Items = deserializeAws_restXmlPublicKeyIdList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["PublicKey"]), context);
    }
    if (output["Comment"] !== undefined) {
        contents.Comment = (0, smithy_client_1.expectString)(output["Comment"]);
    }
    return contents;
};
const deserializeAws_restXmlKeyGroupList = (output, context) => {
    const contents = {
        NextMarker: undefined,
        MaxItems: undefined,
        Quantity: undefined,
        Items: undefined,
    };
    if (output["NextMarker"] !== undefined) {
        contents.NextMarker = (0, smithy_client_1.expectString)(output["NextMarker"]);
    }
    if (output["MaxItems"] !== undefined) {
        contents.MaxItems = (0, smithy_client_1.strictParseInt32)(output["MaxItems"]);
    }
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["KeyGroupSummary"] !== undefined) {
        contents.Items = deserializeAws_restXmlKeyGroupSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["KeyGroupSummary"]), context);
    }
    return contents;
};
const deserializeAws_restXmlKeyGroupSummary = (output, context) => {
    const contents = {
        KeyGroup: undefined,
    };
    if (output["KeyGroup"] !== undefined) {
        contents.KeyGroup = deserializeAws_restXmlKeyGroup(output["KeyGroup"], context);
    }
    return contents;
};
const deserializeAws_restXmlKeyGroupSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlKeyGroupSummary(entry, context);
    });
};
const deserializeAws_restXmlKeyPairIdList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const deserializeAws_restXmlKeyPairIds = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["KeyPairId"] !== undefined) {
        contents.Items = deserializeAws_restXmlKeyPairIdList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["KeyPairId"]), context);
    }
    return contents;
};
const deserializeAws_restXmlKGKeyPairIds = (output, context) => {
    const contents = {
        KeyGroupId: undefined,
        KeyPairIds: undefined,
    };
    if (output["KeyGroupId"] !== undefined) {
        contents.KeyGroupId = (0, smithy_client_1.expectString)(output["KeyGroupId"]);
    }
    if (output["KeyPairIds"] !== undefined) {
        contents.KeyPairIds = deserializeAws_restXmlKeyPairIds(output["KeyPairIds"], context);
    }
    return contents;
};
const deserializeAws_restXmlKGKeyPairIdsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlKGKeyPairIds(entry, context);
    });
};
const deserializeAws_restXmlKinesisStreamConfig = (output, context) => {
    const contents = {
        RoleARN: undefined,
        StreamARN: undefined,
    };
    if (output["RoleARN"] !== undefined) {
        contents.RoleARN = (0, smithy_client_1.expectString)(output["RoleARN"]);
    }
    if (output["StreamARN"] !== undefined) {
        contents.StreamARN = (0, smithy_client_1.expectString)(output["StreamARN"]);
    }
    return contents;
};
const deserializeAws_restXmlLambdaFunctionAssociation = (output, context) => {
    const contents = {
        LambdaFunctionARN: undefined,
        EventType: undefined,
        IncludeBody: undefined,
    };
    if (output["LambdaFunctionARN"] !== undefined) {
        contents.LambdaFunctionARN = (0, smithy_client_1.expectString)(output["LambdaFunctionARN"]);
    }
    if (output["EventType"] !== undefined) {
        contents.EventType = (0, smithy_client_1.expectString)(output["EventType"]);
    }
    if (output["IncludeBody"] !== undefined) {
        contents.IncludeBody = (0, smithy_client_1.parseBoolean)(output["IncludeBody"]);
    }
    return contents;
};
const deserializeAws_restXmlLambdaFunctionAssociationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlLambdaFunctionAssociation(entry, context);
    });
};
const deserializeAws_restXmlLambdaFunctionAssociations = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["LambdaFunctionAssociation"] !== undefined) {
        contents.Items = deserializeAws_restXmlLambdaFunctionAssociationList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["LambdaFunctionAssociation"]), context);
    }
    return contents;
};
const deserializeAws_restXmlLocationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const deserializeAws_restXmlLoggingConfig = (output, context) => {
    const contents = {
        Enabled: undefined,
        IncludeCookies: undefined,
        Bucket: undefined,
        Prefix: undefined,
    };
    if (output["Enabled"] !== undefined) {
        contents.Enabled = (0, smithy_client_1.parseBoolean)(output["Enabled"]);
    }
    if (output["IncludeCookies"] !== undefined) {
        contents.IncludeCookies = (0, smithy_client_1.parseBoolean)(output["IncludeCookies"]);
    }
    if (output["Bucket"] !== undefined) {
        contents.Bucket = (0, smithy_client_1.expectString)(output["Bucket"]);
    }
    if (output["Prefix"] !== undefined) {
        contents.Prefix = (0, smithy_client_1.expectString)(output["Prefix"]);
    }
    return contents;
};
const deserializeAws_restXmlMethodsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const deserializeAws_restXmlMonitoringSubscription = (output, context) => {
    const contents = {
        RealtimeMetricsSubscriptionConfig: undefined,
    };
    if (output["RealtimeMetricsSubscriptionConfig"] !== undefined) {
        contents.RealtimeMetricsSubscriptionConfig = deserializeAws_restXmlRealtimeMetricsSubscriptionConfig(output["RealtimeMetricsSubscriptionConfig"], context);
    }
    return contents;
};
const deserializeAws_restXmlOrigin = (output, context) => {
    const contents = {
        Id: undefined,
        DomainName: undefined,
        OriginPath: undefined,
        CustomHeaders: undefined,
        S3OriginConfig: undefined,
        CustomOriginConfig: undefined,
        ConnectionAttempts: undefined,
        ConnectionTimeout: undefined,
        OriginShield: undefined,
        OriginAccessControlId: undefined,
    };
    if (output["Id"] !== undefined) {
        contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["DomainName"] !== undefined) {
        contents.DomainName = (0, smithy_client_1.expectString)(output["DomainName"]);
    }
    if (output["OriginPath"] !== undefined) {
        contents.OriginPath = (0, smithy_client_1.expectString)(output["OriginPath"]);
    }
    if (output["CustomHeaders"] !== undefined) {
        contents.CustomHeaders = deserializeAws_restXmlCustomHeaders(output["CustomHeaders"], context);
    }
    if (output["S3OriginConfig"] !== undefined) {
        contents.S3OriginConfig = deserializeAws_restXmlS3OriginConfig(output["S3OriginConfig"], context);
    }
    if (output["CustomOriginConfig"] !== undefined) {
        contents.CustomOriginConfig = deserializeAws_restXmlCustomOriginConfig(output["CustomOriginConfig"], context);
    }
    if (output["ConnectionAttempts"] !== undefined) {
        contents.ConnectionAttempts = (0, smithy_client_1.strictParseInt32)(output["ConnectionAttempts"]);
    }
    if (output["ConnectionTimeout"] !== undefined) {
        contents.ConnectionTimeout = (0, smithy_client_1.strictParseInt32)(output["ConnectionTimeout"]);
    }
    if (output["OriginShield"] !== undefined) {
        contents.OriginShield = deserializeAws_restXmlOriginShield(output["OriginShield"], context);
    }
    if (output["OriginAccessControlId"] !== undefined) {
        contents.OriginAccessControlId = (0, smithy_client_1.expectString)(output["OriginAccessControlId"]);
    }
    return contents;
};
const deserializeAws_restXmlOriginAccessControl = (output, context) => {
    const contents = {
        Id: undefined,
        OriginAccessControlConfig: undefined,
    };
    if (output["Id"] !== undefined) {
        contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["OriginAccessControlConfig"] !== undefined) {
        contents.OriginAccessControlConfig = deserializeAws_restXmlOriginAccessControlConfig(output["OriginAccessControlConfig"], context);
    }
    return contents;
};
const deserializeAws_restXmlOriginAccessControlConfig = (output, context) => {
    const contents = {
        Name: undefined,
        Description: undefined,
        SigningProtocol: undefined,
        SigningBehavior: undefined,
        OriginAccessControlOriginType: undefined,
    };
    if (output["Name"] !== undefined) {
        contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
    }
    if (output["Description"] !== undefined) {
        contents.Description = (0, smithy_client_1.expectString)(output["Description"]);
    }
    if (output["SigningProtocol"] !== undefined) {
        contents.SigningProtocol = (0, smithy_client_1.expectString)(output["SigningProtocol"]);
    }
    if (output["SigningBehavior"] !== undefined) {
        contents.SigningBehavior = (0, smithy_client_1.expectString)(output["SigningBehavior"]);
    }
    if (output["OriginAccessControlOriginType"] !== undefined) {
        contents.OriginAccessControlOriginType = (0, smithy_client_1.expectString)(output["OriginAccessControlOriginType"]);
    }
    return contents;
};
const deserializeAws_restXmlOriginAccessControlList = (output, context) => {
    const contents = {
        Marker: undefined,
        NextMarker: undefined,
        MaxItems: undefined,
        IsTruncated: undefined,
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    if (output["NextMarker"] !== undefined) {
        contents.NextMarker = (0, smithy_client_1.expectString)(output["NextMarker"]);
    }
    if (output["MaxItems"] !== undefined) {
        contents.MaxItems = (0, smithy_client_1.strictParseInt32)(output["MaxItems"]);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["OriginAccessControlSummary"] !== undefined) {
        contents.Items = deserializeAws_restXmlOriginAccessControlSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["OriginAccessControlSummary"]), context);
    }
    return contents;
};
const deserializeAws_restXmlOriginAccessControlSummary = (output, context) => {
    const contents = {
        Id: undefined,
        Description: undefined,
        Name: undefined,
        SigningProtocol: undefined,
        SigningBehavior: undefined,
        OriginAccessControlOriginType: undefined,
    };
    if (output["Id"] !== undefined) {
        contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["Description"] !== undefined) {
        contents.Description = (0, smithy_client_1.expectString)(output["Description"]);
    }
    if (output["Name"] !== undefined) {
        contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
    }
    if (output["SigningProtocol"] !== undefined) {
        contents.SigningProtocol = (0, smithy_client_1.expectString)(output["SigningProtocol"]);
    }
    if (output["SigningBehavior"] !== undefined) {
        contents.SigningBehavior = (0, smithy_client_1.expectString)(output["SigningBehavior"]);
    }
    if (output["OriginAccessControlOriginType"] !== undefined) {
        contents.OriginAccessControlOriginType = (0, smithy_client_1.expectString)(output["OriginAccessControlOriginType"]);
    }
    return contents;
};
const deserializeAws_restXmlOriginAccessControlSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlOriginAccessControlSummary(entry, context);
    });
};
const deserializeAws_restXmlOriginCustomHeader = (output, context) => {
    const contents = {
        HeaderName: undefined,
        HeaderValue: undefined,
    };
    if (output["HeaderName"] !== undefined) {
        contents.HeaderName = (0, smithy_client_1.expectString)(output["HeaderName"]);
    }
    if (output["HeaderValue"] !== undefined) {
        contents.HeaderValue = (0, smithy_client_1.expectString)(output["HeaderValue"]);
    }
    return contents;
};
const deserializeAws_restXmlOriginCustomHeadersList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlOriginCustomHeader(entry, context);
    });
};
const deserializeAws_restXmlOriginGroup = (output, context) => {
    const contents = {
        Id: undefined,
        FailoverCriteria: undefined,
        Members: undefined,
    };
    if (output["Id"] !== undefined) {
        contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["FailoverCriteria"] !== undefined) {
        contents.FailoverCriteria = deserializeAws_restXmlOriginGroupFailoverCriteria(output["FailoverCriteria"], context);
    }
    if (output["Members"] !== undefined) {
        contents.Members = deserializeAws_restXmlOriginGroupMembers(output["Members"], context);
    }
    return contents;
};
const deserializeAws_restXmlOriginGroupFailoverCriteria = (output, context) => {
    const contents = {
        StatusCodes: undefined,
    };
    if (output["StatusCodes"] !== undefined) {
        contents.StatusCodes = deserializeAws_restXmlStatusCodes(output["StatusCodes"], context);
    }
    return contents;
};
const deserializeAws_restXmlOriginGroupList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlOriginGroup(entry, context);
    });
};
const deserializeAws_restXmlOriginGroupMember = (output, context) => {
    const contents = {
        OriginId: undefined,
    };
    if (output["OriginId"] !== undefined) {
        contents.OriginId = (0, smithy_client_1.expectString)(output["OriginId"]);
    }
    return contents;
};
const deserializeAws_restXmlOriginGroupMemberList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlOriginGroupMember(entry, context);
    });
};
const deserializeAws_restXmlOriginGroupMembers = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["OriginGroupMember"] !== undefined) {
        contents.Items = deserializeAws_restXmlOriginGroupMemberList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["OriginGroupMember"]), context);
    }
    return contents;
};
const deserializeAws_restXmlOriginGroups = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["OriginGroup"] !== undefined) {
        contents.Items = deserializeAws_restXmlOriginGroupList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["OriginGroup"]), context);
    }
    return contents;
};
const deserializeAws_restXmlOriginList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlOrigin(entry, context);
    });
};
const deserializeAws_restXmlOriginRequestPolicy = (output, context) => {
    const contents = {
        Id: undefined,
        LastModifiedTime: undefined,
        OriginRequestPolicyConfig: undefined,
    };
    if (output["Id"] !== undefined) {
        contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["LastModifiedTime"] !== undefined) {
        contents.LastModifiedTime = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTime)(output["LastModifiedTime"]));
    }
    if (output["OriginRequestPolicyConfig"] !== undefined) {
        contents.OriginRequestPolicyConfig = deserializeAws_restXmlOriginRequestPolicyConfig(output["OriginRequestPolicyConfig"], context);
    }
    return contents;
};
const deserializeAws_restXmlOriginRequestPolicyConfig = (output, context) => {
    const contents = {
        Comment: undefined,
        Name: undefined,
        HeadersConfig: undefined,
        CookiesConfig: undefined,
        QueryStringsConfig: undefined,
    };
    if (output["Comment"] !== undefined) {
        contents.Comment = (0, smithy_client_1.expectString)(output["Comment"]);
    }
    if (output["Name"] !== undefined) {
        contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
    }
    if (output["HeadersConfig"] !== undefined) {
        contents.HeadersConfig = deserializeAws_restXmlOriginRequestPolicyHeadersConfig(output["HeadersConfig"], context);
    }
    if (output["CookiesConfig"] !== undefined) {
        contents.CookiesConfig = deserializeAws_restXmlOriginRequestPolicyCookiesConfig(output["CookiesConfig"], context);
    }
    if (output["QueryStringsConfig"] !== undefined) {
        contents.QueryStringsConfig = deserializeAws_restXmlOriginRequestPolicyQueryStringsConfig(output["QueryStringsConfig"], context);
    }
    return contents;
};
const deserializeAws_restXmlOriginRequestPolicyCookiesConfig = (output, context) => {
    const contents = {
        CookieBehavior: undefined,
        Cookies: undefined,
    };
    if (output["CookieBehavior"] !== undefined) {
        contents.CookieBehavior = (0, smithy_client_1.expectString)(output["CookieBehavior"]);
    }
    if (output["Cookies"] !== undefined) {
        contents.Cookies = deserializeAws_restXmlCookieNames(output["Cookies"], context);
    }
    return contents;
};
const deserializeAws_restXmlOriginRequestPolicyHeadersConfig = (output, context) => {
    const contents = {
        HeaderBehavior: undefined,
        Headers: undefined,
    };
    if (output["HeaderBehavior"] !== undefined) {
        contents.HeaderBehavior = (0, smithy_client_1.expectString)(output["HeaderBehavior"]);
    }
    if (output["Headers"] !== undefined) {
        contents.Headers = deserializeAws_restXmlHeaders(output["Headers"], context);
    }
    return contents;
};
const deserializeAws_restXmlOriginRequestPolicyList = (output, context) => {
    const contents = {
        NextMarker: undefined,
        MaxItems: undefined,
        Quantity: undefined,
        Items: undefined,
    };
    if (output["NextMarker"] !== undefined) {
        contents.NextMarker = (0, smithy_client_1.expectString)(output["NextMarker"]);
    }
    if (output["MaxItems"] !== undefined) {
        contents.MaxItems = (0, smithy_client_1.strictParseInt32)(output["MaxItems"]);
    }
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["OriginRequestPolicySummary"] !== undefined) {
        contents.Items = deserializeAws_restXmlOriginRequestPolicySummaryList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["OriginRequestPolicySummary"]), context);
    }
    return contents;
};
const deserializeAws_restXmlOriginRequestPolicyQueryStringsConfig = (output, context) => {
    const contents = {
        QueryStringBehavior: undefined,
        QueryStrings: undefined,
    };
    if (output["QueryStringBehavior"] !== undefined) {
        contents.QueryStringBehavior = (0, smithy_client_1.expectString)(output["QueryStringBehavior"]);
    }
    if (output["QueryStrings"] !== undefined) {
        contents.QueryStrings = deserializeAws_restXmlQueryStringNames(output["QueryStrings"], context);
    }
    return contents;
};
const deserializeAws_restXmlOriginRequestPolicySummary = (output, context) => {
    const contents = {
        Type: undefined,
        OriginRequestPolicy: undefined,
    };
    if (output["Type"] !== undefined) {
        contents.Type = (0, smithy_client_1.expectString)(output["Type"]);
    }
    if (output["OriginRequestPolicy"] !== undefined) {
        contents.OriginRequestPolicy = deserializeAws_restXmlOriginRequestPolicy(output["OriginRequestPolicy"], context);
    }
    return contents;
};
const deserializeAws_restXmlOriginRequestPolicySummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlOriginRequestPolicySummary(entry, context);
    });
};
const deserializeAws_restXmlOrigins = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["Origin"] !== undefined) {
        contents.Items = deserializeAws_restXmlOriginList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["Origin"]), context);
    }
    return contents;
};
const deserializeAws_restXmlOriginShield = (output, context) => {
    const contents = {
        Enabled: undefined,
        OriginShieldRegion: undefined,
    };
    if (output["Enabled"] !== undefined) {
        contents.Enabled = (0, smithy_client_1.parseBoolean)(output["Enabled"]);
    }
    if (output["OriginShieldRegion"] !== undefined) {
        contents.OriginShieldRegion = (0, smithy_client_1.expectString)(output["OriginShieldRegion"]);
    }
    return contents;
};
const deserializeAws_restXmlOriginSslProtocols = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["SslProtocol"] !== undefined) {
        contents.Items = deserializeAws_restXmlSslProtocolsList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["SslProtocol"]), context);
    }
    return contents;
};
const deserializeAws_restXmlParametersInCacheKeyAndForwardedToOrigin = (output, context) => {
    const contents = {
        EnableAcceptEncodingGzip: undefined,
        EnableAcceptEncodingBrotli: undefined,
        HeadersConfig: undefined,
        CookiesConfig: undefined,
        QueryStringsConfig: undefined,
    };
    if (output["EnableAcceptEncodingGzip"] !== undefined) {
        contents.EnableAcceptEncodingGzip = (0, smithy_client_1.parseBoolean)(output["EnableAcceptEncodingGzip"]);
    }
    if (output["EnableAcceptEncodingBrotli"] !== undefined) {
        contents.EnableAcceptEncodingBrotli = (0, smithy_client_1.parseBoolean)(output["EnableAcceptEncodingBrotli"]);
    }
    if (output["HeadersConfig"] !== undefined) {
        contents.HeadersConfig = deserializeAws_restXmlCachePolicyHeadersConfig(output["HeadersConfig"], context);
    }
    if (output["CookiesConfig"] !== undefined) {
        contents.CookiesConfig = deserializeAws_restXmlCachePolicyCookiesConfig(output["CookiesConfig"], context);
    }
    if (output["QueryStringsConfig"] !== undefined) {
        contents.QueryStringsConfig = deserializeAws_restXmlCachePolicyQueryStringsConfig(output["QueryStringsConfig"], context);
    }
    return contents;
};
const deserializeAws_restXmlPathList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const deserializeAws_restXmlPaths = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["Path"] !== undefined) {
        contents.Items = deserializeAws_restXmlPathList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["Path"]), context);
    }
    return contents;
};
const deserializeAws_restXmlPublicKey = (output, context) => {
    const contents = {
        Id: undefined,
        CreatedTime: undefined,
        PublicKeyConfig: undefined,
    };
    if (output["Id"] !== undefined) {
        contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["CreatedTime"] !== undefined) {
        contents.CreatedTime = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTime)(output["CreatedTime"]));
    }
    if (output["PublicKeyConfig"] !== undefined) {
        contents.PublicKeyConfig = deserializeAws_restXmlPublicKeyConfig(output["PublicKeyConfig"], context);
    }
    return contents;
};
const deserializeAws_restXmlPublicKeyConfig = (output, context) => {
    const contents = {
        CallerReference: undefined,
        Name: undefined,
        EncodedKey: undefined,
        Comment: undefined,
    };
    if (output["CallerReference"] !== undefined) {
        contents.CallerReference = (0, smithy_client_1.expectString)(output["CallerReference"]);
    }
    if (output["Name"] !== undefined) {
        contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
    }
    if (output["EncodedKey"] !== undefined) {
        contents.EncodedKey = (0, smithy_client_1.expectString)(output["EncodedKey"]);
    }
    if (output["Comment"] !== undefined) {
        contents.Comment = (0, smithy_client_1.expectString)(output["Comment"]);
    }
    return contents;
};
const deserializeAws_restXmlPublicKeyIdList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const deserializeAws_restXmlPublicKeyList = (output, context) => {
    const contents = {
        NextMarker: undefined,
        MaxItems: undefined,
        Quantity: undefined,
        Items: undefined,
    };
    if (output["NextMarker"] !== undefined) {
        contents.NextMarker = (0, smithy_client_1.expectString)(output["NextMarker"]);
    }
    if (output["MaxItems"] !== undefined) {
        contents.MaxItems = (0, smithy_client_1.strictParseInt32)(output["MaxItems"]);
    }
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["PublicKeySummary"] !== undefined) {
        contents.Items = deserializeAws_restXmlPublicKeySummaryList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["PublicKeySummary"]), context);
    }
    return contents;
};
const deserializeAws_restXmlPublicKeySummary = (output, context) => {
    const contents = {
        Id: undefined,
        Name: undefined,
        CreatedTime: undefined,
        EncodedKey: undefined,
        Comment: undefined,
    };
    if (output["Id"] !== undefined) {
        contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["Name"] !== undefined) {
        contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
    }
    if (output["CreatedTime"] !== undefined) {
        contents.CreatedTime = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTime)(output["CreatedTime"]));
    }
    if (output["EncodedKey"] !== undefined) {
        contents.EncodedKey = (0, smithy_client_1.expectString)(output["EncodedKey"]);
    }
    if (output["Comment"] !== undefined) {
        contents.Comment = (0, smithy_client_1.expectString)(output["Comment"]);
    }
    return contents;
};
const deserializeAws_restXmlPublicKeySummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlPublicKeySummary(entry, context);
    });
};
const deserializeAws_restXmlQueryArgProfile = (output, context) => {
    const contents = {
        QueryArg: undefined,
        ProfileId: undefined,
    };
    if (output["QueryArg"] !== undefined) {
        contents.QueryArg = (0, smithy_client_1.expectString)(output["QueryArg"]);
    }
    if (output["ProfileId"] !== undefined) {
        contents.ProfileId = (0, smithy_client_1.expectString)(output["ProfileId"]);
    }
    return contents;
};
const deserializeAws_restXmlQueryArgProfileConfig = (output, context) => {
    const contents = {
        ForwardWhenQueryArgProfileIsUnknown: undefined,
        QueryArgProfiles: undefined,
    };
    if (output["ForwardWhenQueryArgProfileIsUnknown"] !== undefined) {
        contents.ForwardWhenQueryArgProfileIsUnknown = (0, smithy_client_1.parseBoolean)(output["ForwardWhenQueryArgProfileIsUnknown"]);
    }
    if (output["QueryArgProfiles"] !== undefined) {
        contents.QueryArgProfiles = deserializeAws_restXmlQueryArgProfiles(output["QueryArgProfiles"], context);
    }
    return contents;
};
const deserializeAws_restXmlQueryArgProfileList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlQueryArgProfile(entry, context);
    });
};
const deserializeAws_restXmlQueryArgProfiles = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["QueryArgProfile"] !== undefined) {
        contents.Items = deserializeAws_restXmlQueryArgProfileList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["QueryArgProfile"]), context);
    }
    return contents;
};
const deserializeAws_restXmlQueryStringCacheKeys = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["Name"] !== undefined) {
        contents.Items = deserializeAws_restXmlQueryStringCacheKeysList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["Name"]), context);
    }
    return contents;
};
const deserializeAws_restXmlQueryStringCacheKeysList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const deserializeAws_restXmlQueryStringNames = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["Name"] !== undefined) {
        contents.Items = deserializeAws_restXmlQueryStringNamesList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["Name"]), context);
    }
    return contents;
};
const deserializeAws_restXmlQueryStringNamesList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const deserializeAws_restXmlRealtimeLogConfig = (output, context) => {
    const contents = {
        ARN: undefined,
        Name: undefined,
        SamplingRate: undefined,
        EndPoints: undefined,
        Fields: undefined,
    };
    if (output["ARN"] !== undefined) {
        contents.ARN = (0, smithy_client_1.expectString)(output["ARN"]);
    }
    if (output["Name"] !== undefined) {
        contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
    }
    if (output["SamplingRate"] !== undefined) {
        contents.SamplingRate = (0, smithy_client_1.strictParseLong)(output["SamplingRate"]);
    }
    if (output.EndPoints === "") {
        contents.EndPoints = [];
    }
    else if (output["EndPoints"] !== undefined && output["EndPoints"]["member"] !== undefined) {
        contents.EndPoints = deserializeAws_restXmlEndPointList((0, smithy_client_1.getArrayIfSingleItem)(output["EndPoints"]["member"]), context);
    }
    if (output.Fields === "") {
        contents.Fields = [];
    }
    else if (output["Fields"] !== undefined && output["Fields"]["Field"] !== undefined) {
        contents.Fields = deserializeAws_restXmlFieldList((0, smithy_client_1.getArrayIfSingleItem)(output["Fields"]["Field"]), context);
    }
    return contents;
};
const deserializeAws_restXmlRealtimeLogConfigList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlRealtimeLogConfig(entry, context);
    });
};
const deserializeAws_restXmlRealtimeLogConfigs = (output, context) => {
    const contents = {
        MaxItems: undefined,
        Items: undefined,
        IsTruncated: undefined,
        Marker: undefined,
        NextMarker: undefined,
    };
    if (output["MaxItems"] !== undefined) {
        contents.MaxItems = (0, smithy_client_1.strictParseInt32)(output["MaxItems"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["member"] !== undefined) {
        contents.Items = deserializeAws_restXmlRealtimeLogConfigList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    if (output["NextMarker"] !== undefined) {
        contents.NextMarker = (0, smithy_client_1.expectString)(output["NextMarker"]);
    }
    return contents;
};
const deserializeAws_restXmlRealtimeMetricsSubscriptionConfig = (output, context) => {
    const contents = {
        RealtimeMetricsSubscriptionStatus: undefined,
    };
    if (output["RealtimeMetricsSubscriptionStatus"] !== undefined) {
        contents.RealtimeMetricsSubscriptionStatus = (0, smithy_client_1.expectString)(output["RealtimeMetricsSubscriptionStatus"]);
    }
    return contents;
};
const deserializeAws_restXmlResponseHeadersPolicy = (output, context) => {
    const contents = {
        Id: undefined,
        LastModifiedTime: undefined,
        ResponseHeadersPolicyConfig: undefined,
    };
    if (output["Id"] !== undefined) {
        contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["LastModifiedTime"] !== undefined) {
        contents.LastModifiedTime = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTime)(output["LastModifiedTime"]));
    }
    if (output["ResponseHeadersPolicyConfig"] !== undefined) {
        contents.ResponseHeadersPolicyConfig = deserializeAws_restXmlResponseHeadersPolicyConfig(output["ResponseHeadersPolicyConfig"], context);
    }
    return contents;
};
const deserializeAws_restXmlResponseHeadersPolicyAccessControlAllowHeaders = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["Header"] !== undefined) {
        contents.Items = deserializeAws_restXmlAccessControlAllowHeadersList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["Header"]), context);
    }
    return contents;
};
const deserializeAws_restXmlResponseHeadersPolicyAccessControlAllowMethods = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["Method"] !== undefined) {
        contents.Items = deserializeAws_restXmlAccessControlAllowMethodsList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["Method"]), context);
    }
    return contents;
};
const deserializeAws_restXmlResponseHeadersPolicyAccessControlAllowOrigins = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["Origin"] !== undefined) {
        contents.Items = deserializeAws_restXmlAccessControlAllowOriginsList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["Origin"]), context);
    }
    return contents;
};
const deserializeAws_restXmlResponseHeadersPolicyAccessControlExposeHeaders = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["Header"] !== undefined) {
        contents.Items = deserializeAws_restXmlAccessControlExposeHeadersList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["Header"]), context);
    }
    return contents;
};
const deserializeAws_restXmlResponseHeadersPolicyConfig = (output, context) => {
    const contents = {
        Comment: undefined,
        Name: undefined,
        CorsConfig: undefined,
        SecurityHeadersConfig: undefined,
        ServerTimingHeadersConfig: undefined,
        CustomHeadersConfig: undefined,
    };
    if (output["Comment"] !== undefined) {
        contents.Comment = (0, smithy_client_1.expectString)(output["Comment"]);
    }
    if (output["Name"] !== undefined) {
        contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
    }
    if (output["CorsConfig"] !== undefined) {
        contents.CorsConfig = deserializeAws_restXmlResponseHeadersPolicyCorsConfig(output["CorsConfig"], context);
    }
    if (output["SecurityHeadersConfig"] !== undefined) {
        contents.SecurityHeadersConfig = deserializeAws_restXmlResponseHeadersPolicySecurityHeadersConfig(output["SecurityHeadersConfig"], context);
    }
    if (output["ServerTimingHeadersConfig"] !== undefined) {
        contents.ServerTimingHeadersConfig = deserializeAws_restXmlResponseHeadersPolicyServerTimingHeadersConfig(output["ServerTimingHeadersConfig"], context);
    }
    if (output["CustomHeadersConfig"] !== undefined) {
        contents.CustomHeadersConfig = deserializeAws_restXmlResponseHeadersPolicyCustomHeadersConfig(output["CustomHeadersConfig"], context);
    }
    return contents;
};
const deserializeAws_restXmlResponseHeadersPolicyContentSecurityPolicy = (output, context) => {
    const contents = {
        Override: undefined,
        ContentSecurityPolicy: undefined,
    };
    if (output["Override"] !== undefined) {
        contents.Override = (0, smithy_client_1.parseBoolean)(output["Override"]);
    }
    if (output["ContentSecurityPolicy"] !== undefined) {
        contents.ContentSecurityPolicy = (0, smithy_client_1.expectString)(output["ContentSecurityPolicy"]);
    }
    return contents;
};
const deserializeAws_restXmlResponseHeadersPolicyContentTypeOptions = (output, context) => {
    const contents = {
        Override: undefined,
    };
    if (output["Override"] !== undefined) {
        contents.Override = (0, smithy_client_1.parseBoolean)(output["Override"]);
    }
    return contents;
};
const deserializeAws_restXmlResponseHeadersPolicyCorsConfig = (output, context) => {
    const contents = {
        AccessControlAllowOrigins: undefined,
        AccessControlAllowHeaders: undefined,
        AccessControlAllowMethods: undefined,
        AccessControlAllowCredentials: undefined,
        AccessControlExposeHeaders: undefined,
        AccessControlMaxAgeSec: undefined,
        OriginOverride: undefined,
    };
    if (output["AccessControlAllowOrigins"] !== undefined) {
        contents.AccessControlAllowOrigins = deserializeAws_restXmlResponseHeadersPolicyAccessControlAllowOrigins(output["AccessControlAllowOrigins"], context);
    }
    if (output["AccessControlAllowHeaders"] !== undefined) {
        contents.AccessControlAllowHeaders = deserializeAws_restXmlResponseHeadersPolicyAccessControlAllowHeaders(output["AccessControlAllowHeaders"], context);
    }
    if (output["AccessControlAllowMethods"] !== undefined) {
        contents.AccessControlAllowMethods = deserializeAws_restXmlResponseHeadersPolicyAccessControlAllowMethods(output["AccessControlAllowMethods"], context);
    }
    if (output["AccessControlAllowCredentials"] !== undefined) {
        contents.AccessControlAllowCredentials = (0, smithy_client_1.parseBoolean)(output["AccessControlAllowCredentials"]);
    }
    if (output["AccessControlExposeHeaders"] !== undefined) {
        contents.AccessControlExposeHeaders = deserializeAws_restXmlResponseHeadersPolicyAccessControlExposeHeaders(output["AccessControlExposeHeaders"], context);
    }
    if (output["AccessControlMaxAgeSec"] !== undefined) {
        contents.AccessControlMaxAgeSec = (0, smithy_client_1.strictParseInt32)(output["AccessControlMaxAgeSec"]);
    }
    if (output["OriginOverride"] !== undefined) {
        contents.OriginOverride = (0, smithy_client_1.parseBoolean)(output["OriginOverride"]);
    }
    return contents;
};
const deserializeAws_restXmlResponseHeadersPolicyCustomHeader = (output, context) => {
    const contents = {
        Header: undefined,
        Value: undefined,
        Override: undefined,
    };
    if (output["Header"] !== undefined) {
        contents.Header = (0, smithy_client_1.expectString)(output["Header"]);
    }
    if (output["Value"] !== undefined) {
        contents.Value = (0, smithy_client_1.expectString)(output["Value"]);
    }
    if (output["Override"] !== undefined) {
        contents.Override = (0, smithy_client_1.parseBoolean)(output["Override"]);
    }
    return contents;
};
const deserializeAws_restXmlResponseHeadersPolicyCustomHeaderList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlResponseHeadersPolicyCustomHeader(entry, context);
    });
};
const deserializeAws_restXmlResponseHeadersPolicyCustomHeadersConfig = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["ResponseHeadersPolicyCustomHeader"] !== undefined) {
        contents.Items = deserializeAws_restXmlResponseHeadersPolicyCustomHeaderList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["ResponseHeadersPolicyCustomHeader"]), context);
    }
    return contents;
};
const deserializeAws_restXmlResponseHeadersPolicyFrameOptions = (output, context) => {
    const contents = {
        Override: undefined,
        FrameOption: undefined,
    };
    if (output["Override"] !== undefined) {
        contents.Override = (0, smithy_client_1.parseBoolean)(output["Override"]);
    }
    if (output["FrameOption"] !== undefined) {
        contents.FrameOption = (0, smithy_client_1.expectString)(output["FrameOption"]);
    }
    return contents;
};
const deserializeAws_restXmlResponseHeadersPolicyList = (output, context) => {
    const contents = {
        NextMarker: undefined,
        MaxItems: undefined,
        Quantity: undefined,
        Items: undefined,
    };
    if (output["NextMarker"] !== undefined) {
        contents.NextMarker = (0, smithy_client_1.expectString)(output["NextMarker"]);
    }
    if (output["MaxItems"] !== undefined) {
        contents.MaxItems = (0, smithy_client_1.strictParseInt32)(output["MaxItems"]);
    }
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["ResponseHeadersPolicySummary"] !== undefined) {
        contents.Items = deserializeAws_restXmlResponseHeadersPolicySummaryList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["ResponseHeadersPolicySummary"]), context);
    }
    return contents;
};
const deserializeAws_restXmlResponseHeadersPolicyReferrerPolicy = (output, context) => {
    const contents = {
        Override: undefined,
        ReferrerPolicy: undefined,
    };
    if (output["Override"] !== undefined) {
        contents.Override = (0, smithy_client_1.parseBoolean)(output["Override"]);
    }
    if (output["ReferrerPolicy"] !== undefined) {
        contents.ReferrerPolicy = (0, smithy_client_1.expectString)(output["ReferrerPolicy"]);
    }
    return contents;
};
const deserializeAws_restXmlResponseHeadersPolicySecurityHeadersConfig = (output, context) => {
    const contents = {
        XSSProtection: undefined,
        FrameOptions: undefined,
        ReferrerPolicy: undefined,
        ContentSecurityPolicy: undefined,
        ContentTypeOptions: undefined,
        StrictTransportSecurity: undefined,
    };
    if (output["XSSProtection"] !== undefined) {
        contents.XSSProtection = deserializeAws_restXmlResponseHeadersPolicyXSSProtection(output["XSSProtection"], context);
    }
    if (output["FrameOptions"] !== undefined) {
        contents.FrameOptions = deserializeAws_restXmlResponseHeadersPolicyFrameOptions(output["FrameOptions"], context);
    }
    if (output["ReferrerPolicy"] !== undefined) {
        contents.ReferrerPolicy = deserializeAws_restXmlResponseHeadersPolicyReferrerPolicy(output["ReferrerPolicy"], context);
    }
    if (output["ContentSecurityPolicy"] !== undefined) {
        contents.ContentSecurityPolicy = deserializeAws_restXmlResponseHeadersPolicyContentSecurityPolicy(output["ContentSecurityPolicy"], context);
    }
    if (output["ContentTypeOptions"] !== undefined) {
        contents.ContentTypeOptions = deserializeAws_restXmlResponseHeadersPolicyContentTypeOptions(output["ContentTypeOptions"], context);
    }
    if (output["StrictTransportSecurity"] !== undefined) {
        contents.StrictTransportSecurity = deserializeAws_restXmlResponseHeadersPolicyStrictTransportSecurity(output["StrictTransportSecurity"], context);
    }
    return contents;
};
const deserializeAws_restXmlResponseHeadersPolicyServerTimingHeadersConfig = (output, context) => {
    const contents = {
        Enabled: undefined,
        SamplingRate: undefined,
    };
    if (output["Enabled"] !== undefined) {
        contents.Enabled = (0, smithy_client_1.parseBoolean)(output["Enabled"]);
    }
    if (output["SamplingRate"] !== undefined) {
        contents.SamplingRate = (0, smithy_client_1.strictParseFloat)(output["SamplingRate"]);
    }
    return contents;
};
const deserializeAws_restXmlResponseHeadersPolicyStrictTransportSecurity = (output, context) => {
    const contents = {
        Override: undefined,
        IncludeSubdomains: undefined,
        Preload: undefined,
        AccessControlMaxAgeSec: undefined,
    };
    if (output["Override"] !== undefined) {
        contents.Override = (0, smithy_client_1.parseBoolean)(output["Override"]);
    }
    if (output["IncludeSubdomains"] !== undefined) {
        contents.IncludeSubdomains = (0, smithy_client_1.parseBoolean)(output["IncludeSubdomains"]);
    }
    if (output["Preload"] !== undefined) {
        contents.Preload = (0, smithy_client_1.parseBoolean)(output["Preload"]);
    }
    if (output["AccessControlMaxAgeSec"] !== undefined) {
        contents.AccessControlMaxAgeSec = (0, smithy_client_1.strictParseInt32)(output["AccessControlMaxAgeSec"]);
    }
    return contents;
};
const deserializeAws_restXmlResponseHeadersPolicySummary = (output, context) => {
    const contents = {
        Type: undefined,
        ResponseHeadersPolicy: undefined,
    };
    if (output["Type"] !== undefined) {
        contents.Type = (0, smithy_client_1.expectString)(output["Type"]);
    }
    if (output["ResponseHeadersPolicy"] !== undefined) {
        contents.ResponseHeadersPolicy = deserializeAws_restXmlResponseHeadersPolicy(output["ResponseHeadersPolicy"], context);
    }
    return contents;
};
const deserializeAws_restXmlResponseHeadersPolicySummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlResponseHeadersPolicySummary(entry, context);
    });
};
const deserializeAws_restXmlResponseHeadersPolicyXSSProtection = (output, context) => {
    const contents = {
        Override: undefined,
        Protection: undefined,
        ModeBlock: undefined,
        ReportUri: undefined,
    };
    if (output["Override"] !== undefined) {
        contents.Override = (0, smithy_client_1.parseBoolean)(output["Override"]);
    }
    if (output["Protection"] !== undefined) {
        contents.Protection = (0, smithy_client_1.parseBoolean)(output["Protection"]);
    }
    if (output["ModeBlock"] !== undefined) {
        contents.ModeBlock = (0, smithy_client_1.parseBoolean)(output["ModeBlock"]);
    }
    if (output["ReportUri"] !== undefined) {
        contents.ReportUri = (0, smithy_client_1.expectString)(output["ReportUri"]);
    }
    return contents;
};
const deserializeAws_restXmlRestrictions = (output, context) => {
    const contents = {
        GeoRestriction: undefined,
    };
    if (output["GeoRestriction"] !== undefined) {
        contents.GeoRestriction = deserializeAws_restXmlGeoRestriction(output["GeoRestriction"], context);
    }
    return contents;
};
const deserializeAws_restXmlS3Origin = (output, context) => {
    const contents = {
        DomainName: undefined,
        OriginAccessIdentity: undefined,
    };
    if (output["DomainName"] !== undefined) {
        contents.DomainName = (0, smithy_client_1.expectString)(output["DomainName"]);
    }
    if (output["OriginAccessIdentity"] !== undefined) {
        contents.OriginAccessIdentity = (0, smithy_client_1.expectString)(output["OriginAccessIdentity"]);
    }
    return contents;
};
const deserializeAws_restXmlS3OriginConfig = (output, context) => {
    const contents = {
        OriginAccessIdentity: undefined,
    };
    if (output["OriginAccessIdentity"] !== undefined) {
        contents.OriginAccessIdentity = (0, smithy_client_1.expectString)(output["OriginAccessIdentity"]);
    }
    return contents;
};
const deserializeAws_restXmlSessionStickinessConfig = (output, context) => {
    const contents = {
        IdleTTL: undefined,
        MaximumTTL: undefined,
    };
    if (output["IdleTTL"] !== undefined) {
        contents.IdleTTL = (0, smithy_client_1.strictParseInt32)(output["IdleTTL"]);
    }
    if (output["MaximumTTL"] !== undefined) {
        contents.MaximumTTL = (0, smithy_client_1.strictParseInt32)(output["MaximumTTL"]);
    }
    return contents;
};
const deserializeAws_restXmlSigner = (output, context) => {
    const contents = {
        AwsAccountNumber: undefined,
        KeyPairIds: undefined,
    };
    if (output["AwsAccountNumber"] !== undefined) {
        contents.AwsAccountNumber = (0, smithy_client_1.expectString)(output["AwsAccountNumber"]);
    }
    if (output["KeyPairIds"] !== undefined) {
        contents.KeyPairIds = deserializeAws_restXmlKeyPairIds(output["KeyPairIds"], context);
    }
    return contents;
};
const deserializeAws_restXmlSignerList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlSigner(entry, context);
    });
};
const deserializeAws_restXmlSslProtocolsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const deserializeAws_restXmlStagingDistributionDnsNameList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const deserializeAws_restXmlStagingDistributionDnsNames = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["DnsName"] !== undefined) {
        contents.Items = deserializeAws_restXmlStagingDistributionDnsNameList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["DnsName"]), context);
    }
    return contents;
};
const deserializeAws_restXmlStatusCodeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.strictParseInt32)(entry);
    });
};
const deserializeAws_restXmlStatusCodes = (output, context) => {
    const contents = {
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["StatusCode"] !== undefined) {
        contents.Items = deserializeAws_restXmlStatusCodeList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["StatusCode"]), context);
    }
    return contents;
};
const deserializeAws_restXmlStreamingDistribution = (output, context) => {
    const contents = {
        Id: undefined,
        ARN: undefined,
        Status: undefined,
        LastModifiedTime: undefined,
        DomainName: undefined,
        ActiveTrustedSigners: undefined,
        StreamingDistributionConfig: undefined,
    };
    if (output["Id"] !== undefined) {
        contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["ARN"] !== undefined) {
        contents.ARN = (0, smithy_client_1.expectString)(output["ARN"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
    }
    if (output["LastModifiedTime"] !== undefined) {
        contents.LastModifiedTime = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTime)(output["LastModifiedTime"]));
    }
    if (output["DomainName"] !== undefined) {
        contents.DomainName = (0, smithy_client_1.expectString)(output["DomainName"]);
    }
    if (output["ActiveTrustedSigners"] !== undefined) {
        contents.ActiveTrustedSigners = deserializeAws_restXmlActiveTrustedSigners(output["ActiveTrustedSigners"], context);
    }
    if (output["StreamingDistributionConfig"] !== undefined) {
        contents.StreamingDistributionConfig = deserializeAws_restXmlStreamingDistributionConfig(output["StreamingDistributionConfig"], context);
    }
    return contents;
};
const deserializeAws_restXmlStreamingDistributionConfig = (output, context) => {
    const contents = {
        CallerReference: undefined,
        S3Origin: undefined,
        Aliases: undefined,
        Comment: undefined,
        Logging: undefined,
        TrustedSigners: undefined,
        PriceClass: undefined,
        Enabled: undefined,
    };
    if (output["CallerReference"] !== undefined) {
        contents.CallerReference = (0, smithy_client_1.expectString)(output["CallerReference"]);
    }
    if (output["S3Origin"] !== undefined) {
        contents.S3Origin = deserializeAws_restXmlS3Origin(output["S3Origin"], context);
    }
    if (output["Aliases"] !== undefined) {
        contents.Aliases = deserializeAws_restXmlAliases(output["Aliases"], context);
    }
    if (output["Comment"] !== undefined) {
        contents.Comment = (0, smithy_client_1.expectString)(output["Comment"]);
    }
    if (output["Logging"] !== undefined) {
        contents.Logging = deserializeAws_restXmlStreamingLoggingConfig(output["Logging"], context);
    }
    if (output["TrustedSigners"] !== undefined) {
        contents.TrustedSigners = deserializeAws_restXmlTrustedSigners(output["TrustedSigners"], context);
    }
    if (output["PriceClass"] !== undefined) {
        contents.PriceClass = (0, smithy_client_1.expectString)(output["PriceClass"]);
    }
    if (output["Enabled"] !== undefined) {
        contents.Enabled = (0, smithy_client_1.parseBoolean)(output["Enabled"]);
    }
    return contents;
};
const deserializeAws_restXmlStreamingDistributionList = (output, context) => {
    const contents = {
        Marker: undefined,
        NextMarker: undefined,
        MaxItems: undefined,
        IsTruncated: undefined,
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Marker"] !== undefined) {
        contents.Marker = (0, smithy_client_1.expectString)(output["Marker"]);
    }
    if (output["NextMarker"] !== undefined) {
        contents.NextMarker = (0, smithy_client_1.expectString)(output["NextMarker"]);
    }
    if (output["MaxItems"] !== undefined) {
        contents.MaxItems = (0, smithy_client_1.strictParseInt32)(output["MaxItems"]);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = (0, smithy_client_1.parseBoolean)(output["IsTruncated"]);
    }
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["StreamingDistributionSummary"] !== undefined) {
        contents.Items = deserializeAws_restXmlStreamingDistributionSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["StreamingDistributionSummary"]), context);
    }
    return contents;
};
const deserializeAws_restXmlStreamingDistributionSummary = (output, context) => {
    const contents = {
        Id: undefined,
        ARN: undefined,
        Status: undefined,
        LastModifiedTime: undefined,
        DomainName: undefined,
        S3Origin: undefined,
        Aliases: undefined,
        TrustedSigners: undefined,
        Comment: undefined,
        PriceClass: undefined,
        Enabled: undefined,
    };
    if (output["Id"] !== undefined) {
        contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["ARN"] !== undefined) {
        contents.ARN = (0, smithy_client_1.expectString)(output["ARN"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
    }
    if (output["LastModifiedTime"] !== undefined) {
        contents.LastModifiedTime = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTime)(output["LastModifiedTime"]));
    }
    if (output["DomainName"] !== undefined) {
        contents.DomainName = (0, smithy_client_1.expectString)(output["DomainName"]);
    }
    if (output["S3Origin"] !== undefined) {
        contents.S3Origin = deserializeAws_restXmlS3Origin(output["S3Origin"], context);
    }
    if (output["Aliases"] !== undefined) {
        contents.Aliases = deserializeAws_restXmlAliases(output["Aliases"], context);
    }
    if (output["TrustedSigners"] !== undefined) {
        contents.TrustedSigners = deserializeAws_restXmlTrustedSigners(output["TrustedSigners"], context);
    }
    if (output["Comment"] !== undefined) {
        contents.Comment = (0, smithy_client_1.expectString)(output["Comment"]);
    }
    if (output["PriceClass"] !== undefined) {
        contents.PriceClass = (0, smithy_client_1.expectString)(output["PriceClass"]);
    }
    if (output["Enabled"] !== undefined) {
        contents.Enabled = (0, smithy_client_1.parseBoolean)(output["Enabled"]);
    }
    return contents;
};
const deserializeAws_restXmlStreamingDistributionSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlStreamingDistributionSummary(entry, context);
    });
};
const deserializeAws_restXmlStreamingLoggingConfig = (output, context) => {
    const contents = {
        Enabled: undefined,
        Bucket: undefined,
        Prefix: undefined,
    };
    if (output["Enabled"] !== undefined) {
        contents.Enabled = (0, smithy_client_1.parseBoolean)(output["Enabled"]);
    }
    if (output["Bucket"] !== undefined) {
        contents.Bucket = (0, smithy_client_1.expectString)(output["Bucket"]);
    }
    if (output["Prefix"] !== undefined) {
        contents.Prefix = (0, smithy_client_1.expectString)(output["Prefix"]);
    }
    return contents;
};
const deserializeAws_restXmlTag = (output, context) => {
    const contents = {
        Key: undefined,
        Value: undefined,
    };
    if (output["Key"] !== undefined) {
        contents.Key = (0, smithy_client_1.expectString)(output["Key"]);
    }
    if (output["Value"] !== undefined) {
        contents.Value = (0, smithy_client_1.expectString)(output["Value"]);
    }
    return contents;
};
const deserializeAws_restXmlTagList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return deserializeAws_restXmlTag(entry, context);
    });
};
const deserializeAws_restXmlTags = (output, context) => {
    const contents = {
        Items: undefined,
    };
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["Tag"] !== undefined) {
        contents.Items = deserializeAws_restXmlTagList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["Tag"]), context);
    }
    return contents;
};
const deserializeAws_restXmlTestResult = (output, context) => {
    const contents = {
        FunctionSummary: undefined,
        ComputeUtilization: undefined,
        FunctionExecutionLogs: undefined,
        FunctionErrorMessage: undefined,
        FunctionOutput: undefined,
    };
    if (output["FunctionSummary"] !== undefined) {
        contents.FunctionSummary = deserializeAws_restXmlFunctionSummary(output["FunctionSummary"], context);
    }
    if (output["ComputeUtilization"] !== undefined) {
        contents.ComputeUtilization = (0, smithy_client_1.expectString)(output["ComputeUtilization"]);
    }
    if (output.FunctionExecutionLogs === "") {
        contents.FunctionExecutionLogs = [];
    }
    else if (output["FunctionExecutionLogs"] !== undefined && output["FunctionExecutionLogs"]["member"] !== undefined) {
        contents.FunctionExecutionLogs = deserializeAws_restXmlFunctionExecutionLogList((0, smithy_client_1.getArrayIfSingleItem)(output["FunctionExecutionLogs"]["member"]), context);
    }
    if (output["FunctionErrorMessage"] !== undefined) {
        contents.FunctionErrorMessage = (0, smithy_client_1.expectString)(output["FunctionErrorMessage"]);
    }
    if (output["FunctionOutput"] !== undefined) {
        contents.FunctionOutput = (0, smithy_client_1.expectString)(output["FunctionOutput"]);
    }
    return contents;
};
const deserializeAws_restXmlTrafficConfig = (output, context) => {
    const contents = {
        SingleWeightConfig: undefined,
        SingleHeaderConfig: undefined,
        Type: undefined,
    };
    if (output["SingleWeightConfig"] !== undefined) {
        contents.SingleWeightConfig = deserializeAws_restXmlContinuousDeploymentSingleWeightConfig(output["SingleWeightConfig"], context);
    }
    if (output["SingleHeaderConfig"] !== undefined) {
        contents.SingleHeaderConfig = deserializeAws_restXmlContinuousDeploymentSingleHeaderConfig(output["SingleHeaderConfig"], context);
    }
    if (output["Type"] !== undefined) {
        contents.Type = (0, smithy_client_1.expectString)(output["Type"]);
    }
    return contents;
};
const deserializeAws_restXmlTrustedKeyGroupIdList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const deserializeAws_restXmlTrustedKeyGroups = (output, context) => {
    const contents = {
        Enabled: undefined,
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Enabled"] !== undefined) {
        contents.Enabled = (0, smithy_client_1.parseBoolean)(output["Enabled"]);
    }
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["KeyGroup"] !== undefined) {
        contents.Items = deserializeAws_restXmlTrustedKeyGroupIdList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["KeyGroup"]), context);
    }
    return contents;
};
const deserializeAws_restXmlTrustedSigners = (output, context) => {
    const contents = {
        Enabled: undefined,
        Quantity: undefined,
        Items: undefined,
    };
    if (output["Enabled"] !== undefined) {
        contents.Enabled = (0, smithy_client_1.parseBoolean)(output["Enabled"]);
    }
    if (output["Quantity"] !== undefined) {
        contents.Quantity = (0, smithy_client_1.strictParseInt32)(output["Quantity"]);
    }
    if (output.Items === "") {
        contents.Items = [];
    }
    else if (output["Items"] !== undefined && output["Items"]["AwsAccountNumber"] !== undefined) {
        contents.Items = deserializeAws_restXmlAwsAccountNumberList((0, smithy_client_1.getArrayIfSingleItem)(output["Items"]["AwsAccountNumber"]), context);
    }
    return contents;
};
const deserializeAws_restXmlViewerCertificate = (output, context) => {
    const contents = {
        CloudFrontDefaultCertificate: undefined,
        IAMCertificateId: undefined,
        ACMCertificateArn: undefined,
        SSLSupportMethod: undefined,
        MinimumProtocolVersion: undefined,
        Certificate: undefined,
        CertificateSource: undefined,
    };
    if (output["CloudFrontDefaultCertificate"] !== undefined) {
        contents.CloudFrontDefaultCertificate = (0, smithy_client_1.parseBoolean)(output["CloudFrontDefaultCertificate"]);
    }
    if (output["IAMCertificateId"] !== undefined) {
        contents.IAMCertificateId = (0, smithy_client_1.expectString)(output["IAMCertificateId"]);
    }
    if (output["ACMCertificateArn"] !== undefined) {
        contents.ACMCertificateArn = (0, smithy_client_1.expectString)(output["ACMCertificateArn"]);
    }
    if (output["SSLSupportMethod"] !== undefined) {
        contents.SSLSupportMethod = (0, smithy_client_1.expectString)(output["SSLSupportMethod"]);
    }
    if (output["MinimumProtocolVersion"] !== undefined) {
        contents.MinimumProtocolVersion = (0, smithy_client_1.expectString)(output["MinimumProtocolVersion"]);
    }
    if (output["Certificate"] !== undefined) {
        contents.Certificate = (0, smithy_client_1.expectString)(output["Certificate"]);
    }
    if (output["CertificateSource"] !== undefined) {
        contents.CertificateSource = (0, smithy_client_1.expectString)(output["CertificateSource"]);
    }
    return contents;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        const parser = new fast_xml_parser_1.XMLParser({
            attributeNamePrefix: "",
            htmlEntities: true,
            ignoreAttributes: false,
            ignoreDeclaration: true,
            parseTagValue: false,
            trimValues: false,
            tagValueProcessor: (_, val) => (val.trim() === "" && val.includes("\n") ? "" : undefined),
        });
        parser.addEntity("#xD", "\r");
        parser.addEntity("#10", "\n");
        const parsedObj = parser.parse(encoded);
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
            parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
            delete parsedObjToReturn[textNodeName];
        }
        return (0, smithy_client_1.getValueFromTextNode)(parsedObjToReturn);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
};
const loadRestXmlErrorCode = (output, data) => {
    if (data.Error.Code !== undefined) {
        return data.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};
